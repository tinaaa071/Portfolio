import "./chunk-DGUM43GV.js";

// node_modules/vue-spline/dist/index.js
(function(h, Fa) {
  "object" === typeof exports && "undefined" !== typeof module ? Fa(exports) : "function" === typeof define && define.amd ? define(["exports"], Fa) : (h = h || self, Fa(h.THREE = {}));
})(void 0, function(h) {
  function Fa() {
  }
  function w(a, b) {
    this.x = a || 0;
    this.y = b || 0;
  }
  function za() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  function Z(a, b, c, d, e, f, g, k, l, m) {
    Object.defineProperty(this, "id", { value: pj++ });
    this.uuid = P.generateUUID();
    this.name = "";
    this.image = void 0 !== a ? a : Z.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = void 0 !== b ? b : Z.DEFAULT_MAPPING;
    this.wrapS = void 0 !== c ? c : 1001;
    this.wrapT = void 0 !== d ? d : 1001;
    this.magFilter = void 0 !== e ? e : 1006;
    this.minFilter = void 0 !== f ? f : 1008;
    this.anisotropy = void 0 !== l ? l : 1;
    this.format = void 0 !== g ? g : 1023;
    this.internalFormat = null;
    this.type = void 0 !== k ? k : 1009;
    this.offset = new w(0, 0);
    this.repeat = new w(1, 1);
    this.center = new w(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new za();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = void 0 !== m ? m : 3e3;
    this.version = 0;
    this.onUpdate = null;
  }
  function ia(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = void 0 !== d ? d : 1;
  }
  function wa(a, b, c) {
    this.width = a;
    this.height = b;
    this.scissor = new ia(0, 0, a, b);
    this.scissorTest = false;
    this.viewport = new ia(0, 0, a, b);
    c = c || {};
    this.texture = new Z(void 0, c.mapping, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding);
    this.texture.image = {};
    this.texture.image.width = a;
    this.texture.image.height = b;
    this.texture.generateMipmaps = void 0 !== c.generateMipmaps ? c.generateMipmaps : false;
    this.texture.minFilter = void 0 !== c.minFilter ? c.minFilter : 1006;
    this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : true;
    this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : true;
    this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null;
  }
  function $f(a, b, c) {
    wa.call(this, a, b, c);
    this.samples = 4;
  }
  function Da(a, b, c, d) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._w = void 0 !== d ? d : 1;
  }
  function n(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
  }
  function O() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  function Ub(a, b, c, d) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._order = d || Ub.DefaultOrder;
  }
  function ag() {
    this.mask = 1;
  }
  function D() {
    Object.defineProperty(this, "id", { value: qj++ });
    this.uuid = P.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = D.DefaultUp.clone();
    var a = new n(), b = new Ub(), c = new Da(), d = new n(1, 1, 1);
    b._onChange(function() {
      c.setFromEuler(b, false);
    });
    c._onChange(function() {
      b.setFromQuaternion(c, void 0, false);
    });
    Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: a }, rotation: { configurable: true, enumerable: true, value: b }, quaternion: { configurable: true, enumerable: true, value: c }, scale: { configurable: true, enumerable: true, value: d }, modelViewMatrix: { value: new O() }, normalMatrix: { value: new za() } });
    this.matrix = new O();
    this.matrixWorld = new O();
    this.matrixAutoUpdate = D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new ag();
    this.visible = true;
    this.receiveShadow = this.castShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
  }
  function pb() {
    D.call(this);
    this.type = "Scene";
    this.overrideMaterial = this.fog = this.environment = this.background = null;
    this.autoUpdate = true;
    "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  function Ta(a, b) {
    this.min = void 0 !== a ? a : new n(Infinity, Infinity, Infinity);
    this.max = void 0 !== b ? b : new n(-Infinity, -Infinity, -Infinity);
  }
  function bg(a, b, c, d, e) {
    var f;
    var g = 0;
    for (f = a.length - 3; g <= f; g += 3) {
      Vb.fromArray(a, g);
      var k = e.x * Math.abs(Vb.x) + e.y * Math.abs(Vb.y) + e.z * Math.abs(Vb.z), l = b.dot(Vb), m = c.dot(Vb), x = d.dot(Vb);
      if (Math.max(-Math.max(l, m, x), Math.min(l, m, x)) > k) return false;
    }
    return true;
  }
  function qb(a, b) {
    this.center = void 0 !== a ? a : new n();
    this.radius = void 0 !== b ? b : 0;
  }
  function Wb(a, b) {
    this.origin = void 0 !== a ? a : new n();
    this.direction = void 0 !== b ? b : new n(0, 0, -1);
  }
  function Ua(a, b) {
    this.normal = void 0 !== a ? a : new n(
      1,
      0,
      0
    );
    this.constant = void 0 !== b ? b : 0;
  }
  function oa(a, b, c) {
    this.a = void 0 !== a ? a : new n();
    this.b = void 0 !== b ? b : new n();
    this.c = void 0 !== c ? c : new n();
  }
  function B(a, b, c) {
    return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c);
  }
  function cg(a, b, c) {
    0 > c && (c += 1);
    1 < c && --c;
    return c < 1 / 6 ? a + 6 * (b - a) * c : 0.5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;
  }
  function dg(a) {
    return 0.04045 > a ? 0.0773993808 * a : Math.pow(0.9478672986 * a + 0.0521327014, 2.4);
  }
  function eg(a) {
    return 31308e-7 > a ? 12.92 * a : 1.055 * Math.pow(a, 0.41666) - 0.055;
  }
  function Bc(a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = d && d.isVector3 ? d : new n();
    this.vertexNormals = Array.isArray(d) ? d : [];
    this.color = e && e.isColor ? e : new B();
    this.vertexColors = Array.isArray(e) ? e : [];
    this.materialIndex = void 0 !== f ? f : 0;
  }
  function K() {
    Object.defineProperty(this, "id", { value: rj++ });
    this.uuid = P.generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.blending = 1;
    this.side = 0;
    this.vertexTangents = this.flatShading = false;
    this.vertexColors = 0;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = 204;
    this.blendDst = 205;
    this.blendEquation = 100;
    this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
    this.depthFunc = 3;
    this.depthWrite = this.depthTest = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = 519;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilZPass = this.stencilZFail = this.stencilFail = 7680;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipShadows = this.clipIntersection = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.toneMapped = this.visible = true;
    this.userData = {};
    this.version = 0;
  }
  function Pa(a) {
    K.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new B(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphTargets = this.skinning = false;
    this.setValues(a);
  }
  function M(a, b, c) {
    if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.name = "";
    this.array = a;
    this.itemSize = b;
    this.count = void 0 !== a ? a.length / b : 0;
    this.normalized = true === c;
    this.usage = 35044;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  function Cd(a, b, c) {
    M.call(this, new Int8Array(a), b, c);
  }
  function Dd(a, b, c) {
    M.call(this, new Uint8Array(a), b, c);
  }
  function Ed(a, b, c) {
    M.call(this, new Uint8ClampedArray(a), b, c);
  }
  function Fd(a, b, c) {
    M.call(this, new Int16Array(a), b, c);
  }
  function Xb(a, b, c) {
    M.call(this, new Uint16Array(a), b, c);
  }
  function Gd(a, b, c) {
    M.call(this, new Int32Array(a), b, c);
  }
  function Yb(a, b, c) {
    M.call(this, new Uint32Array(a), b, c);
  }
  function E(a, b, c) {
    M.call(this, new Float32Array(a), b, c);
  }
  function Hd(a, b, c) {
    M.call(this, new Float64Array(a), b, c);
  }
  function xh() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = false;
  }
  function yh(a) {
    if (0 === a.length) return -Infinity;
    for (var b = a[0], c = 1, d = a.length; c < d; ++c) a[c] > b && (b = a[c]);
    return b;
  }
  function A() {
    Object.defineProperty(this, "id", { value: sj += 2 });
    this.uuid = P.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  function ca(a, b) {
    D.call(this);
    this.type = "Mesh";
    this.geometry = void 0 !== a ? a : new A();
    this.material = void 0 !== b ? b : new Pa();
    this.updateMorphTargets();
  }
  function zh(a, b, c, d, e, f, g, k) {
    if (null === (1 === b.side ? d.intersectTriangle(g, f, e, true, k) : d.intersectTriangle(e, f, g, 2 !== b.side, k))) return null;
    Ke.copy(k);
    Ke.applyMatrix4(a.matrixWorld);
    b = c.ray.origin.distanceTo(Ke);
    return b < c.near || b > c.far ? null : { distance: b, point: Ke.clone(), object: a };
  }
  function Le(a, b, c, d, e, f, g, k, l, m, x, p) {
    Zb.fromBufferAttribute(e, m);
    $b.fromBufferAttribute(e, x);
    ac.fromBufferAttribute(e, p);
    e = a.morphTargetInfluences;
    if (b.morphTargets && f && e) {
      Me.set(0, 0, 0);
      Ne.set(0, 0, 0);
      Oe.set(0, 0, 0);
      for (var q = 0, t = f.length; q < t; q++) {
        var r = e[q], h2 = f[q];
        0 !== r && (fg.fromBufferAttribute(h2, m), gg.fromBufferAttribute(h2, x), hg.fromBufferAttribute(h2, p), g ? (Me.addScaledVector(fg, r), Ne.addScaledVector(gg, r), Oe.addScaledVector(hg, r)) : (Me.addScaledVector(fg.sub(Zb), r), Ne.addScaledVector(gg.sub($b), r), Oe.addScaledVector(
          hg.sub(ac),
          r
        )));
      }
      Zb.add(Me);
      $b.add(Ne);
      ac.add(Oe);
    }
    if (a = zh(a, b, c, d, Zb, $b, ac, Id)) k && (Cc.fromBufferAttribute(k, m), Dc.fromBufferAttribute(k, x), Ec.fromBufferAttribute(k, p), a.uv = oa.getUV(Id, Zb, $b, ac, Cc, Dc, Ec, new w())), l && (Cc.fromBufferAttribute(l, m), Dc.fromBufferAttribute(l, x), Ec.fromBufferAttribute(l, p), a.uv2 = oa.getUV(Id, Zb, $b, ac, Cc, Dc, Ec, new w())), k = new Bc(m, x, p), oa.getNormal(Zb, $b, ac, k.normal), a.face = k;
    return a;
  }
  function L() {
    Object.defineProperty(this, "id", { value: tj += 2 });
    this.uuid = P.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null;
    this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = false;
  }
  function Fc(a) {
    var b = {}, c;
    for (c in a) {
      b[c] = {};
      for (var d in a[c]) {
        var e = a[c][d];
        e && (e.isColor || e.isMatrix3 || e.isMatrix4 || e.isVector2 || e.isVector3 || e.isVector4 || e.isTexture) ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e;
      }
    }
    return b;
  }
  function pa(a) {
    for (var b = {}, c = 0; c < a.length; c++) {
      var d = Fc(a[c]), e;
      for (e in d) b[e] = d[e];
    }
    return b;
  }
  function qa(a) {
    K.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = false;
    this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false };
    this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a));
  }
  function eb() {
    D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new O();
    this.projectionMatrix = new O();
    this.projectionMatrixInverse = new O();
  }
  function da(a, b, c, d) {
    eb.call(this);
    this.type = "PerspectiveCamera";
    this.fov = void 0 !== a ? a : 50;
    this.zoom = 1;
    this.near = void 0 !== c ? c : 0.1;
    this.far = void 0 !== d ? d : 2e3;
    this.focus = 10;
    this.aspect = void 0 !== b ? b : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  function Gc(a, b, c, d) {
    D.call(this);
    this.type = "CubeCamera";
    var e = new da(90, 1, a, b);
    e.up.set(
      0,
      -1,
      0
    );
    e.lookAt(new n(1, 0, 0));
    this.add(e);
    var f = new da(90, 1, a, b);
    f.up.set(0, -1, 0);
    f.lookAt(new n(-1, 0, 0));
    this.add(f);
    var g = new da(90, 1, a, b);
    g.up.set(0, 0, 1);
    g.lookAt(new n(0, 1, 0));
    this.add(g);
    var k = new da(90, 1, a, b);
    k.up.set(0, 0, -1);
    k.lookAt(new n(0, -1, 0));
    this.add(k);
    var l = new da(90, 1, a, b);
    l.up.set(0, -1, 0);
    l.lookAt(new n(0, 0, 1));
    this.add(l);
    var m = new da(90, 1, a, b);
    m.up.set(0, -1, 0);
    m.lookAt(new n(0, 0, -1));
    this.add(m);
    d = d || { format: 1022, magFilter: 1006, minFilter: 1006 };
    this.renderTarget = new Eb(c, d);
    this.renderTarget.texture.name = "CubeCamera";
    this.update = function(a2, b2) {
      null === this.parent && this.updateMatrixWorld();
      var c2 = a2.getRenderTarget(), d2 = this.renderTarget, p = d2.texture.generateMipmaps;
      d2.texture.generateMipmaps = false;
      a2.setRenderTarget(d2, 0);
      a2.render(b2, e);
      a2.setRenderTarget(d2, 1);
      a2.render(b2, f);
      a2.setRenderTarget(d2, 2);
      a2.render(b2, g);
      a2.setRenderTarget(d2, 3);
      a2.render(b2, k);
      a2.setRenderTarget(d2, 4);
      a2.render(b2, l);
      d2.texture.generateMipmaps = p;
      a2.setRenderTarget(d2, 5);
      a2.render(b2, m);
      a2.setRenderTarget(c2);
    };
    this.clear = function(a2, b2, c2, d2) {
      for (var e2 = a2.getRenderTarget(), f2 = this.renderTarget, g2 = 0; 6 > g2; g2++) a2.setRenderTarget(f2, g2), a2.clear(b2, c2, d2);
      a2.setRenderTarget(e2);
    };
  }
  function Eb(a, b, c) {
    Number.isInteger(b) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), b = c);
    wa.call(this, a, a, b);
  }
  function bc(a, b, c, d, e, f, g, k, l, m, x, p) {
    Z.call(this, null, f, g, k, l, m, d, e, x, p);
    this.image = { data: a || null, width: b || 1, height: c || 1 };
    this.magFilter = void 0 !== l ? l : 1003;
    this.minFilter = void 0 !== m ? m : 1003;
    this.flipY = this.generateMipmaps = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
  }
  function Hc(a, b, c, d, e, f) {
    this.planes = [void 0 !== a ? a : new Ua(), void 0 !== b ? b : new Ua(), void 0 !== c ? c : new Ua(), void 0 !== d ? d : new Ua(), void 0 !== e ? e : new Ua(), void 0 !== f ? f : new Ua()];
  }
  function Ah() {
    function a(e, f) {
      false !== c && (d(e, f), b.requestAnimationFrame(a));
    }
    var b = null, c = false, d = null;
    return { start: function() {
      true !== c && null !== d && (b.requestAnimationFrame(a), c = true);
    }, stop: function() {
      c = false;
    }, setAnimationLoop: function(a2) {
      d = a2;
    }, setContext: function(a2) {
      b = a2;
    } };
  }
  function uj(a, b) {
    function c(b2, c2) {
      var d2 = b2.array, e2 = b2.usage, f = a.createBuffer();
      a.bindBuffer(c2, f);
      a.bufferData(c2, d2, e2);
      b2.onUploadCallback();
      c2 = 5126;
      d2 instanceof Float32Array ? c2 = 5126 : d2 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : d2 instanceof Uint16Array ? c2 = 5123 : d2 instanceof Int16Array ? c2 = 5122 : d2 instanceof Uint32Array ? c2 = 5125 : d2 instanceof Int32Array ? c2 = 5124 : d2 instanceof Int8Array ? c2 = 5120 : d2 instanceof Uint8Array && (c2 = 5121);
      return { buffer: f, type: c2, bytesPerElement: d2.BYTES_PER_ELEMENT, version: b2.version };
    }
    var d = b.isWebGL2, e = /* @__PURE__ */ new WeakMap();
    return { get: function(a2) {
      a2.isInterleavedBufferAttribute && (a2 = a2.data);
      return e.get(a2);
    }, remove: function(b2) {
      b2.isInterleavedBufferAttribute && (b2 = b2.data);
      var c2 = e.get(b2);
      c2 && (a.deleteBuffer(c2.buffer), e.delete(b2));
    }, update: function(b2, g) {
      b2.isInterleavedBufferAttribute && (b2 = b2.data);
      var f = e.get(b2);
      if (void 0 === f) e.set(b2, c(b2, g));
      else if (f.version < b2.version) {
        var l = b2.array, m = b2.updateRange;
        a.bindBuffer(g, f.buffer);
        -1 === m.count ? a.bufferSubData(g, 0, l) : (d ? a.bufferSubData(g, m.offset * l.BYTES_PER_ELEMENT, l, m.offset, m.count) : a.bufferSubData(g, m.offset * l.BYTES_PER_ELEMENT, l.subarray(m.offset, m.offset + m.count)), m.count = -1);
        f.version = b2.version;
      }
    } };
  }
  function Jd(a, b, c, d) {
    L.call(this);
    this.type = "PlaneGeometry";
    this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d };
    this.fromBufferGeometry(new cc(a, b, c, d));
    this.mergeVertices();
  }
  function cc(a, b, c, d) {
    A.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = { width: a, height: b, widthSegments: c, heightSegments: d };
    a = a || 1;
    b = b || 1;
    var e = a / 2, f = b / 2;
    c = Math.floor(c) || 1;
    d = Math.floor(d) || 1;
    var g = c + 1, k = d + 1, l = a / c, m = b / d, x = [], p = [], q = [], t = [];
    for (a = 0; a < k; a++) {
      var r = a * m - f;
      for (b = 0; b < g; b++) p.push(b * l - e, -r, 0), q.push(0, 0, 1), t.push(b / c), t.push(1 - a / d);
    }
    for (a = 0; a < d; a++) for (b = 0; b < c; b++) e = b + g * (a + 1), f = b + 1 + g * (a + 1), k = b + 1 + g * a, x.push(b + g * a, e, k), x.push(e, f, k);
    this.setIndex(x);
    this.setAttribute("position", new E(p, 3));
    this.setAttribute("normal", new E(q, 3));
    this.setAttribute("uv", new E(t, 2));
  }
  function vj(a, b, c, d) {
    function e(a2, c2) {
      b.buffers.color.setClear(a2.r, a2.g, a2.b, c2, d);
    }
    var f = new B(0), g = 0, k, l, m = null, x = 0, p = null;
    return { getClearColor: function() {
      return f;
    }, setClearColor: function(a2, b2) {
      f.set(a2);
      g = void 0 !== b2 ? b2 : 1;
      e(f, g);
    }, getClearAlpha: function() {
      return g;
    }, setClearAlpha: function(a2) {
      g = a2;
      e(f, g);
    }, render: function(b2, d2, r, h2) {
      d2 = d2.background;
      r = a.xr;
      (r = r.getSession && r.getSession()) && "additive" === r.environmentBlendMode && (d2 = null);
      null === d2 ? e(f, g) : d2 && d2.isColor && (e(d2, 1), h2 = true);
      (a.autoClear || h2) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
      if (d2 && (d2.isCubeTexture || d2.isWebGLCubeRenderTarget || 306 === d2.mapping)) {
        void 0 === l && (l = new ca(new Kd(1, 1, 1), new qa({ type: "BackgroundCubeMaterial", uniforms: Fc(fb.cube.uniforms), vertexShader: fb.cube.vertexShader, fragmentShader: fb.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(a2, b3, c2) {
          this.matrixWorld.copyPosition(c2.matrixWorld);
        }, Object.defineProperty(l.material, "envMap", { get: function() {
          return this.uniforms.envMap.value;
        } }), c.update(l));
        h2 = d2.isWebGLCubeRenderTarget ? d2.texture : d2;
        l.material.uniforms.envMap.value = h2;
        l.material.uniforms.flipEnvMap.value = h2.isCubeTexture ? -1 : 1;
        if (m !== d2 || x !== h2.version || p !== a.toneMapping) l.material.needsUpdate = true, m = d2, x = h2.version, p = a.toneMapping;
        b2.unshift(l, l.geometry, l.material, 0, 0, null);
      } else if (d2 && d2.isTexture) {
        void 0 === k && (k = new ca(new cc(2, 2), new qa({ type: "BackgroundMaterial", uniforms: Fc(fb.background.uniforms), vertexShader: fb.background.vertexShader, fragmentShader: fb.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), k.geometry.deleteAttribute("normal"), Object.defineProperty(k.material, "map", { get: function() {
          return this.uniforms.t2D.value;
        } }), c.update(k));
        k.material.uniforms.t2D.value = d2;
        true === d2.matrixAutoUpdate && d2.updateMatrix();
        k.material.uniforms.uvTransform.value.copy(d2.matrix);
        if (m !== d2 || x !== d2.version || p !== a.toneMapping) k.material.needsUpdate = true, m = d2, x = d2.version, p = a.toneMapping;
        b2.unshift(k, k.geometry, k.material, 0, 0, null);
      }
    } };
  }
  function wj(a, b, c, d) {
    var e = d.isWebGL2, f;
    this.setMode = function(a2) {
      f = a2;
    };
    this.render = function(b2, d2) {
      a.drawArrays(f, b2, d2);
      c.update(
        d2,
        f
      );
    };
    this.renderInstances = function(d2, k, l, m) {
      if (0 !== m) {
        if (e) {
          d2 = a;
          var g = "drawArraysInstanced";
        } else if (d2 = b.get("ANGLE_instanced_arrays"), g = "drawArraysInstancedANGLE", null === d2) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
        d2[g](f, k, l, m);
        c.update(l, f, m);
      }
    };
  }
  function xj(a, b, c) {
    function d(b2) {
      if ("highp" === b2) {
        if (0 < a.getShaderPrecisionFormat(35633, 36338).precision && 0 < a.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
        b2 = "mediump";
      }
      return "mediump" === b2 && 0 < a.getShaderPrecisionFormat(35633, 36337).precision && 0 < a.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp";
    }
    var e, f = "undefined" !== typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext || "undefined" !== typeof WebGL2ComputeRenderingContext && a instanceof WebGL2ComputeRenderingContext, g = void 0 !== c.precision ? c.precision : "highp", k = d(g);
    k !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", k, "instead."), g = k);
    c = true === c.logarithmicDepthBuffer;
    k = a.getParameter(34930);
    var l = a.getParameter(35660), m = a.getParameter(3379), x = a.getParameter(34076), p = a.getParameter(34921), q = a.getParameter(36347), t = a.getParameter(36348), h2 = a.getParameter(36349), u = 0 < l, n2 = f || !!b.get("OES_texture_float"), v = u && n2, C = f ? a.getParameter(36183) : 0;
    return {
      isWebGL2: f,
      getMaxAnisotropy: function() {
        if (void 0 !== e) return e;
        var c2 = b.get("EXT_texture_filter_anisotropic");
        return e = null !== c2 ? a.getParameter(c2.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
      },
      getMaxPrecision: d,
      precision: g,
      logarithmicDepthBuffer: c,
      maxTextures: k,
      maxVertexTextures: l,
      maxTextureSize: m,
      maxCubemapSize: x,
      maxAttributes: p,
      maxVertexUniforms: q,
      maxVaryings: t,
      maxFragmentUniforms: h2,
      vertexTextures: u,
      floatFragmentTextures: n2,
      floatVertexTextures: v,
      maxSamples: C
    };
  }
  function yj() {
    function a() {
      m.value !== d && (m.value = d, m.needsUpdate = 0 < e);
      c.numPlanes = e;
      c.numIntersection = 0;
    }
    function b(a2, b2, d2, e2) {
      var f2 = null !== a2 ? a2.length : 0, g2 = null;
      if (0 !== f2) {
        g2 = m.value;
        if (true !== e2 || null === g2) {
          e2 = d2 + 4 * f2;
          b2 = b2.matrixWorldInverse;
          l.getNormalMatrix(b2);
          if (null === g2 || g2.length < e2) g2 = new Float32Array(e2);
          for (e2 = 0; e2 !== f2; ++e2, d2 += 4) k.copy(a2[e2]).applyMatrix4(b2, l), k.normal.toArray(g2, d2), g2[d2 + 3] = k.constant;
        }
        m.value = g2;
        m.needsUpdate = true;
      }
      c.numPlanes = f2;
      return g2;
    }
    var c = this, d = null, e = 0, f = false, g = false, k = new Ua(), l = new za(), m = { value: null, needsUpdate: false };
    this.uniform = m;
    this.numIntersection = this.numPlanes = 0;
    this.init = function(a2, c2, g2) {
      var k2 = 0 !== a2.length || c2 || 0 !== e || f;
      f = c2;
      d = b(a2, g2, 0);
      e = a2.length;
      return k2;
    };
    this.beginShadows = function() {
      g = true;
      b(null);
    };
    this.endShadows = function() {
      g = false;
      a();
    };
    this.setState = function(c2, k2, l2, h2, r, u) {
      if (!f || null === c2 || 0 === c2.length || g && !l2) g ? b(null) : a();
      else {
        l2 = g ? 0 : e;
        var p = 4 * l2, x = r.clippingState || null;
        m.value = x;
        x = b(c2, h2, p, u);
        for (c2 = 0; c2 !== p; ++c2) x[c2] = d[c2];
        r.clippingState = x;
        this.numIntersection = k2 ? this.numPlanes : 0;
        this.numPlanes += l2;
      }
    };
  }
  function zj(a) {
    var b = {};
    return { get: function(c) {
      if (void 0 !== b[c]) return b[c];
      switch (c) {
        case "WEBGL_depth_texture":
          var d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          d = a.getExtension(c);
      }
      null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported.");
      return b[c] = d;
    } };
  }
  function Aj(a, b, c) {
    function d(a2) {
      var e2 = a2.target;
      a2 = f.get(e2);
      null !== a2.index && b.remove(a2.index);
      for (var k in a2.attributes) b.remove(a2.attributes[k]);
      e2.removeEventListener("dispose", d);
      f.delete(e2);
      if (k = g.get(a2)) b.remove(k), g.delete(a2);
      c.memory.geometries--;
    }
    function e(a2) {
      var c2 = [], d2 = a2.index, e2 = a2.attributes.position;
      if (null !== d2) {
        var f2 = d2.array;
        d2 = d2.version;
        e2 = 0;
        for (var k = f2.length; e2 < k; e2 += 3) {
          var h2 = f2[e2 + 0], r = f2[e2 + 1], u = f2[e2 + 2];
          c2.push(h2, r, r, u, u, h2);
        }
      } else for (f2 = e2.array, d2 = e2.version, e2 = 0, k = f2.length / 3 - 1; e2 < k; e2 += 3) h2 = e2 + 0, r = e2 + 1, u = e2 + 2, c2.push(h2, r, r, u, u, h2);
      c2 = new (65535 < yh(c2) ? Yb : Xb)(c2, 1);
      c2.version = d2;
      b.update(c2, 34963);
      (f2 = g.get(a2)) && b.remove(f2);
      g.set(a2, c2);
    }
    var f = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
    return { get: function(a2, b2) {
      var e2 = f.get(b2);
      if (e2) return e2;
      b2.addEventListener("dispose", d);
      b2.isBufferGeometry ? e2 = b2 : b2.isGeometry && (void 0 === b2._bufferGeometry && (b2._bufferGeometry = new A().setFromObject(a2)), e2 = b2._bufferGeometry);
      f.set(b2, e2);
      c.memory.geometries++;
      return e2;
    }, update: function(a2) {
      var c2 = a2.index, d2 = a2.attributes;
      null !== c2 && b.update(c2, 34963);
      for (var e2 in d2) b.update(d2[e2], 34962);
      a2 = a2.morphAttributes;
      for (e2 in a2) {
        c2 = a2[e2];
        d2 = 0;
        for (var f2 = c2.length; d2 < f2; d2++) b.update(c2[d2], 34962);
      }
    }, getWireframeAttribute: function(a2) {
      var b2 = g.get(a2);
      if (b2) {
        var c2 = a2.index;
        null !== c2 && b2.version < c2.version && e(a2);
      } else e(a2);
      return g.get(a2);
    } };
  }
  function Bj(a, b, c, d) {
    var e = d.isWebGL2, f, g, k;
    this.setMode = function(a2) {
      f = a2;
    };
    this.setIndex = function(a2) {
      g = a2.type;
      k = a2.bytesPerElement;
    };
    this.render = function(b2, d2) {
      a.drawElements(f, d2, g, b2 * k);
      c.update(d2, f);
    };
    this.renderInstances = function(d2, m, x, p) {
      if (0 !== p) {
        if (e) {
          d2 = a;
          var l = "drawElementsInstanced";
        } else if (d2 = b.get("ANGLE_instanced_arrays"), l = "drawElementsInstancedANGLE", null === d2) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
        d2[l](f, x, g, m * k, p);
        c.update(x, f, p);
      }
    };
  }
  function Cj(a) {
    var b = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return { memory: { geometries: 0, textures: 0 }, render: b, programs: null, autoReset: true, reset: function() {
      b.frame++;
      b.calls = 0;
      b.triangles = 0;
      b.points = 0;
      b.lines = 0;
    }, update: function(a2, d, e) {
      e = e || 1;
      b.calls++;
      switch (d) {
        case 4:
          b.triangles += a2 / 3 * e;
          break;
        case 1:
          b.lines += a2 / 2 * e;
          break;
        case 3:
          b.lines += e * (a2 - 1);
          break;
        case 2:
          b.lines += e * a2;
          break;
        case 0:
          b.points += e * a2;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", d);
      }
    } };
  }
  function Dj(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }
  function Ej(a) {
    var b = {}, c = new Float32Array(8);
    return { update: function(d, e, f, g) {
      var k = d.morphTargetInfluences, l = void 0 === k ? 0 : k.length;
      d = b[e.id];
      if (void 0 === d) {
        d = [];
        for (var m = 0; m < l; m++) d[m] = [m, 0];
        b[e.id] = d;
      }
      var x = f.morphTargets && e.morphAttributes.position;
      f = f.morphNormals && e.morphAttributes.normal;
      for (m = 0; m < l; m++) {
        var p = d[m];
        0 !== p[1] && (x && e.deleteAttribute("morphTarget" + m), f && e.deleteAttribute("morphNormal" + m));
      }
      for (m = 0; m < l; m++) p = d[m], p[0] = m, p[1] = k[m];
      d.sort(Dj);
      for (m = k = 0; 8 > m; m++) {
        if (p = d[m]) {
          if (l = p[0], p = p[1]) {
            x && e.setAttribute("morphTarget" + m, x[l]);
            f && e.setAttribute("morphNormal" + m, f[l]);
            c[m] = p;
            k += p;
            continue;
          }
        }
        c[m] = 0;
      }
      e = e.morphTargetsRelative ? 1 : 1 - k;
      g.getUniforms().setValue(a, "morphTargetBaseInfluence", e);
      g.getUniforms().setValue(a, "morphTargetInfluences", c);
    } };
  }
  function Fj(a, b, c, d) {
    var e = {};
    return { update: function(a2) {
      var f = d.render.frame, k = a2.geometry, l = b.get(a2, k);
      e[l.id] !== f && (k.isGeometry && l.updateFromObject(a2), b.update(l), e[l.id] = f);
      a2.isInstancedMesh && c.update(a2.instanceMatrix, 34962);
      return l;
    }, dispose: function() {
      e = {};
    } };
  }
  function rb(a, b, c, d, e, f, g, k, l, m) {
    a = void 0 !== a ? a : [];
    Z.call(this, a, void 0 !== b ? b : 301, c, d, e, f, void 0 !== g ? g : 1022, k, l, m);
    this.flipY = false;
  }
  function Ic(a, b, c, d) {
    Z.call(this, null);
    this.image = { data: a || null, width: b || 1, height: c || 1, depth: d || 1 };
    this.minFilter = this.magFilter = 1003;
    this.wrapR = 1001;
    this.flipY = this.generateMipmaps = false;
    this.needsUpdate = true;
  }
  function Jc(a, b, c, d) {
    Z.call(this, null);
    this.image = { data: a || null, width: b || 1, height: c || 1, depth: d || 1 };
    this.minFilter = this.magFilter = 1003;
    this.wrapR = 1001;
    this.flipY = this.generateMipmaps = false;
    this.needsUpdate = true;
  }
  function Kc(a, b, c) {
    var d = a[0];
    if (0 >= d || 0 < d) return a;
    var e = b * c, f = Bh[e];
    void 0 === f && (f = new Float32Array(e), Bh[e] = f);
    if (0 !== b) for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d) e += c, a[d].toArray(f, e);
    return f;
  }
  function Qa(a, b) {
    if (a.length !== b.length) return false;
    for (var c = 0, d = a.length; c < d; c++) if (a[c] !== b[c]) return false;
    return true;
  }
  function Ka(a, b) {
    for (var c = 0, d = b.length; c < d; c++) a[c] = b[c];
  }
  function Ch(a, b) {
    var c = Dh[b];
    void 0 === c && (c = new Int32Array(b), Dh[b] = c);
    for (var d = 0; d !== b; ++d) c[d] = a.allocateTextureUnit();
    return c;
  }
  function Gj(a, b) {
    var c = this.cache;
    c[0] !== b && (a.uniform1f(this.addr, b), c[0] = b);
  }
  function Hj(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
      if (c[0] !== b.x || c[1] !== b.y) a.uniform2f(this.addr, b.x, b.y), c[0] = b.x, c[1] = b.y;
    } else Qa(c, b) || (a.uniform2fv(this.addr, b), Ka(c, b));
  }
  function Ij(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
      if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z) a.uniform3f(this.addr, b.x, b.y, b.z), c[0] = b.x, c[1] = b.y, c[2] = b.z;
    } else if (void 0 !== b.r) {
      if (c[0] !== b.r || c[1] !== b.g || c[2] !== b.b) a.uniform3f(this.addr, b.r, b.g, b.b), c[0] = b.r, c[1] = b.g, c[2] = b.b;
    } else Qa(c, b) || (a.uniform3fv(this.addr, b), Ka(c, b));
  }
  function Jj(a, b) {
    var c = this.cache;
    if (void 0 !== b.x) {
      if (c[0] !== b.x || c[1] !== b.y || c[2] !== b.z || c[3] !== b.w) a.uniform4f(this.addr, b.x, b.y, b.z, b.w), c[0] = b.x, c[1] = b.y, c[2] = b.z, c[3] = b.w;
    } else Qa(c, b) || (a.uniform4fv(this.addr, b), Ka(c, b));
  }
  function Kj(a, b) {
    var c = this.cache, d = b.elements;
    void 0 === d ? Qa(c, b) || (a.uniformMatrix2fv(this.addr, false, b), Ka(c, b)) : Qa(c, d) || (Eh.set(d), a.uniformMatrix2fv(this.addr, false, Eh), Ka(c, d));
  }
  function Lj(a, b) {
    var c = this.cache, d = b.elements;
    void 0 === d ? Qa(c, b) || (a.uniformMatrix3fv(this.addr, false, b), Ka(c, b)) : Qa(c, d) || (Fh.set(d), a.uniformMatrix3fv(this.addr, false, Fh), Ka(c, d));
  }
  function Mj(a, b) {
    var c = this.cache, d = b.elements;
    void 0 === d ? Qa(c, b) || (a.uniformMatrix4fv(this.addr, false, b), Ka(c, b)) : Qa(c, d) || (Gh.set(d), a.uniformMatrix4fv(this.addr, false, Gh), Ka(c, d));
  }
  function Nj(a, b, c) {
    var d = this.cache, e = c.allocateTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
    c.safeSetTexture2D(b || Hh, e);
  }
  function Oj(a, b, c) {
    var d = this.cache, e = c.allocateTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
    c.setTexture2DArray(b || Pj, e);
  }
  function Qj(a, b, c) {
    var d = this.cache, e = c.allocateTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
    c.setTexture3D(b || Rj, e);
  }
  function Sj(a, b, c) {
    var d = this.cache, e = c.allocateTextureUnit();
    d[0] !== e && (a.uniform1i(this.addr, e), d[0] = e);
    c.safeSetTextureCube(b || Ih, e);
  }
  function Tj(a, b) {
    var c = this.cache;
    c[0] !== b && (a.uniform1i(this.addr, b), c[0] = b);
  }
  function Uj(a, b) {
    var c = this.cache;
    Qa(c, b) || (a.uniform2iv(this.addr, b), Ka(c, b));
  }
  function Vj(a, b) {
    var c = this.cache;
    Qa(c, b) || (a.uniform3iv(this.addr, b), Ka(c, b));
  }
  function Wj(a, b) {
    var c = this.cache;
    Qa(c, b) || (a.uniform4iv(this.addr, b), Ka(c, b));
  }
  function Xj(a, b) {
    var c = this.cache;
    c[0] !== b && (a.uniform1ui(this.addr, b), c[0] = b);
  }
  function Yj(a) {
    switch (a) {
      case 5126:
        return Gj;
      case 35664:
        return Hj;
      case 35665:
        return Ij;
      case 35666:
        return Jj;
      case 35674:
        return Kj;
      case 35675:
        return Lj;
      case 35676:
        return Mj;
      case 5124:
      case 35670:
        return Tj;
      case 35667:
      case 35671:
        return Uj;
      case 35668:
      case 35672:
        return Vj;
      case 35669:
      case 35673:
        return Wj;
      case 5125:
        return Xj;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Nj;
      case 35679:
      case 36299:
      case 36307:
        return Qj;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Sj;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Oj;
    }
  }
  function Zj(a, b) {
    a.uniform1fv(this.addr, b);
  }
  function ak(a, b) {
    a.uniform1iv(this.addr, b);
  }
  function bk(a, b) {
    a.uniform2iv(this.addr, b);
  }
  function ck(a, b) {
    a.uniform3iv(this.addr, b);
  }
  function dk(a, b) {
    a.uniform4iv(this.addr, b);
  }
  function ek(a, b) {
    b = Kc(b, this.size, 2);
    a.uniform2fv(
      this.addr,
      b
    );
  }
  function fk(a, b) {
    b = Kc(b, this.size, 3);
    a.uniform3fv(this.addr, b);
  }
  function gk(a, b) {
    b = Kc(b, this.size, 4);
    a.uniform4fv(this.addr, b);
  }
  function hk(a, b) {
    b = Kc(b, this.size, 4);
    a.uniformMatrix2fv(this.addr, false, b);
  }
  function ik(a, b) {
    b = Kc(b, this.size, 9);
    a.uniformMatrix3fv(this.addr, false, b);
  }
  function jk(a, b) {
    b = Kc(b, this.size, 16);
    a.uniformMatrix4fv(this.addr, false, b);
  }
  function kk(a, b, c) {
    var d = b.length, e = Ch(c, d);
    a.uniform1iv(this.addr, e);
    for (a = 0; a !== d; ++a) c.safeSetTexture2D(b[a] || Hh, e[a]);
  }
  function lk(a, b, c) {
    var d = b.length, e = Ch(c, d);
    a.uniform1iv(this.addr, e);
    for (a = 0; a !== d; ++a) c.safeSetTextureCube(b[a] || Ih, e[a]);
  }
  function mk(a) {
    switch (a) {
      case 5126:
        return Zj;
      case 35664:
        return ek;
      case 35665:
        return fk;
      case 35666:
        return gk;
      case 35674:
        return hk;
      case 35675:
        return ik;
      case 35676:
        return jk;
      case 5124:
      case 35670:
        return ak;
      case 35667:
      case 35671:
        return bk;
      case 35668:
      case 35672:
        return ck;
      case 35669:
      case 35673:
        return dk;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return kk;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return lk;
    }
  }
  function nk(a, b, c) {
    this.id = a;
    this.addr = c;
    this.cache = [];
    this.setValue = Yj(b.type);
  }
  function Jh(a, b, c) {
    this.id = a;
    this.addr = c;
    this.cache = [];
    this.size = b.size;
    this.setValue = mk(b.type);
  }
  function Kh(a) {
    this.id = a;
    this.seq = [];
    this.map = {};
  }
  function Fb(a, b) {
    this.seq = [];
    this.map = {};
    for (var c = a.getProgramParameter(b, 35718), d = 0; d < c; ++d) {
      var e = a.getActiveUniform(b, d), f = a.getUniformLocation(b, e.name), g = this, k = e.name, l = k.length;
      for (ig.lastIndex = 0; ; ) {
        var m = ig.exec(k), x = ig.lastIndex, p = m[1], h2 = m[3];
        "]" === m[2] && (p |= 0);
        if (void 0 === h2 || "[" === h2 && x + 2 === l) {
          k = g;
          e = void 0 === h2 ? new nk(p, e, f) : new Jh(p, e, f);
          k.seq.push(e);
          k.map[e.id] = e;
          break;
        } else h2 = g.map[p], void 0 === h2 && (h2 = new Kh(p), p = g, g = h2, p.seq.push(g), p.map[g.id] = g), g = h2;
      }
    }
  }
  function Lh(a, b, c) {
    b = a.createShader(b);
    a.shaderSource(b, c);
    a.compileShader(b);
    return b;
  }
  function Mh(a) {
    switch (a) {
      case 3e3:
        return ["Linear", "( value )"];
      case 3001:
        return ["sRGB", "( value )"];
      case 3002:
        return ["RGBE", "( value )"];
      case 3004:
        return ["RGBM", "( value, 7.0 )"];
      case 3005:
        return ["RGBM", "( value, 16.0 )"];
      case 3006:
        return [
          "RGBD",
          "( value, 256.0 )"
        ];
      case 3007:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case 3003:
        return ["LogLuv", "( value )"];
      default:
        throw Error("unsupported encoding: " + a);
    }
  }
  function Nh(a, b, c) {
    var d = a.getShaderParameter(b, 35713), e = a.getShaderInfoLog(b).trim();
    if (d && "" === e) return "";
    a = a.getShaderSource(b).split("\n");
    for (b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
    a = a.join("\n");
    return "THREE.WebGLShader: gl.getShaderInfoLog() " + c + "\n" + e + a;
  }
  function Ld(a, b) {
    b = Mh(b);
    return "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }";
  }
  function ok(a, b) {
    b = Mh(b);
    return "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }";
  }
  function pk(a, b) {
    switch (b) {
      case 1:
        b = "Linear";
        break;
      case 2:
        b = "Reinhard";
        break;
      case 3:
        b = "Uncharted2";
        break;
      case 4:
        b = "OptimizedCineon";
        break;
      case 5:
        b = "ACESFilmic";
        break;
      default:
        throw Error("unsupported toneMapping: " + b);
    }
    return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }";
  }
  function qk(a) {
    var b = [], c;
    for (c in a) {
      var d = a[c];
      false !== d && b.push("#define " + c + " " + d);
    }
    return b.join("\n");
  }
  function Md(a) {
    return "" !== a;
  }
  function Oh(a, b) {
    return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, b.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, b.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, b.numPointLightShadows);
  }
  function Ph(a, b) {
    return a.replace(
      /NUM_CLIPPING_PLANES/g,
      b.numClippingPlanes
    ).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes - b.numClipIntersection);
  }
  function jg(a, b) {
    a = N[b];
    if (void 0 === a) throw Error("Can not resolve #include <" + b + ">");
    return a.replace(kg, jg);
  }
  function Qh(a, b, c, d) {
    a = "";
    for (b = parseInt(b); b < parseInt(c); b++) a += d.replace(/\[ i \]/g, "[ " + b + " ]").replace(/UNROLLED_LOOP_INDEX/g, b);
    return a;
  }
  function Rh(a) {
    var b = "precision " + a.precision + " float;\nprecision " + a.precision + " int;";
    "highp" === a.precision ? b += "\n#define HIGH_PRECISION" : "mediump" === a.precision ? b += "\n#define MEDIUM_PRECISION" : "lowp" === a.precision && (b += "\n#define LOW_PRECISION");
    return b;
  }
  function rk(a) {
    var b = "SHADOWMAP_TYPE_BASIC";
    1 === a.shadowMapType ? b = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType ? b = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === a.shadowMapType && (b = "SHADOWMAP_TYPE_VSM");
    return b;
  }
  function sk(a) {
    var b = "ENVMAP_TYPE_CUBE";
    if (a.envMap) switch (a.envMapMode) {
      case 301:
      case 302:
        b = "ENVMAP_TYPE_CUBE";
        break;
      case 306:
      case 307:
        b = "ENVMAP_TYPE_CUBE_UV";
        break;
      case 303:
      case 304:
        b = "ENVMAP_TYPE_EQUIREC";
        break;
      case 305:
        b = "ENVMAP_TYPE_SPHERE";
    }
    return b;
  }
  function tk(a) {
    var b = "ENVMAP_MODE_REFLECTION";
    if (a.envMap) switch (a.envMapMode) {
      case 302:
      case 304:
        b = "ENVMAP_MODE_REFRACTION";
    }
    return b;
  }
  function uk(a) {
    var b = "ENVMAP_BLENDING_NONE";
    if (a.envMap) switch (a.combine) {
      case 0:
        b = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case 1:
        b = "ENVMAP_BLENDING_MIX";
        break;
      case 2:
        b = "ENVMAP_BLENDING_ADD";
    }
    return b;
  }
  function vk(a, b, c) {
    var d = a.getContext(), e = c.defines, f = c.vertexShader, g = c.fragmentShader, k = rk(c), l = sk(c), m = tk(c), x = uk(c), p = 0 < a.gammaFactor ? a.gammaFactor : 1, h2 = c.isWebGL2 ? "" : [c.extensionDerivatives || c.envMapCubeUV || c.bumpMap || c.tangentSpaceNormalMap || c.clearcoatNormalMap || c.flatShading || "physical" === c.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (c.extensionFragDepth || c.logarithmicDepthBuffer) && c.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", c.extensionDrawBuffers && c.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (c.extensionShaderTextureLOD || c.envMap) && c.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Md).join("\n"), t = qk(e), r = d.createProgram(), u = c.numMultiviewViews;
    c.isRawShaderMaterial ? (e = [t].filter(Md).join("\n"), 0 < e.length && (e += "\n"), k = [h2, t].filter(Md).join("\n"), 0 < k.length && (k += "\n")) : (e = [
      Rh(c),
      "#define SHADER_NAME " + c.shaderName,
      t,
      c.instancing ? "#define USE_INSTANCING" : "",
      c.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define GAMMA_FACTOR " + p,
      "#define MAX_BONES " + c.maxBones,
      c.useFog && c.fog ? "#define USE_FOG" : "",
      c.useFog && c.fogExp2 ? "#define FOG_EXP2" : "",
      c.map ? "#define USE_MAP" : "",
      c.envMap ? "#define USE_ENVMAP" : "",
      c.envMap ? "#define " + m : "",
      c.lightMap ? "#define USE_LIGHTMAP" : "",
      c.aoMap ? "#define USE_AOMAP" : "",
      c.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      c.bumpMap ? "#define USE_BUMPMAP" : "",
      c.normalMap ? "#define USE_NORMALMAP" : "",
      c.normalMap && c.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      c.normalMap && c.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      c.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      c.displacementMap && c.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      c.specularMap ? "#define USE_SPECULARMAP" : "",
      c.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      c.metalnessMap ? "#define USE_METALNESSMAP" : "",
      c.alphaMap ? "#define USE_ALPHAMAP" : "",
      c.vertexTangents ? "#define USE_TANGENT" : "",
      c.vertexColors ? "#define USE_COLOR" : "",
      c.vertexUvs ? "#define USE_UV" : "",
      c.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      c.flatShading ? "#define FLAT_SHADED" : "",
      c.skinning ? "#define USE_SKINNING" : "",
      c.useVertexTexture ? "#define BONE_TEXTURE" : "",
      c.morphTargets ? "#define USE_MORPHTARGETS" : "",
      c.morphNormals && false === c.flatShading ? "#define USE_MORPHNORMALS" : "",
      c.doubleSided ? "#define DOUBLE_SIDED" : "",
      c.flipSided ? "#define FLIP_SIDED" : "",
      c.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      c.shadowMapEnabled ? "#define " + k : "",
      c.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      c.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      c.logarithmicDepthBuffer && c.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      " attribute mat4 instanceMatrix;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#ifdef USE_COLOR",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_MORPHTARGETS",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(Md).join("\n"), k = [
      h2,
      Rh(c),
      "#define SHADER_NAME " + c.shaderName,
      t,
      c.alphaTest ? "#define ALPHATEST " + c.alphaTest + (c.alphaTest % 1 ? "" : ".0") : "",
      "#define GAMMA_FACTOR " + p,
      c.useFog && c.fog ? "#define USE_FOG" : "",
      c.useFog && c.fogExp2 ? "#define FOG_EXP2" : "",
      c.map ? "#define USE_MAP" : "",
      c.matcap ? "#define USE_MATCAP" : "",
      c.envMap ? "#define USE_ENVMAP" : "",
      c.envMap ? "#define " + l : "",
      c.envMap ? "#define " + m : "",
      c.envMap ? "#define " + x : "",
      c.lightMap ? "#define USE_LIGHTMAP" : "",
      c.aoMap ? "#define USE_AOMAP" : "",
      c.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      c.bumpMap ? "#define USE_BUMPMAP" : "",
      c.normalMap ? "#define USE_NORMALMAP" : "",
      c.normalMap && c.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      c.normalMap && c.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      c.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      c.specularMap ? "#define USE_SPECULARMAP" : "",
      c.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      c.metalnessMap ? "#define USE_METALNESSMAP" : "",
      c.alphaMap ? "#define USE_ALPHAMAP" : "",
      c.sheen ? "#define USE_SHEEN" : "",
      c.vertexTangents ? "#define USE_TANGENT" : "",
      c.vertexColors ? "#define USE_COLOR" : "",
      c.vertexUvs ? "#define USE_UV" : "",
      c.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      c.gradientMap ? "#define USE_GRADIENTMAP" : "",
      c.flatShading ? "#define FLAT_SHADED" : "",
      c.doubleSided ? "#define DOUBLE_SIDED" : "",
      c.flipSided ? "#define FLIP_SIDED" : "",
      c.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      c.shadowMapEnabled ? "#define " + k : "",
      c.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      c.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      c.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      c.logarithmicDepthBuffer && c.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      (c.extensionShaderTextureLOD || c.envMap) && c.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      0 !== c.toneMapping ? "#define TONE_MAPPING" : "",
      0 !== c.toneMapping ? N.tonemapping_pars_fragment : "",
      0 !== c.toneMapping ? pk("toneMapping", c.toneMapping) : "",
      c.dithering ? "#define DITHERING" : "",
      c.outputEncoding || c.mapEncoding || c.matcapEncoding || c.envMapEncoding || c.emissiveMapEncoding || c.lightMapEncoding ? N.encodings_pars_fragment : "",
      c.mapEncoding ? Ld("mapTexelToLinear", c.mapEncoding) : "",
      c.matcapEncoding ? Ld("matcapTexelToLinear", c.matcapEncoding) : "",
      c.envMapEncoding ? Ld("envMapTexelToLinear", c.envMapEncoding) : "",
      c.emissiveMapEncoding ? Ld("emissiveMapTexelToLinear", c.emissiveMapEncoding) : "",
      c.lightMapEncoding ? Ld("lightMapTexelToLinear", c.lightMapEncoding) : "",
      c.outputEncoding ? ok("linearToOutputTexel", c.outputEncoding) : "",
      c.depthPacking ? "#define DEPTH_PACKING " + c.depthPacking : "",
      "\n"
    ].filter(Md).join("\n"));
    f = f.replace(kg, jg);
    f = Oh(f, c);
    f = Ph(f, c);
    g = g.replace(kg, jg);
    g = Oh(g, c);
    g = Ph(g, c);
    f = f.replace(Sh, Qh);
    g = g.replace(Sh, Qh);
    c.isWebGL2 && !c.isRawShaderMaterial && (l = false, m = /^\s*#version\s+300\s+es\s*\n/, c.isShaderMaterial && null !== f.match(m) && null !== g.match(m) && (l = true, f = f.replace(m, ""), g = g.replace(m, "")), e = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + e, k = [
      "#version 300 es\n\n#define varying in",
      l ? "" : "out highp vec4 pc_fragColor;",
      l ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + k, 0 < u && (e = e.replace(
      "#version 300 es\n",
      ["#version 300 es\n\n#extension GL_OVR_multiview2 : require", "layout(num_views = " + u + ") in;", "#define VIEW_ID gl_ViewID_OVR"].join("\n")
    ), e = e.replace("uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;", ["uniform mat4 modelViewMatrices[" + u + "];", "uniform mat4 projectionMatrices[" + u + "];", "uniform mat4 viewMatrices[" + u + "];", "uniform mat3 normalMatrices[" + u + "];", "#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"].join("\n")), k = k.replace("#version 300 es\n", "#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR"), k = k.replace("uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + u + "];", "#define viewMatrix viewMatrices[VIEW_ID]"].join("\n"))));
    g = k + g;
    f = Lh(d, 35633, e + f);
    g = Lh(d, 35632, g);
    d.attachShader(r, f);
    d.attachShader(r, g);
    void 0 !== c.index0AttributeName ? d.bindAttribLocation(r, 0, c.index0AttributeName) : true === c.morphTargets && d.bindAttribLocation(r, 0, "position");
    d.linkProgram(r);
    if (a.debug.checkShaderErrors) {
      a = d.getProgramInfoLog(r).trim();
      l = d.getShaderInfoLog(f).trim();
      m = d.getShaderInfoLog(g).trim();
      p = x = true;
      if (false === d.getProgramParameter(r, 35714)) x = false, h2 = Nh(d, f, "vertex"), t = Nh(d, g, "fragment"), console.error("THREE.WebGLProgram: shader error: ", d.getError(), "35715", d.getProgramParameter(r, 35715), "gl.getProgramInfoLog", a, h2, t);
      else if ("" !== a) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a);
      else if ("" === l || "" === m) p = false;
      p && (this.diagnostics = { runnable: x, programLog: a, vertexShader: { log: l, prefix: e }, fragmentShader: {
        log: m,
        prefix: k
      } });
    }
    d.deleteShader(f);
    d.deleteShader(g);
    var n2;
    this.getUniforms = function() {
      void 0 === n2 && (n2 = new Fb(d, r));
      return n2;
    };
    var v;
    this.getAttributes = function() {
      if (void 0 === v) {
        for (var a2 = {}, b2 = d.getProgramParameter(r, 35721), c2 = 0; c2 < b2; c2++) {
          var e2 = d.getActiveAttrib(r, c2).name;
          a2[e2] = d.getAttribLocation(r, e2);
        }
        v = a2;
      }
      return v;
    };
    this.destroy = function() {
      d.deleteProgram(r);
      this.program = void 0;
    };
    this.name = c.shaderName;
    this.id = wk++;
    this.cacheKey = b;
    this.usedTimes = 1;
    this.program = r;
    this.vertexShader = f;
    this.fragmentShader = g;
    this.numMultiviewViews = u;
    return this;
  }
  function xk(a, b, c) {
    function d(a2) {
      if (a2) a2.isTexture ? b2 = a2.encoding : a2.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), b2 = a2.texture.encoding);
      else var b2 = 3e3;
      return b2;
    }
    var e = [], f = c.isWebGL2, g = c.logarithmicDepthBuffer, k = c.floatVertexTextures, l = c.precision, m = c.maxVertexUniforms, x = c.vertexTextures, p = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    }, h2 = "precision isWebGL2 supportsVertexTextures outputEncoding instancing numMultiviewViews map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding envMapCubeUV lightMap lightMapEncoding aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents vertexUvs uvsVertexOnly fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights numDirLightShadows numPointLightShadows numSpotLightShadows shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen".split(" ");
    this.getParameters = function(e2, h3, q, n2, v, C, W) {
      var r = n2.fog;
      n2 = e2.isMeshStandardMaterial ? n2.environment : null;
      n2 = e2.envMap || n2;
      var t = p[e2.type];
      if (W.isSkinnedMesh) {
        var u = W.skeleton.bones;
        if (k) u = 1024;
        else {
          var y = Math.min(Math.floor((m - 20) / 4), u.length);
          y < u.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + u.length + " bones. This GPU supports " + y + "."), u = 0) : u = y;
        }
      } else u = 0;
      null !== e2.precision && (l = c.getMaxPrecision(e2.precision), l !== e2.precision && console.warn(
        "THREE.WebGLProgram.getParameters:",
        e2.precision,
        "not supported, using",
        l,
        "instead."
      ));
      t ? (y = fb[t], y = { name: e2.type, uniforms: Th.clone(y.uniforms), vertexShader: y.vertexShader, fragmentShader: y.fragmentShader }) : y = { name: e2.type, uniforms: e2.uniforms, vertexShader: e2.vertexShader, fragmentShader: e2.fragmentShader };
      e2.onBeforeCompile(y, a);
      var Ga = a.getRenderTarget();
      return {
        isWebGL2: f,
        shaderID: t,
        shaderName: y.name,
        uniforms: y.uniforms,
        vertexShader: y.vertexShader,
        fragmentShader: y.fragmentShader,
        defines: e2.defines,
        isRawShaderMaterial: e2.isRawShaderMaterial,
        isShaderMaterial: e2.isShaderMaterial,
        precision: l,
        instancing: true === W.isInstancedMesh,
        supportsVertexTextures: x,
        numMultiviewViews: Ga && Ga.isWebGLMultiviewRenderTarget ? Ga.numViews : 0,
        outputEncoding: null !== Ga ? d(Ga.texture) : a.outputEncoding,
        map: !!e2.map,
        mapEncoding: d(e2.map),
        matcap: !!e2.matcap,
        matcapEncoding: d(e2.matcap),
        envMap: !!n2,
        envMapMode: n2 && n2.mapping,
        envMapEncoding: d(n2),
        envMapCubeUV: !!n2 && (306 === n2.mapping || 307 === n2.mapping),
        lightMap: !!e2.lightMap,
        lightMapEncoding: d(e2.lightMap),
        aoMap: !!e2.aoMap,
        emissiveMap: !!e2.emissiveMap,
        emissiveMapEncoding: d(e2.emissiveMap),
        bumpMap: !!e2.bumpMap,
        normalMap: !!e2.normalMap,
        objectSpaceNormalMap: 1 === e2.normalMapType,
        tangentSpaceNormalMap: 0 === e2.normalMapType,
        clearcoatNormalMap: !!e2.clearcoatNormalMap,
        displacementMap: !!e2.displacementMap,
        roughnessMap: !!e2.roughnessMap,
        metalnessMap: !!e2.metalnessMap,
        specularMap: !!e2.specularMap,
        alphaMap: !!e2.alphaMap,
        gradientMap: !!e2.gradientMap,
        sheen: !!e2.sheen,
        combine: e2.combine,
        vertexTangents: e2.normalMap && e2.vertexTangents,
        vertexColors: e2.vertexColors,
        vertexUvs: !!e2.map || !!e2.bumpMap || !!e2.normalMap || !!e2.specularMap || !!e2.alphaMap || !!e2.emissiveMap || !!e2.roughnessMap || !!e2.metalnessMap || !!e2.clearcoatNormalMap || !!e2.displacementMap,
        uvsVertexOnly: !(e2.map || e2.bumpMap || e2.normalMap || e2.specularMap || e2.alphaMap || e2.emissiveMap || e2.roughnessMap || e2.metalnessMap || e2.clearcoatNormalMap) && !!e2.displacementMap,
        fog: !!r,
        useFog: e2.fog,
        fogExp2: r && r.isFogExp2,
        flatShading: e2.flatShading,
        sizeAttenuation: e2.sizeAttenuation,
        logarithmicDepthBuffer: g,
        skinning: e2.skinning && 0 < u,
        maxBones: u,
        useVertexTexture: k,
        morphTargets: e2.morphTargets,
        morphNormals: e2.morphNormals,
        maxMorphTargets: a.maxMorphTargets,
        maxMorphNormals: a.maxMorphNormals,
        numDirLights: h3.directional.length,
        numPointLights: h3.point.length,
        numSpotLights: h3.spot.length,
        numRectAreaLights: h3.rectArea.length,
        numHemiLights: h3.hemi.length,
        numDirLightShadows: h3.directionalShadowMap.length,
        numPointLightShadows: h3.pointShadowMap.length,
        numSpotLightShadows: h3.spotShadowMap.length,
        numClippingPlanes: v,
        numClipIntersection: C,
        dithering: e2.dithering,
        shadowMapEnabled: a.shadowMap.enabled && 0 < q.length,
        shadowMapType: a.shadowMap.type,
        toneMapping: e2.toneMapped ? a.toneMapping : 0,
        physicallyCorrectLights: a.physicallyCorrectLights,
        premultipliedAlpha: e2.premultipliedAlpha,
        alphaTest: e2.alphaTest,
        doubleSided: 2 === e2.side,
        flipSided: 1 === e2.side,
        depthPacking: void 0 !== e2.depthPacking ? e2.depthPacking : false,
        index0AttributeName: e2.index0AttributeName,
        extensionDerivatives: e2.extensions && e2.extensions.derivatives,
        extensionFragDepth: e2.extensions && e2.extensions.frawbuffers,
        extensionDrawbuffers: e2.extensions && e2.extensions.drawbuffers,
        extensionShaderTextureLOD: e2.extensions && e2.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: f || null !== b.get("EXT_frag_depth"),
        rendererExtensionDrawBuffers: f || null !== b.get("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: f || null !== b.get("EXT_shader_texture_lod"),
        onBeforeCompile: e2.onBeforeCompile
      };
    };
    this.getProgramCacheKey = function(b2) {
      var c2 = [];
      b2.shaderID ? c2.push(b2.shaderID) : (c2.push(b2.fragmentShader), c2.push(b2.vertexShader));
      if (void 0 !== b2.defines) for (var d2 in b2.defines) c2.push(d2), c2.push(b2.defines[d2]);
      if (void 0 === b2.isRawShaderMaterial) {
        for (d2 = 0; d2 < h2.length; d2++) c2.push(b2[h2[d2]]);
        c2.push(a.outputEncoding);
        c2.push(a.gammaFactor);
      }
      c2.push(b2.onBeforeCompile.toString());
      return c2.join();
    };
    this.acquireProgram = function(b2, c2) {
      for (var d2, f2 = 0, g2 = e.length; f2 < g2; f2++) {
        var k2 = e[f2];
        if (k2.cacheKey === c2) {
          d2 = k2;
          ++d2.usedTimes;
          break;
        }
      }
      void 0 === d2 && (d2 = new vk(a, c2, b2), e.push(d2));
      return d2;
    };
    this.releaseProgram = function(a2) {
      if (0 === --a2.usedTimes) {
        var b2 = e.indexOf(a2);
        e[b2] = e[e.length - 1];
        e.pop();
        a2.destroy();
      }
    };
    this.programs = e;
  }
  function yk() {
    var a = /* @__PURE__ */ new WeakMap();
    return { get: function(b) {
      var c = a.get(b);
      void 0 === c && (c = {}, a.set(b, c));
      return c;
    }, remove: function(b) {
      a.delete(b);
    }, update: function(b, c, d) {
      a.get(b)[c] = d;
    }, dispose: function() {
      a = /* @__PURE__ */ new WeakMap();
    } };
  }
  function zk(a, b) {
    return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id;
  }
  function Ak(a, b) {
    return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id;
  }
  function Uh() {
    function a(a2, d2, e2, m, x, p) {
      var g = b[c];
      void 0 === g ? (g = { id: a2.id, object: a2, geometry: d2, material: e2, program: e2.program || f, groupOrder: m, renderOrder: a2.renderOrder, z: x, group: p }, b[c] = g) : (g.id = a2.id, g.object = a2, g.geometry = d2, g.material = e2, g.program = e2.program || f, g.groupOrder = m, g.renderOrder = a2.renderOrder, g.z = x, g.group = p);
      c++;
      return g;
    }
    var b = [], c = 0, d = [], e = [], f = { id: -1 };
    return { opaque: d, transparent: e, init: function() {
      c = 0;
      d.length = 0;
      e.length = 0;
    }, push: function(b2, c2, f2, m, x, p) {
      b2 = a(b2, c2, f2, m, x, p);
      (true === f2.transparent ? e : d).push(b2);
    }, unshift: function(b2, c2, f2, m, x, p) {
      b2 = a(b2, c2, f2, m, x, p);
      (true === f2.transparent ? e : d).unshift(b2);
    }, sort: function(a2, b2) {
      1 < d.length && d.sort(a2 || zk);
      1 < e.length && e.sort(b2 || Ak);
    } };
  }
  function Bk() {
    function a(c) {
      c = c.target;
      c.removeEventListener("dispose", a);
      b.delete(c);
    }
    var b = /* @__PURE__ */ new WeakMap();
    return { get: function(c, d) {
      var e = b.get(c);
      if (void 0 === e) {
        var f = new Uh();
        b.set(c, /* @__PURE__ */ new WeakMap());
        b.get(c).set(d, f);
        c.addEventListener("dispose", a);
      } else f = e.get(d), void 0 === f && (f = new Uh(), e.set(d, f));
      return f;
    }, dispose: function() {
      b = /* @__PURE__ */ new WeakMap();
    } };
  }
  function Ck() {
    var a = {};
    return { get: function(b) {
      if (void 0 !== a[b.id]) return a[b.id];
      switch (b.type) {
        case "DirectionalLight":
          var c = { direction: new n(), color: new B(), shadow: false, shadowBias: 0, shadowRadius: 1, shadowMapSize: new w() };
          break;
        case "SpotLight":
          c = { position: new n(), direction: new n(), color: new B(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: false, shadowBias: 0, shadowRadius: 1, shadowMapSize: new w() };
          break;
        case "PointLight":
          c = {
            position: new n(),
            color: new B(),
            distance: 0,
            decay: 0,
            shadow: false,
            shadowBias: 0,
            shadowRadius: 1,
            shadowMapSize: new w(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
        case "HemisphereLight":
          c = { direction: new n(), skyColor: new B(), groundColor: new B() };
          break;
        case "RectAreaLight":
          c = { color: new B(), position: new n(), halfWidth: new n(), halfHeight: new n() };
      }
      return a[b.id] = c;
    } };
  }
  function Dk(a, b) {
    return (b.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0);
  }
  function Ek() {
    for (var a = new Ck(), b = { version: 0, hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, c = 0; 9 > c; c++) b.probe.push(new n());
    var d = new n(), e = new O(), f = new O();
    return { setup: function(c2, k, l) {
      for (var g = 0, x = 0, p = 0, h2 = 0; 9 > h2; h2++) b.probe[h2].set(0, 0, 0);
      var t = k = 0, r = 0, u = 0, n2 = 0, v = 0, C = 0, W = 0;
      l = l.matrixWorldInverse;
      c2.sort(Dk);
      h2 = 0;
      for (var ja = c2.length; h2 < ja; h2++) {
        var z = c2[h2], ra = z.color, fa = z.intensity, Ga = z.distance, w2 = z.shadow && z.shadow.map ? z.shadow.map.texture : null;
        if (z.isAmbientLight) g += ra.r * fa, x += ra.g * fa, p += ra.b * fa;
        else if (z.isLightProbe) for (w2 = 0; 9 > w2; w2++) b.probe[w2].addScaledVector(z.sh.coefficients[w2], fa);
        else if (z.isDirectionalLight) {
          var G = a.get(z);
          G.color.copy(z.color).multiplyScalar(z.intensity);
          G.direction.setFromMatrixPosition(z.matrixWorld);
          d.setFromMatrixPosition(z.target.matrixWorld);
          G.direction.sub(d);
          G.direction.transformDirection(l);
          if (G.shadow = z.castShadow) fa = z.shadow, G.shadowBias = fa.bias, G.shadowRadius = fa.radius, G.shadowMapSize = fa.mapSize, b.directionalShadowMap[k] = w2, b.directionalShadowMatrix[k] = z.shadow.matrix, v++;
          b.directional[k] = G;
          k++;
        } else if (z.isSpotLight) {
          G = a.get(z);
          G.position.setFromMatrixPosition(z.matrixWorld);
          G.position.applyMatrix4(l);
          G.color.copy(ra).multiplyScalar(fa);
          G.distance = Ga;
          G.direction.setFromMatrixPosition(z.matrixWorld);
          d.setFromMatrixPosition(z.target.matrixWorld);
          G.direction.sub(d);
          G.direction.transformDirection(l);
          G.coneCos = Math.cos(z.angle);
          G.penumbraCos = Math.cos(z.angle * (1 - z.penumbra));
          G.decay = z.decay;
          if (G.shadow = z.castShadow) fa = z.shadow, G.shadowBias = fa.bias, G.shadowRadius = fa.radius, G.shadowMapSize = fa.mapSize, b.spotShadowMap[r] = w2, b.spotShadowMatrix[r] = z.shadow.matrix, W++;
          b.spot[r] = G;
          r++;
        } else if (z.isRectAreaLight) G = a.get(z), G.color.copy(ra).multiplyScalar(fa), G.position.setFromMatrixPosition(z.matrixWorld), G.position.applyMatrix4(l), f.identity(), e.copy(z.matrixWorld), e.premultiply(l), f.extractRotation(e), G.halfWidth.set(0.5 * z.width, 0, 0), G.halfHeight.set(0, 0.5 * z.height, 0), G.halfWidth.applyMatrix4(f), G.halfHeight.applyMatrix4(f), b.rectArea[u] = G, u++;
        else if (z.isPointLight) {
          G = a.get(z);
          G.position.setFromMatrixPosition(z.matrixWorld);
          G.position.applyMatrix4(l);
          G.color.copy(z.color).multiplyScalar(z.intensity);
          G.distance = z.distance;
          G.decay = z.decay;
          if (G.shadow = z.castShadow) fa = z.shadow, G.shadowBias = fa.bias, G.shadowRadius = fa.radius, G.shadowMapSize = fa.mapSize, G.shadowCameraNear = fa.camera.near, G.shadowCameraFar = fa.camera.far, b.pointShadowMap[t] = w2, b.pointShadowMatrix[t] = z.shadow.matrix, C++;
          b.point[t] = G;
          t++;
        } else z.isHemisphereLight && (G = a.get(z), G.direction.setFromMatrixPosition(z.matrixWorld), G.direction.transformDirection(l), G.direction.normalize(), G.skyColor.copy(z.color).multiplyScalar(fa), G.groundColor.copy(z.groundColor).multiplyScalar(fa), b.hemi[n2] = G, n2++);
      }
      b.ambient[0] = g;
      b.ambient[1] = x;
      b.ambient[2] = p;
      c2 = b.hash;
      if (c2.directionalLength !== k || c2.pointLength !== t || c2.spotLength !== r || c2.rectAreaLength !== u || c2.hemiLength !== n2 || c2.numDirectionalShadows !== v || c2.numPointShadows !== C || c2.numSpotShadows !== W) b.directional.length = k, b.spot.length = r, b.rectArea.length = u, b.point.length = t, b.hemi.length = n2, b.directionalShadowMap.length = v, b.pointShadowMap.length = C, b.spotShadowMap.length = W, b.directionalShadowMatrix.length = v, b.pointShadowMatrix.length = C, b.spotShadowMatrix.length = W, c2.directionalLength = k, c2.pointLength = t, c2.spotLength = r, c2.rectAreaLength = u, c2.hemiLength = n2, c2.numDirectionalShadows = v, c2.numPointShadows = C, c2.numSpotShadows = W, b.version = Fk++;
    }, state: b };
  }
  function Vh() {
    var a = new Ek(), b = [], c = [];
    return { init: function() {
      b.length = 0;
      c.length = 0;
    }, state: { lightsArray: b, shadowsArray: c, lights: a }, setupLights: function(d) {
      a.setup(b, c, d);
    }, pushLight: function(a2) {
      b.push(a2);
    }, pushShadow: function(a2) {
      c.push(a2);
    } };
  }
  function Gk() {
    function a(c) {
      c = c.target;
      c.removeEventListener("dispose", a);
      b.delete(c);
    }
    var b = /* @__PURE__ */ new WeakMap();
    return { get: function(c, d) {
      if (false === b.has(c)) {
        var e = new Vh();
        b.set(c, /* @__PURE__ */ new WeakMap());
        b.get(c).set(d, e);
        c.addEventListener(
          "dispose",
          a
        );
      } else false === b.get(c).has(d) ? (e = new Vh(), b.get(c).set(d, e)) : e = b.get(c).get(d);
      return e;
    }, dispose: function() {
      b = /* @__PURE__ */ new WeakMap();
    } };
  }
  function Gb(a) {
    K.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = 3200;
    this.morphTargets = this.skinning = false;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(a);
  }
  function Hb(a) {
    K.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new n();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.morphTargets = this.skinning = false;
    this.displacementMap = this.alphaMap = this.map = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(a);
  }
  function Wh(a, b, c) {
    function d(a2, b2, c2) {
      c2 = a2 << 0 | b2 << 1 | c2 << 2;
      var d2 = p[c2];
      void 0 === d2 && (d2 = new Gb({ depthPacking: 3201, morphTargets: a2, skinning: b2 }), p[c2] = d2);
      return d2;
    }
    function e(a2, b2, c2) {
      c2 = a2 << 0 | b2 << 1 | c2 << 2;
      var d2 = h2[c2];
      void 0 === d2 && (d2 = new Hb({ morphTargets: a2, skinning: b2 }), h2[c2] = d2);
      return d2;
    }
    function f(b2, c2, f2, g2, k2, l2) {
      var m2 = b2.geometry, p2 = d, x2 = b2.customDepthMaterial;
      true === f2.isPointLight && (p2 = e, x2 = b2.customDistanceMaterial);
      void 0 === x2 ? (x2 = false, true === c2.morphTargets && (true === m2.isBufferGeometry ? x2 = m2.morphAttributes && m2.morphAttributes.position && 0 < m2.morphAttributes.position.length : true === m2.isGeometry && (x2 = m2.morphTargets && 0 < m2.morphTargets.length)), m2 = false, true === b2.isSkinnedMesh && (true === c2.skinning ? m2 = true : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", b2)), b2 = p2(x2, m2, true === b2.isInstancedMesh)) : b2 = x2;
      a.localClippingEnabled && true === c2.clipShadows && 0 !== c2.clippingPlanes.length && (x2 = b2.uuid, p2 = c2.uuid, m2 = t[x2], void 0 === m2 && (m2 = {}, t[x2] = m2), x2 = m2[p2], void 0 === x2 && (x2 = b2.clone(), m2[p2] = x2), b2 = x2);
      b2.visible = c2.visible;
      b2.wireframe = c2.wireframe;
      b2.side = 3 === l2 ? null !== c2.shadowSide ? c2.shadowSide : c2.side : null !== c2.shadowSide ? c2.shadowSide : r[c2.side];
      b2.clipShadows = c2.clipShadows;
      b2.clippingPlanes = c2.clippingPlanes;
      b2.clipIntersection = c2.clipIntersection;
      b2.wireframeLinewidth = c2.wireframeLinewidth;
      b2.linewidth = c2.linewidth;
      true === f2.isPointLight && true === b2.isMeshDistanceMaterial && (b2.referencePosition.setFromMatrixPosition(f2.matrixWorld), b2.nearDistance = g2, b2.farDistance = k2);
      return b2;
    }
    function g(c2, d2, e2, l2, m2) {
      if (false !== c2.visible) {
        if (c2.layers.test(d2.layers) && (c2.isMesh || c2.isLine || c2.isPoints) && (c2.castShadow || c2.receiveShadow && 3 === m2) && (!c2.frustumCulled || k.intersectsObject(c2))) {
          c2.modelViewMatrix.multiplyMatrices(e2.matrixWorldInverse, c2.matrixWorld);
          var p2 = b.update(c2), x2 = c2.material;
          if (Array.isArray(x2)) for (var h3 = p2.groups, r2 = 0, q = h3.length; r2 < q; r2++) {
            var t2 = h3[r2], u2 = x2[t2.materialIndex];
            u2 && u2.visible && (u2 = f(c2, u2, l2, e2.near, e2.far, m2), a.renderBufferDirect(
              e2,
              null,
              p2,
              u2,
              c2,
              t2
            ));
          }
          else x2.visible && (u2 = f(c2, x2, l2, e2.near, e2.far, m2), a.renderBufferDirect(e2, null, p2, u2, c2, null));
        }
        c2 = c2.children;
        p2 = 0;
        for (x2 = c2.length; p2 < x2; p2++) g(c2[p2], d2, e2, l2, m2);
      }
    }
    var k = new Hc(), l = new w(), m = new w(), x = new ia(), p = [], h2 = [], t = {}, r = { 0: 1, 1: 0, 2: 2 }, u = new qa({ defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 0.125 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new w() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), n2 = u.clone();
    n2.defines.HORIZONAL_PASS = 1;
    var v = new A();
    v.setAttribute("position", new M(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    var C = new ca(v, u), W = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = 1;
    this.render = function(d2, e2, f2) {
      if (false !== W.enabled && (false !== W.autoUpdate || false !== W.needsUpdate) && 0 !== d2.length) {
        var p2 = a.getRenderTarget(), h3 = a.getActiveCubeFace(), r2 = a.getActiveMipmapLevel(), q = a.state;
        q.setBlending(0);
        q.buffers.color.setClear(1, 1, 1, 1);
        q.buffers.depth.setTest(true);
        q.setScissorTest(false);
        for (var t2 = 0, y = d2.length; t2 < y; t2++) {
          var v2 = d2[t2], z = v2.shadow;
          if (void 0 === z) console.warn("THREE.WebGLShadowMap:", v2, "has no shadow.");
          else {
            l.copy(z.mapSize);
            var w2 = z.getFrameExtents();
            l.multiply(w2);
            m.copy(z.mapSize);
            if (l.x > c || l.y > c) console.warn("THREE.WebGLShadowMap:", v2, "has shadow exceeding max texture size, reducing"), l.x > c && (m.x = Math.floor(c / w2.x), l.x = m.x * w2.x, z.mapSize.x = m.x), l.y > c && (m.y = Math.floor(c / w2.y), l.y = m.y * w2.y, z.mapSize.y = m.y);
            null !== z.map || z.isPointLightShadow || 3 !== this.type || (w2 = {
              minFilter: 1006,
              magFilter: 1006,
              format: 1023
            }, z.map = new wa(l.x, l.y, w2), z.map.texture.name = v2.name + ".shadowMap", z.mapPass = new wa(l.x, l.y, w2), z.camera.updateProjectionMatrix());
            null === z.map && (w2 = { minFilter: 1003, magFilter: 1003, format: 1023 }, z.map = new wa(l.x, l.y, w2), z.map.texture.name = v2.name + ".shadowMap", z.camera.updateProjectionMatrix());
            a.setRenderTarget(z.map);
            a.clear();
            w2 = z.getViewportCount();
            for (var ja = 0; ja < w2; ja++) {
              var ra = z.getViewport(ja);
              x.set(m.x * ra.x, m.y * ra.y, m.x * ra.z, m.y * ra.w);
              q.viewport(x);
              z.updateMatrices(v2, ja);
              k = z.getFrustum();
              g(e2, f2, z.camera, v2, this.type);
            }
            z.isPointLightShadow || 3 !== this.type || (v2 = z, z = f2, w2 = b.update(C), u.uniforms.shadow_pass.value = v2.map.texture, u.uniforms.resolution.value = v2.mapSize, u.uniforms.radius.value = v2.radius, a.setRenderTarget(v2.mapPass), a.clear(), a.renderBufferDirect(z, null, w2, u, C, null), n2.uniforms.shadow_pass.value = v2.mapPass.texture, n2.uniforms.resolution.value = v2.mapSize, n2.uniforms.radius.value = v2.radius, a.setRenderTarget(v2.map), a.clear(), a.renderBufferDirect(z, null, w2, n2, C, null));
          }
        }
        W.needsUpdate = false;
        a.setRenderTarget(
          p2,
          h3,
          r2
        );
      }
    };
  }
  function Hk(a, b, c) {
    function d(b2, c2, d2) {
      var e2 = new Uint8Array(4), f2 = a.createTexture();
      a.bindTexture(b2, f2);
      a.texParameteri(b2, 10241, 9728);
      a.texParameteri(b2, 10240, 9728);
      for (b2 = 0; b2 < d2; b2++) a.texImage2D(c2 + b2, 0, 6408, 1, 1, 0, 6408, 5121, e2);
      return f2;
    }
    function e(c2, d2) {
      n2[c2] = 1;
      0 === v[c2] && (a.enableVertexAttribArray(c2), v[c2] = 1);
      C[c2] !== d2 && ((h2 ? a : b.get("ANGLE_instanced_arrays"))[h2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](c2, d2), C[c2] = d2);
    }
    function f(b2) {
      true !== W[b2] && (a.enable(b2), W[b2] = true);
    }
    function g(b2) {
      false !== W[b2] && (a.disable(b2), W[b2] = false);
    }
    function k(b2, c2, d2, e2, k2, l2, m2, p2) {
      if (0 === b2) z && (g(3042), z = false);
      else if (z || (f(3042), z = true), 5 !== b2) {
        if (b2 !== ra || p2 !== F2) {
          if (100 !== fa || 100 !== G) a.blendEquation(32774), G = fa = 100;
          if (p2) switch (b2) {
            case 1:
              a.blendFuncSeparate(1, 771, 1, 771);
              break;
            case 2:
              a.blendFunc(1, 1);
              break;
            case 3:
              a.blendFuncSeparate(0, 0, 769, 771);
              break;
            case 4:
              a.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", b2);
          }
          else switch (b2) {
            case 1:
              a.blendFuncSeparate(770, 771, 1, 771);
              break;
            case 2:
              a.blendFunc(
                770,
                1
              );
              break;
            case 3:
              a.blendFunc(0, 769);
              break;
            case 4:
              a.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", b2);
          }
          E2 = Nd = Ha = Ga = null;
          ra = b2;
          F2 = p2;
        }
      } else {
        k2 = k2 || c2;
        l2 = l2 || d2;
        m2 = m2 || e2;
        if (c2 !== fa || k2 !== G) a.blendEquationSeparate(Lc[c2], Lc[k2]), fa = c2, G = k2;
        if (d2 !== Ga || e2 !== Ha || l2 !== Nd || m2 !== E2) a.blendFuncSeparate(J[d2], J[e2], J[l2], J[m2]), Ga = d2, Ha = e2, Nd = l2, E2 = m2;
        ra = b2;
        F2 = null;
      }
    }
    function l(b2) {
      D2 !== b2 && (b2 ? a.frontFace(2304) : a.frontFace(2305), D2 = b2);
    }
    function m(b2) {
      0 !== b2 ? (f(2884), b2 !== B2 && (1 === b2 ? a.cullFace(1029) : 2 === b2 ? a.cullFace(1028) : a.cullFace(1032))) : g(2884);
      B2 = b2;
    }
    function x(b2, c2, d2) {
      if (b2) {
        if (f(32823), I2 !== c2 || K2 !== d2) a.polygonOffset(c2, d2), I2 = c2, K2 = d2;
      } else g(32823);
    }
    function p(b2) {
      void 0 === b2 && (b2 = 33984 + M2 - 1);
      P2 !== b2 && (a.activeTexture(b2), P2 = b2);
    }
    var h2 = c.isWebGL2, t = new function() {
      var b2 = false, c2 = new ia(), d2 = null, e2 = new ia(0, 0, 0, 0);
      return { setMask: function(c3) {
        d2 === c3 || b2 || (a.colorMask(c3, c3, c3, c3), d2 = c3);
      }, setLocked: function(a2) {
        b2 = a2;
      }, setClear: function(b3, d3, f2, g2, k2) {
        true === k2 && (b3 *= g2, d3 *= g2, f2 *= g2);
        c2.set(b3, d3, f2, g2);
        false === e2.equals(c2) && (a.clearColor(b3, d3, f2, g2), e2.copy(c2));
      }, reset: function() {
        b2 = false;
        d2 = null;
        e2.set(-1, 0, 0, 0);
      } };
    }(), r = new function() {
      var b2 = false, c2 = null, d2 = null, e2 = null;
      return { setTest: function(a2) {
        a2 ? f(2929) : g(2929);
      }, setMask: function(d3) {
        c2 === d3 || b2 || (a.depthMask(d3), c2 = d3);
      }, setFunc: function(b3) {
        if (d2 !== b3) {
          if (b3) switch (b3) {
            case 0:
              a.depthFunc(512);
              break;
            case 1:
              a.depthFunc(519);
              break;
            case 2:
              a.depthFunc(513);
              break;
            case 3:
              a.depthFunc(515);
              break;
            case 4:
              a.depthFunc(514);
              break;
            case 5:
              a.depthFunc(518);
              break;
            case 6:
              a.depthFunc(516);
              break;
            case 7:
              a.depthFunc(517);
              break;
            default:
              a.depthFunc(515);
          }
          else a.depthFunc(515);
          d2 = b3;
        }
      }, setLocked: function(a2) {
        b2 = a2;
      }, setClear: function(b3) {
        e2 !== b3 && (a.clearDepth(b3), e2 = b3);
      }, reset: function() {
        b2 = false;
        e2 = d2 = c2 = null;
      } };
    }(), u = new function() {
      var b2 = false, c2 = null, d2 = null, e2 = null, k2 = null, l2 = null, m2 = null, p2 = null, x2 = null;
      return { setTest: function(a2) {
        b2 || (a2 ? f(2960) : g(2960));
      }, setMask: function(d3) {
        c2 === d3 || b2 || (a.stencilMask(d3), c2 = d3);
      }, setFunc: function(b3, c3, f2) {
        if (d2 !== b3 || e2 !== c3 || k2 !== f2) a.stencilFunc(b3, c3, f2), d2 = b3, e2 = c3, k2 = f2;
      }, setOp: function(b3, c3, d3) {
        if (l2 !== b3 || m2 !== c3 || p2 !== d3) a.stencilOp(b3, c3, d3), l2 = b3, m2 = c3, p2 = d3;
      }, setLocked: function(a2) {
        b2 = a2;
      }, setClear: function(b3) {
        x2 !== b3 && (a.clearStencil(b3), x2 = b3);
      }, reset: function() {
        b2 = false;
        x2 = p2 = m2 = l2 = k2 = e2 = d2 = c2 = null;
      } };
    }();
    c = a.getParameter(34921);
    var n2 = new Uint8Array(c), v = new Uint8Array(c), C = new Uint8Array(c), W = {}, w2 = null, z = null, ra = null, fa = null, Ga = null, Ha = null, G = null, Nd = null, E2 = null, F2 = false, D2 = null, B2 = null, A2 = null, I2 = null, K2 = null, M2 = a.getParameter(35661), L2 = false;
    c = 0;
    c = a.getParameter(7938);
    -1 !== c.indexOf("WebGL") ? (c = parseFloat(/^WebGL ([0-9])/.exec(c)[1]), L2 = 1 <= c) : -1 !== c.indexOf("OpenGL ES") && (c = parseFloat(/^OpenGL ES ([0-9])/.exec(c)[1]), L2 = 2 <= c);
    var P2 = null, Pd = {}, X = new ia(), Xh = new ia(), og = {};
    og[3553] = d(3553, 3553, 1);
    og[34067] = d(34067, 34069, 6);
    t.setClear(0, 0, 0, 1);
    r.setClear(1);
    u.setClear(0);
    f(2929);
    r.setFunc(3);
    l(false);
    m(1);
    f(2884);
    k(0);
    var Lc = { 100: 32774, 101: 32778, 102: 32779 };
    h2 ? (Lc[103] = 32775, Lc[104] = 32776) : (c = b.get("EXT_blend_minmax"), null !== c && (Lc[103] = c.MIN_EXT, Lc[104] = c.MAX_EXT));
    var J = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
    return { buffers: { color: t, depth: r, stencil: u }, initAttributes: function() {
      for (var a2 = 0, b2 = n2.length; a2 < b2; a2++) n2[a2] = 0;
    }, enableAttribute: function(a2) {
      e(a2, 0);
    }, enableAttributeAndDivisor: e, disableUnusedAttributes: function() {
      for (var b2 = 0, c2 = v.length; b2 !== c2; ++b2) v[b2] !== n2[b2] && (a.disableVertexAttribArray(b2), v[b2] = 0);
    }, enable: f, disable: g, useProgram: function(b2) {
      return w2 !== b2 ? (a.useProgram(b2), w2 = b2, true) : false;
    }, setBlending: k, setMaterial: function(a2, b2) {
      2 === a2.side ? g(2884) : f(2884);
      var c2 = 1 === a2.side;
      b2 && (c2 = !c2);
      l(c2);
      1 === a2.blending && false === a2.transparent ? k(0) : k(
        a2.blending,
        a2.blendEquation,
        a2.blendSrc,
        a2.blendDst,
        a2.blendEquationAlpha,
        a2.blendSrcAlpha,
        a2.blendDstAlpha,
        a2.premultipliedAlpha
      );
      r.setFunc(a2.depthFunc);
      r.setTest(a2.depthTest);
      r.setMask(a2.depthWrite);
      t.setMask(a2.colorWrite);
      b2 = a2.stencilWrite;
      u.setTest(b2);
      b2 && (u.setMask(a2.stencilWriteMask), u.setFunc(a2.stencilFunc, a2.stencilRef, a2.stencilFuncMask), u.setOp(a2.stencilFail, a2.stencilZFail, a2.stencilZPass));
      x(a2.polygonOffset, a2.polygonOffsetFactor, a2.polygonOffsetUnits);
    }, setFlipSided: l, setCullFace: m, setLineWidth: function(b2) {
      b2 !== A2 && (L2 && a.lineWidth(b2), A2 = b2);
    }, setPolygonOffset: x, setScissorTest: function(a2) {
      a2 ? f(3089) : g(3089);
    }, activeTexture: p, bindTexture: function(b2, c2) {
      null === P2 && p();
      var d2 = Pd[P2];
      void 0 === d2 && (d2 = { type: void 0, texture: void 0 }, Pd[P2] = d2);
      if (d2.type !== b2 || d2.texture !== c2) a.bindTexture(b2, c2 || og[b2]), d2.type = b2, d2.texture = c2;
    }, unbindTexture: function() {
      var b2 = Pd[P2];
      void 0 !== b2 && void 0 !== b2.type && (a.bindTexture(b2.type, null), b2.type = void 0, b2.texture = void 0);
    }, compressedTexImage2D: function() {
      try {
        a.compressedTexImage2D.apply(a, arguments);
      } catch (Q) {
        console.error("THREE.WebGLState:", Q);
      }
    }, texImage2D: function() {
      try {
        a.texImage2D.apply(
          a,
          arguments
        );
      } catch (Q) {
        console.error("THREE.WebGLState:", Q);
      }
    }, texImage3D: function() {
      try {
        a.texImage3D.apply(a, arguments);
      } catch (Q) {
        console.error("THREE.WebGLState:", Q);
      }
    }, scissor: function(b2) {
      false === X.equals(b2) && (a.scissor(b2.x, b2.y, b2.z, b2.w), X.copy(b2));
    }, viewport: function(b2) {
      false === Xh.equals(b2) && (a.viewport(b2.x, b2.y, b2.z, b2.w), Xh.copy(b2));
    }, reset: function() {
      for (var b2 = 0; b2 < v.length; b2++) 1 === v[b2] && (a.disableVertexAttribArray(b2), v[b2] = 0);
      W = {};
      P2 = null;
      Pd = {};
      B2 = D2 = ra = w2 = null;
      t.reset();
      r.reset();
      u.reset();
    } };
  }
  function Ik(a, b, c, d, e, f, g) {
    function k(a2, b2) {
      return A2 ? new OffscreenCanvas(a2, b2) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function l(a2, b2, c2, d2) {
      var e2 = 1;
      if (a2.width > d2 || a2.height > d2) e2 = d2 / Math.max(a2.width, a2.height);
      if (1 > e2 || true === b2) {
        if ("undefined" !== typeof HTMLImageElement && a2 instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && a2 instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a2 instanceof ImageBitmap) return d2 = b2 ? P.floorPowerOfTwo : Math.floor, b2 = d2(e2 * a2.width), e2 = d2(e2 * a2.height), void 0 === B2 && (B2 = k(b2, e2)), c2 = c2 ? k(b2, e2) : B2, c2.width = b2, c2.height = e2, c2.getContext("2d").drawImage(a2, 0, 0, b2, e2), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + a2.width + "x" + a2.height + ") to (" + b2 + "x" + e2 + ")."), c2;
        "data" in a2 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a2.width + "x" + a2.height + ").");
      }
      return a2;
    }
    function m(a2) {
      return P.isPowerOfTwo(a2.width) && P.isPowerOfTwo(a2.height);
    }
    function x(a2, b2) {
      return a2.generateMipmaps && b2 && 1003 !== a2.minFilter && 1006 !== a2.minFilter;
    }
    function p(b2, c2, e2, f2) {
      a.generateMipmap(b2);
      d.get(c2).__maxMipLevel = Math.log(Math.max(e2, f2)) * Math.LOG2E;
    }
    function h2(c2, d2, e2) {
      if (false === Ha) return d2;
      if (null !== c2) {
        if (void 0 !== a[c2]) return a[c2];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + c2 + "'");
      }
      c2 = d2;
      6403 === d2 && (5126 === e2 && (c2 = 33326), 5131 === e2 && (c2 = 33325), 5121 === e2 && (c2 = 33321));
      6407 === d2 && (5126 === e2 && (c2 = 34837), 5131 === e2 && (c2 = 34843), 5121 === e2 && (c2 = 32849));
      6408 === d2 && (5126 === e2 && (c2 = 34836), 5131 === e2 && (c2 = 34842), 5121 === e2 && (c2 = 32856));
      33325 === c2 || 33326 === c2 || 34842 === c2 || 34836 === c2 ? b.get("EXT_color_buffer_float") : (34843 === c2 || 34837 === c2) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
      return c2;
    }
    function t(a2) {
      return 1003 === a2 || 1004 === a2 || 1005 === a2 ? 9728 : 9729;
    }
    function r(b2) {
      b2 = b2.target;
      b2.removeEventListener("dispose", r);
      var c2 = d.get(b2);
      void 0 !== c2.__webglInit && (a.deleteTexture(c2.__webglTexture), d.remove(b2));
      b2.isVideoTexture && D2.delete(b2);
      g.memory.textures--;
    }
    function u(b2) {
      b2 = b2.target;
      b2.removeEventListener("dispose", u);
      var c2 = d.get(b2), e2 = d.get(b2.texture);
      if (b2) {
        void 0 !== e2.__webglTexture && a.deleteTexture(e2.__webglTexture);
        b2.depthTexture && b2.depthTexture.dispose();
        if (b2.isWebGLCubeRenderTarget) for (e2 = 0; 6 > e2; e2++) a.deleteFramebuffer(c2.__webglFramebuffer[e2]), c2.__webglDepthbuffer && a.deleteRenderbuffer(c2.__webglDepthbuffer[e2]);
        else a.deleteFramebuffer(c2.__webglFramebuffer), c2.__webglDepthbuffer && a.deleteRenderbuffer(c2.__webglDepthbuffer);
        if (b2.isWebGLMultiviewRenderTarget) {
          a.deleteTexture(c2.__webglColorTexture);
          a.deleteTexture(c2.__webglDepthStencilTexture);
          g.memory.textures -= 2;
          e2 = 0;
          for (var f2 = c2.__webglViewFramebuffers.length; e2 < f2; e2++) a.deleteFramebuffer(c2.__webglViewFramebuffers[e2]);
        }
        d.remove(b2.texture);
        d.remove(b2);
      }
      g.memory.textures--;
    }
    function n2(a2, b2) {
      var e2 = d.get(a2);
      if (a2.isVideoTexture) {
        var f2 = g.render.frame;
        D2.get(a2) !== f2 && (D2.set(a2, f2), a2.update());
      }
      if (0 < a2.version && e2.__version !== a2.version) if (f2 = a2.image, void 0 === f2) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else if (false === f2.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        z(e2, a2, b2);
        return;
      }
      c.activeTexture(33984 + b2);
      c.bindTexture(3553, e2.__webglTexture);
    }
    function v(b2, e2) {
      if (6 === b2.image.length) {
        var g2 = d.get(b2);
        if (0 < b2.version && g2.__version !== b2.version) {
          w2(g2, b2);
          c.activeTexture(33984 + e2);
          c.bindTexture(34067, g2.__webglTexture);
          a.pixelStorei(37440, b2.flipY);
          var k2 = b2 && (b2.isCompressedTexture || b2.image[0].isCompressedTexture);
          e2 = b2.image[0] && b2.image[0].isDataTexture;
          for (var r2 = [], q = 0; 6 > q; q++) r2[q] = k2 || e2 ? e2 ? b2.image[q].image : b2.image[q] : l(b2.image[q], false, true, Nd);
          var t2 = r2[0], u2 = m(t2) || Ha, n3 = f.convert(b2.format), y = f.convert(b2.type), v2 = h2(b2.internalFormat, n3, y);
          W(34067, b2, u2);
          if (k2) {
            for (q = 0; 6 > q; q++) {
              var z2 = r2[q].mipmaps;
              for (k2 = 0; k2 < z2.length; k2++) {
                var X = z2[k2];
                1023 !== b2.format && 1022 !== b2.format ? null !== n3 ? c.compressedTexImage2D(34069 + q, k2, v2, X.width, X.height, 0, X.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(34069 + q, k2, v2, X.width, X.height, 0, n3, y, X.data);
              }
            }
            g2.__maxMipLevel = z2.length - 1;
          } else {
            z2 = b2.mipmaps;
            for (q = 0; 6 > q; q++) if (e2) for (c.texImage2D(
              34069 + q,
              0,
              v2,
              r2[q].width,
              r2[q].height,
              0,
              n3,
              y,
              r2[q].data
            ), k2 = 0; k2 < z2.length; k2++) X = z2[k2], X = X.image[q].image, c.texImage2D(34069 + q, k2 + 1, v2, X.width, X.height, 0, n3, y, X.data);
            else for (c.texImage2D(34069 + q, 0, v2, n3, y, r2[q]), k2 = 0; k2 < z2.length; k2++) X = z2[k2], c.texImage2D(34069 + q, k2 + 1, v2, n3, y, X.image[q]);
            g2.__maxMipLevel = z2.length;
          }
          x(b2, u2) && p(34067, b2, t2.width, t2.height);
          g2.__version = b2.version;
          if (b2.onUpdate) b2.onUpdate(b2);
        } else c.activeTexture(33984 + e2), c.bindTexture(34067, g2.__webglTexture);
      }
    }
    function C(a2, b2) {
      c.activeTexture(33984 + b2);
      c.bindTexture(34067, d.get(a2).__webglTexture);
    }
    function W(c2, f2, g2) {
      g2 ? (a.texParameteri(c2, 10242, K2[f2.wrapS]), a.texParameteri(c2, 10243, K2[f2.wrapT]), 32879 !== c2 && 35866 !== c2 || a.texParameteri(c2, 32882, K2[f2.wrapR]), a.texParameteri(c2, 10240, L2[f2.magFilter]), a.texParameteri(c2, 10241, L2[f2.minFilter])) : (a.texParameteri(c2, 10242, 33071), a.texParameteri(c2, 10243, 33071), 32879 !== c2 && 35866 !== c2 || a.texParameteri(c2, 32882, 33071), 1001 === f2.wrapS && 1001 === f2.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(c2, 10240, t(f2.magFilter)), a.texParameteri(c2, 10241, t(f2.minFilter)), 1003 !== f2.minFilter && 1006 !== f2.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
      !(g2 = b.get("EXT_texture_filter_anisotropic")) || 1015 === f2.type && null === b.get("OES_texture_float_linear") || 1016 === f2.type && null === (Ha || b.get("OES_texture_half_float_linear")) || !(1 < f2.anisotropy || d.get(f2).__currentAnisotropy) || (a.texParameterf(
        c2,
        g2.TEXTURE_MAX_ANISOTROPY_EXT,
        Math.min(f2.anisotropy, e.getMaxAnisotropy())
      ), d.get(f2).__currentAnisotropy = f2.anisotropy);
    }
    function w2(b2, c2) {
      void 0 === b2.__webglInit && (b2.__webglInit = true, c2.addEventListener("dispose", r), b2.__webglTexture = a.createTexture(), g.memory.textures++);
    }
    function z(b2, d2, e2) {
      var g2 = 3553;
      d2.isDataTexture2DArray && (g2 = 35866);
      d2.isDataTexture3D && (g2 = 32879);
      w2(b2, d2);
      c.activeTexture(33984 + e2);
      c.bindTexture(g2, b2.__webglTexture);
      a.pixelStorei(37440, d2.flipY);
      a.pixelStorei(37441, d2.premultiplyAlpha);
      a.pixelStorei(
        3317,
        d2.unpackAlignment
      );
      e2 = Ha ? false : 1001 !== d2.wrapS || 1001 !== d2.wrapT || 1003 !== d2.minFilter && 1006 !== d2.minFilter;
      e2 = e2 && false === m(d2.image);
      e2 = l(d2.image, e2, false, E2);
      var k2 = m(e2) || Ha, r2 = f.convert(d2.format), q = f.convert(d2.type), t2 = h2(d2.internalFormat, r2, q);
      W(g2, d2, k2);
      var u2 = d2.mipmaps;
      if (d2.isDepthTexture) {
        t2 = 6402;
        if (1015 === d2.type) {
          if (false === Ha) throw Error("Float Depth Texture only supported in WebGL2.0");
          t2 = 36012;
        } else Ha && (t2 = 33189);
        1026 === d2.format && 6402 === t2 && 1012 !== d2.type && 1014 !== d2.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), d2.type = 1012, q = f.convert(d2.type));
        1027 === d2.format && (t2 = 34041, 1020 !== d2.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), d2.type = 1020, q = f.convert(d2.type)));
        c.texImage2D(3553, 0, t2, e2.width, e2.height, 0, r2, q, null);
      } else if (d2.isDataTexture) if (0 < u2.length && k2) {
        for (var n3 = 0, y = u2.length; n3 < y; n3++) {
          var v2 = u2[n3];
          c.texImage2D(3553, n3, t2, v2.width, v2.height, 0, r2, q, v2.data);
        }
        d2.generateMipmaps = false;
        b2.__maxMipLevel = u2.length - 1;
      } else c.texImage2D(3553, 0, t2, e2.width, e2.height, 0, r2, q, e2.data), b2.__maxMipLevel = 0;
      else if (d2.isCompressedTexture) {
        n3 = 0;
        for (y = u2.length; n3 < y; n3++) v2 = u2[n3], 1023 !== d2.format && 1022 !== d2.format ? null !== r2 ? c.compressedTexImage2D(3553, n3, t2, v2.width, v2.height, 0, v2.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(3553, n3, t2, v2.width, v2.height, 0, r2, q, v2.data);
        b2.__maxMipLevel = u2.length - 1;
      } else if (d2.isDataTexture2DArray) c.texImage3D(35866, 0, t2, e2.width, e2.height, e2.depth, 0, r2, q, e2.data), b2.__maxMipLevel = 0;
      else if (d2.isDataTexture3D) c.texImage3D(
        32879,
        0,
        t2,
        e2.width,
        e2.height,
        e2.depth,
        0,
        r2,
        q,
        e2.data
      ), b2.__maxMipLevel = 0;
      else if (0 < u2.length && k2) {
        n3 = 0;
        for (y = u2.length; n3 < y; n3++) v2 = u2[n3], c.texImage2D(3553, n3, t2, r2, q, v2);
        d2.generateMipmaps = false;
        b2.__maxMipLevel = u2.length - 1;
      } else c.texImage2D(3553, 0, t2, r2, q, e2), b2.__maxMipLevel = 0;
      x(d2, k2) && p(g2, d2, e2.width, e2.height);
      b2.__version = d2.version;
      if (d2.onUpdate) d2.onUpdate(d2);
    }
    function ra(b2, e2, g2, k2) {
      var l2 = f.convert(e2.texture.format), m2 = f.convert(e2.texture.type), p2 = h2(e2.texture.internalFormat, l2, m2);
      c.texImage2D(k2, 0, p2, e2.width, e2.height, 0, l2, m2, null);
      a.bindFramebuffer(
        36160,
        b2
      );
      a.framebufferTexture2D(36160, g2, k2, d.get(e2.texture).__webglTexture, 0);
      a.bindFramebuffer(36160, null);
    }
    function fa(b2, c2, d2) {
      a.bindRenderbuffer(36161, b2);
      if (c2.depthBuffer && !c2.stencilBuffer) d2 ? (d2 = Ga(c2), a.renderbufferStorageMultisample(36161, d2, 33189, c2.width, c2.height)) : a.renderbufferStorage(36161, 33189, c2.width, c2.height), a.framebufferRenderbuffer(36160, 36096, 36161, b2);
      else if (c2.depthBuffer && c2.stencilBuffer) d2 ? (d2 = Ga(c2), a.renderbufferStorageMultisample(36161, d2, 35056, c2.width, c2.height)) : a.renderbufferStorage(
        36161,
        34041,
        c2.width,
        c2.height
      ), a.framebufferRenderbuffer(36160, 33306, 36161, b2);
      else {
        b2 = f.convert(c2.texture.format);
        var e2 = f.convert(c2.texture.type);
        b2 = h2(c2.texture.internalFormat, b2, e2);
        d2 ? (d2 = Ga(c2), a.renderbufferStorageMultisample(36161, d2, b2, c2.width, c2.height)) : a.renderbufferStorage(36161, b2, c2.width, c2.height);
      }
      a.bindRenderbuffer(36161, null);
    }
    function Ga(a2) {
      return Ha && a2.isWebGLMultisampleRenderTarget ? Math.min(F2, a2.samples) : 0;
    }
    var Ha = e.isWebGL2, G = e.maxTextures, Nd = e.maxCubemapSize, E2 = e.maxTextureSize, F2 = e.maxSamples, D2 = /* @__PURE__ */ new WeakMap(), B2, A2 = false;
    try {
      A2 = "undefined" !== typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (Pd) {
    }
    var I2 = 0, K2 = { 1e3: 10497, 1001: 33071, 1002: 33648 }, L2 = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 }, M2 = false, O2 = false;
    this.allocateTextureUnit = function() {
      var a2 = I2;
      a2 >= G && console.warn("THREE.WebGLTextures: Trying to use " + a2 + " texture units while this GPU supports only " + G);
      I2 += 1;
      return a2;
    };
    this.resetTextureUnits = function() {
      I2 = 0;
    };
    this.setTexture2D = n2;
    this.setTexture2DArray = function(a2, b2) {
      var e2 = d.get(a2);
      0 < a2.version && e2.__version !== a2.version ? z(e2, a2, b2) : (c.activeTexture(33984 + b2), c.bindTexture(35866, e2.__webglTexture));
    };
    this.setTexture3D = function(a2, b2) {
      var e2 = d.get(a2);
      0 < a2.version && e2.__version !== a2.version ? z(e2, a2, b2) : (c.activeTexture(33984 + b2), c.bindTexture(32879, e2.__webglTexture));
    };
    this.setTextureCube = v;
    this.setTextureCubeDynamic = C;
    this.setupRenderTarget = function(e2) {
      var k2 = d.get(e2), l2 = d.get(e2.texture);
      e2.addEventListener("dispose", u);
      l2.__webglTexture = a.createTexture();
      g.memory.textures++;
      var r2 = true === e2.isWebGLCubeRenderTarget, q = true === e2.isWebGLMultisampleRenderTarget, t2 = true === e2.isWebGLMultiviewRenderTarget, y = m(e2) || Ha;
      if (r2) {
        k2.__webglFramebuffer = [];
        for (var v2 = 0; 6 > v2; v2++) k2.__webglFramebuffer[v2] = a.createFramebuffer();
      } else if (k2.__webglFramebuffer = a.createFramebuffer(), q) if (Ha) {
        k2.__webglMultisampledFramebuffer = a.createFramebuffer();
        k2.__webglColorRenderbuffer = a.createRenderbuffer();
        a.bindRenderbuffer(36161, k2.__webglColorRenderbuffer);
        q = f.convert(e2.texture.format);
        var z2 = f.convert(e2.texture.type);
        q = h2(e2.texture.internalFormat, q, z2);
        z2 = Ga(e2);
        a.renderbufferStorageMultisample(36161, z2, q, e2.width, e2.height);
        a.bindFramebuffer(36160, k2.__webglMultisampledFramebuffer);
        a.framebufferRenderbuffer(36160, 36064, 36161, k2.__webglColorRenderbuffer);
        a.bindRenderbuffer(36161, null);
        e2.depthBuffer && (k2.__webglDepthRenderbuffer = a.createRenderbuffer(), fa(k2.__webglDepthRenderbuffer, e2, true));
        a.bindFramebuffer(36160, null);
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      else if (t2) {
        v2 = e2.width;
        var C2 = e2.height;
        q = e2.numViews;
        a.bindFramebuffer(36160, k2.__webglFramebuffer);
        var G2 = b.get("OVR_multiview2");
        g.memory.textures += 2;
        z2 = a.createTexture();
        a.bindTexture(35866, z2);
        a.texParameteri(35866, 10240, 9728);
        a.texParameteri(35866, 10241, 9728);
        a.texImage3D(35866, 0, 32856, v2, C2, q, 0, 6408, 5121, null);
        G2.framebufferTextureMultiviewOVR(36160, 36064, z2, 0, 0, q);
        var w3 = a.createTexture();
        a.bindTexture(35866, w3);
        a.texParameteri(35866, 10240, 9728);
        a.texParameteri(35866, 10241, 9728);
        a.texImage3D(35866, 0, 35056, v2, C2, q, 0, 34041, 34042, null);
        G2.framebufferTextureMultiviewOVR(
          36160,
          33306,
          w3,
          0,
          0,
          q
        );
        C2 = Array(q);
        for (v2 = 0; v2 < q; ++v2) C2[v2] = a.createFramebuffer(), a.bindFramebuffer(36160, C2[v2]), a.framebufferTextureLayer(36160, 36064, z2, 0, v2);
        k2.__webglColorTexture = z2;
        k2.__webglDepthStencilTexture = w3;
        k2.__webglViewFramebuffers = C2;
        a.bindFramebuffer(36160, null);
        a.bindTexture(35866, null);
      }
      if (r2) {
        c.bindTexture(34067, l2.__webglTexture);
        W(34067, e2.texture, y);
        for (v2 = 0; 6 > v2; v2++) ra(k2.__webglFramebuffer[v2], e2, 36064, 34069 + v2);
        x(e2.texture, y) && p(34067, e2.texture, e2.width, e2.height);
        c.bindTexture(34067, null);
      } else t2 || (c.bindTexture(
        3553,
        l2.__webglTexture
      ), W(3553, e2.texture, y), ra(k2.__webglFramebuffer, e2, 36064, 3553), x(e2.texture, y) && p(3553, e2.texture, e2.width, e2.height), c.bindTexture(3553, null));
      if (e2.depthBuffer) {
        k2 = d.get(e2);
        l2 = true === e2.isWebGLCubeRenderTarget;
        if (e2.depthTexture) {
          if (l2) throw Error("target.depthTexture not supported in Cube render targets");
          if (e2 && e2.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported");
          a.bindFramebuffer(36160, k2.__webglFramebuffer);
          if (!e2.depthTexture || !e2.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          d.get(e2.depthTexture).__webglTexture && e2.depthTexture.image.width === e2.width && e2.depthTexture.image.height === e2.height || (e2.depthTexture.image.width = e2.width, e2.depthTexture.image.height = e2.height, e2.depthTexture.needsUpdate = true);
          n2(e2.depthTexture, 0);
          k2 = d.get(e2.depthTexture).__webglTexture;
          if (1026 === e2.depthTexture.format) a.framebufferTexture2D(36160, 36096, 3553, k2, 0);
          else if (1027 === e2.depthTexture.format) a.framebufferTexture2D(36160, 33306, 3553, k2, 0);
          else throw Error("Unknown depthTexture format");
        } else if (l2) for (k2.__webglDepthbuffer = [], l2 = 0; 6 > l2; l2++) a.bindFramebuffer(36160, k2.__webglFramebuffer[l2]), k2.__webglDepthbuffer[l2] = a.createRenderbuffer(), fa(k2.__webglDepthbuffer[l2], e2);
        else a.bindFramebuffer(36160, k2.__webglFramebuffer), k2.__webglDepthbuffer = a.createRenderbuffer(), fa(k2.__webglDepthbuffer, e2);
        a.bindFramebuffer(36160, null);
      }
    };
    this.updateRenderTargetMipmap = function(a2) {
      var b2 = a2.texture, e2 = m(a2) || Ha;
      if (x(b2, e2)) {
        e2 = a2.isWebGLCubeRenderTarget ? 34067 : 3553;
        var f2 = d.get(b2).__webglTexture;
        c.bindTexture(e2, f2);
        p(e2, b2, a2.width, a2.height);
        c.bindTexture(
          e2,
          null
        );
      }
    };
    this.updateMultisampleRenderTarget = function(b2) {
      if (b2.isWebGLMultisampleRenderTarget) if (Ha) {
        var c2 = d.get(b2);
        a.bindFramebuffer(36008, c2.__webglMultisampledFramebuffer);
        a.bindFramebuffer(36009, c2.__webglFramebuffer);
        c2 = b2.width;
        var e2 = b2.height, f2 = 16384;
        b2.depthBuffer && (f2 |= 256);
        b2.stencilBuffer && (f2 |= 1024);
        a.blitFramebuffer(0, 0, c2, e2, 0, 0, c2, e2, f2, 9728);
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    };
    this.safeSetTexture2D = function(a2, b2) {
      a2 && a2.isWebGLRenderTarget && (false === M2 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), M2 = true), a2 = a2.texture);
      n2(a2, b2);
    };
    this.safeSetTextureCube = function(a2, b2) {
      a2 && a2.isWebGLCubeRenderTarget && (false === O2 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), O2 = true), a2 = a2.texture);
      a2 && a2.isCubeTexture || Array.isArray(a2.image) && 6 === a2.image.length ? v(a2, b2) : C(a2, b2);
    };
  }
  function Yh(a, b, c) {
    var d = c.isWebGL2;
    return { convert: function(a2) {
      if (1009 === a2) return 5121;
      if (1017 === a2) return 32819;
      if (1018 === a2) return 32820;
      if (1019 === a2) return 33635;
      if (1010 === a2) return 5120;
      if (1011 === a2) return 5122;
      if (1012 === a2) return 5123;
      if (1013 === a2) return 5124;
      if (1014 === a2) return 5125;
      if (1015 === a2) return 5126;
      if (1016 === a2) {
        if (d) return 5131;
        var c2 = b.get("OES_texture_half_float");
        return null !== c2 ? c2.HALF_FLOAT_OES : null;
      }
      if (1021 === a2) return 6406;
      if (1022 === a2) return 6407;
      if (1023 === a2) return 6408;
      if (1024 === a2) return 6409;
      if (1025 === a2) return 6410;
      if (1026 === a2) return 6402;
      if (1027 === a2) return 34041;
      if (1028 === a2) return 6403;
      if (1029 === a2) return 36244;
      if (1030 === a2) return 33319;
      if (1031 === a2) return 33320;
      if (1032 === a2) return 36248;
      if (1033 === a2) return 36249;
      if (33776 === a2 || 33777 === a2 || 33778 === a2 || 33779 === a2) if (c2 = b.get("WEBGL_compressed_texture_s3tc"), null !== c2) {
        if (33776 === a2) return c2.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (33777 === a2) return c2.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (33778 === a2) return c2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (33779 === a2) return c2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
      if (35840 === a2 || 35841 === a2 || 35842 === a2 || 35843 === a2) if (c2 = b.get("WEBGL_compressed_texture_pvrtc"), null !== c2) {
        if (35840 === a2) return c2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (35841 === a2) return c2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (35842 === a2) return c2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (35843 === a2) return c2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
      if (36196 === a2) return c2 = b.get("WEBGL_compressed_texture_etc1"), null !== c2 ? c2.COMPRESSED_RGB_ETC1_WEBGL : null;
      if (37808 === a2 || 37809 === a2 || 37810 === a2 || 37811 === a2 || 37812 === a2 || 37813 === a2 || 37814 === a2 || 37815 === a2 || 37816 === a2 || 37817 === a2 || 37818 === a2 || 37819 === a2 || 37820 === a2 || 37821 === a2) return c2 = b.get("WEBGL_compressed_texture_astc"), null !== c2 ? a2 : null;
      if (1020 === a2) {
        if (d) return 34042;
        c2 = b.get("WEBGL_depth_texture");
        return null !== c2 ? c2.UNSIGNED_INT_24_8_WEBGL : null;
      }
    } };
  }
  function pg(a, b, c, d) {
    wa.call(this, a, b, d);
    this.stencilBuffer = this.depthBuffer = false;
    this.numViews = c;
  }
  function Jk(a, b) {
    function c(a2) {
      if (a2.isArrayCamera) return a2.cameras;
      x[0] = a2;
      return x;
    }
    function d(a2) {
      if (void 0 === a2.isArrayCamera) return true;
      a2 = a2.cameras;
      if (a2.length > t) return false;
      for (var b2 = 1, c2 = a2.length; b2 < c2; b2++) if (a2[0].viewport.z !== a2[b2].viewport.z || a2[0].viewport.w !== a2[b2].viewport.w) return false;
      return true;
    }
    var e = a.extensions, f = a.properties, g, k, l, m, x, p, h2, t = 0;
    this.isAvailable = function() {
      if (void 0 === h2) {
        var a2 = e.get("OVR_multiview2");
        if (h2 = null !== a2 && false === b.getContextAttributes().antialias) for (t = b.getParameter(a2.MAX_VIEWS_OVR), g = new pg(0, 0, 2), p = new w(), m = [], l = [], x = [], a2 = 0; a2 < t; a2++) m[a2] = new O(), l[a2] = new za();
      }
      return h2;
    };
    this.attachCamera = function(b2) {
      if (false !== d(b2)) {
        (k = a.getRenderTarget()) ? p.set(k.width, k.height) : a.getDrawingBufferSize(p);
        if (b2.isArrayCamera) {
          var c2 = b2.cameras[0].viewport;
          g.setSize(c2.z, c2.w);
          g.setNumViews(b2.cameras.length);
        } else g.setSize(p.x, p.y), g.setNumViews(2);
        a.setRenderTarget(g);
      }
    };
    this.detachCamera = function(c2) {
      if (g === a.getRenderTarget()) {
        a.setRenderTarget(k);
        var d2 = g, e2 = d2.numViews, l2 = f.get(d2).__webglViewFramebuffers, m2 = d2.width;
        d2 = d2.height;
        if (c2.isArrayCamera) for (var x2 = 0; x2 < e2; x2++) {
          var h3 = c2.cameras[x2].viewport, q = h3.x, r = h3.y, t2 = q + h3.z;
          h3 = r + h3.w;
          b.bindFramebuffer(36008, l2[x2]);
          b.blitFramebuffer(
            0,
            0,
            m2,
            d2,
            q,
            r,
            t2,
            h3,
            16384,
            9728
          );
        }
        else b.bindFramebuffer(36008, l2[0]), b.blitFramebuffer(0, 0, m2, d2, 0, 0, p.x, p.y, 16384, 9728);
      }
    };
    this.updateCameraProjectionMatricesUniform = function(a2, d2) {
      a2 = c(a2);
      for (var e2 = 0; e2 < a2.length; e2++) m[e2].copy(a2[e2].projectionMatrix);
      d2.setValue(b, "projectionMatrices", m);
    };
    this.updateCameraViewMatricesUniform = function(a2, d2) {
      a2 = c(a2);
      for (var e2 = 0; e2 < a2.length; e2++) m[e2].copy(a2[e2].matrixWorldInverse);
      d2.setValue(b, "viewMatrices", m);
    };
    this.updateObjectMatricesUniforms = function(a2, d2, e2) {
      d2 = c(d2);
      for (var f2 = 0; f2 < d2.length; f2++) m[f2].multiplyMatrices(
        d2[f2].matrixWorldInverse,
        a2.matrixWorld
      ), l[f2].getNormalMatrix(m[f2]);
      e2.setValue(b, "modelViewMatrices", m);
      e2.setValue(b, "normalMatrices", l);
    };
  }
  function Qe(a) {
    da.call(this);
    this.cameras = a || [];
  }
  function Mc() {
    D.call(this);
    this.type = "Group";
  }
  function Zh(a, b) {
    function c(a2) {
      var b2 = t.get(a2.inputSource);
      b2 && (b2.targetRay && b2.targetRay.dispatchEvent({ type: a2.type }), b2.grip && b2.grip.dispatchEvent({ type: a2.type }));
    }
    function d() {
      t.forEach(function(a2, b2) {
        a2.targetRay && (a2.targetRay.dispatchEvent({ type: "disconnected", data: b2 }), a2.targetRay.visible = false);
        a2.grip && (a2.grip.dispatchEvent({ type: "disconnected", data: b2 }), a2.grip.visible = false);
      });
      t.clear();
      a.setFramebuffer(null);
      a.setRenderTarget(a.getRenderTarget());
      ra.stop();
      k.isPresenting = false;
      k.dispatchEvent({ type: "sessionend" });
    }
    function e(a2) {
      m = a2;
      ra.setContext(l);
      ra.start();
      k.isPresenting = true;
      k.dispatchEvent({ type: "sessionstart" });
    }
    function f(a2) {
      for (var b2 = l.inputSources, c2 = 0; c2 < h2.length; c2++) t.set(b2[c2], h2[c2]);
      for (c2 = 0; c2 < a2.removed.length; c2++) {
        b2 = a2.removed[c2];
        var d2 = t.get(b2);
        d2 && (d2.targetRay && d2.targetRay.dispatchEvent({
          type: "disconnected",
          data: b2
        }), d2.grip && d2.grip.dispatchEvent({ type: "disconnected", data: b2 }), t.delete(b2));
      }
      for (c2 = 0; c2 < a2.added.length; c2++) if (b2 = a2.added[c2], d2 = t.get(b2)) d2.targetRay && d2.targetRay.dispatchEvent({ type: "connected", data: b2 }), d2.grip && d2.grip.dispatchEvent({ type: "connected", data: b2 });
    }
    function g(a2, b2) {
      null === b2 ? a2.matrixWorld.copy(a2.matrix) : a2.matrixWorld.multiplyMatrices(b2.matrixWorld, a2.matrix);
      a2.matrixWorldInverse.getInverse(a2.matrixWorld);
    }
    var k = this, l = null, m = null, x = "local-floor", p = null, h2 = [], t = /* @__PURE__ */ new Map(), r = new da();
    r.layers.enable(1);
    r.viewport = new ia();
    var u = new da();
    u.layers.enable(2);
    u.viewport = new ia();
    var y = new Qe([r, u]);
    y.layers.enable(1);
    y.layers.enable(2);
    var v = null, C = null;
    this.isPresenting = this.enabled = false;
    this.getController = function(a2) {
      var b2 = h2[a2];
      void 0 === b2 && (b2 = {}, h2[a2] = b2);
      void 0 === b2.targetRay && (b2.targetRay = new Mc(), b2.targetRay.matrixAutoUpdate = false, b2.targetRay.visible = false);
      return b2.targetRay;
    };
    this.getControllerGrip = function(a2) {
      var b2 = h2[a2];
      void 0 === b2 && (b2 = {}, h2[a2] = b2);
      void 0 === b2.grip && (b2.grip = new Mc(), b2.grip.matrixAutoUpdate = false, b2.grip.visible = false);
      return b2.grip;
    };
    this.setFramebufferScaleFactor = function() {
    };
    this.setReferenceSpaceType = function(a2) {
      x = a2;
    };
    this.getReferenceSpace = function() {
      return m;
    };
    this.getSession = function() {
      return l;
    };
    this.setSession = function(a2) {
      l = a2;
      null !== l && (l.addEventListener("select", c), l.addEventListener("selectstart", c), l.addEventListener("selectend", c), l.addEventListener("squeeze", c), l.addEventListener("squeezestart", c), l.addEventListener("squeezeend", c), l.addEventListener("end", d), a2 = b.getContextAttributes(), a2 = new XRWebGLLayer(
        l,
        b,
        { antialias: a2.antialias, alpha: a2.alpha, depth: a2.depth, stencil: a2.stencil }
      ), l.updateRenderState({ baseLayer: a2 }), l.requestReferenceSpace(x).then(e), l.addEventListener("inputsourceschange", f));
    };
    var w2 = new n(), ja = new n();
    this.getCamera = function(a2) {
      y.near = u.near = r.near = a2.near;
      y.far = u.far = r.far = a2.far;
      if (v !== y.near || C !== y.far) l.updateRenderState({ depthNear: y.near, depthFar: y.far }), v = y.near, C = y.far;
      var b2 = a2.parent, c2 = y.cameras;
      g(y, b2);
      for (var d2 = 0; d2 < c2.length; d2++) g(c2[d2], b2);
      a2.matrixWorld.copy(y.matrixWorld);
      a2 = a2.children;
      d2 = 0;
      for (b2 = a2.length; d2 < b2; d2++) a2[d2].updateMatrixWorld(true);
      w2.setFromMatrixPosition(r.matrixWorld);
      ja.setFromMatrixPosition(u.matrixWorld);
      d2 = w2.distanceTo(ja);
      var e2 = r.projectionMatrix.elements, f2 = u.projectionMatrix.elements, k2 = e2[14] / (e2[10] - 1);
      a2 = e2[14] / (e2[10] + 1);
      b2 = (e2[9] + 1) / e2[5];
      c2 = (e2[9] - 1) / e2[5];
      var m2 = (e2[8] - 1) / e2[0], p2 = (f2[8] + 1) / f2[0];
      f2 = k2 * m2;
      e2 = k2 * p2;
      p2 = d2 / (-m2 + p2);
      m2 = p2 * -m2;
      r.matrixWorld.decompose(y.position, y.quaternion, y.scale);
      y.translateX(m2);
      y.translateZ(p2);
      y.matrixWorld.compose(y.position, y.quaternion, y.scale);
      y.matrixWorldInverse.getInverse(y.matrixWorld);
      k2 += p2;
      p2 = a2 + p2;
      y.projectionMatrix.makePerspective(f2 - m2, e2 + (d2 - m2), b2 * a2 / p2 * k2, c2 * a2 / p2 * k2, k2, p2);
      return y;
    };
    var z = null, ra = new Ah();
    ra.setAnimationLoop(function(b2, c2) {
      p = c2.getViewerPose(m);
      if (null !== p) {
        var d2 = p.views, e2 = l.renderState.baseLayer;
        a.setFramebuffer(e2.framebuffer);
        for (var f2 = 0; f2 < d2.length; f2++) {
          var g2 = d2[f2], k2 = e2.getViewport(g2), x2 = y.cameras[f2];
          x2.matrix.fromArray(g2.transform.matrix);
          x2.projectionMatrix.fromArray(g2.projectionMatrix);
          x2.viewport.set(k2.x, k2.y, k2.width, k2.height);
          0 === f2 && y.matrix.copy(x2.matrix);
        }
      }
      d2 = l.inputSources;
      for (f2 = 0; f2 < h2.length; f2++) e2 = h2[f2], g2 = d2[f2], x2 = k2 = null, g2 && (e2.targetRay && (k2 = c2.getPose(g2.targetRaySpace, m), null !== k2 && (e2.targetRay.matrix.fromArray(k2.transform.matrix), e2.targetRay.matrix.decompose(e2.targetRay.position, e2.targetRay.rotation, e2.targetRay.scale))), e2.grip && g2.gripSpace && (x2 = c2.getPose(g2.gripSpace, m), null !== x2 && (e2.grip.matrix.fromArray(x2.transform.matrix), e2.grip.matrix.decompose(e2.grip.position, e2.grip.rotation, e2.grip.scale)))), e2.targetRay && (e2.targetRay.visible = null !== k2), e2.grip && (e2.grip.visible = null !== x2);
      z && z(b2, c2);
    });
    this.setAnimationLoop = function(a2) {
      z = a2;
    };
    this.dispose = function() {
    };
  }
  function qg(a) {
    var b;
    function c() {
      sa = new zj(H);
      Ia = new xj(H, sa, a);
      false === Ia.isWebGL2 && (sa.get("WEBGL_depth_texture"), sa.get("OES_texture_float"), sa.get("OES_texture_half_float"), sa.get("OES_texture_half_float_linear"), sa.get("OES_standard_derivatives"), sa.get("OES_element_index_uint"), sa.get("ANGLE_instanced_arrays"));
      sa.get("OES_texture_float_linear");
      qa2 = new Yh(H, sa, Ia);
      aa = new Hk(H, sa, Ia);
      aa.scissor(Y2.copy(R2).multiplyScalar(Q).floor());
      aa.viewport(X.copy(ea2).multiplyScalar(Q).floor());
      da2 = new Cj(H);
      S2 = new yk();
      U2 = new Ik(H, sa, aa, S2, Ia, qa2, da2);
      oa2 = new uj(H, Ia);
      za2 = new Aj(H, oa2, da2);
      ta2 = new Fj(H, za2, oa2, da2);
      Aa2 = new Ej(H);
      ua2 = new xk(A2, sa, Ia);
      ya2 = new Bk();
      wa2 = new Gk();
      pa2 = new vj(A2, aa, ta2, z);
      Ba2 = new wj(H, sa, da2, Ia);
      Da2 = new Bj(H, sa, da2, Ia);
      da2.programs = ua2.programs;
      A2.capabilities = Ia;
      A2.extensions = sa;
      A2.properties = S2;
      A2.renderLists = ya2;
      A2.state = aa;
      A2.info = da2;
    }
    function d(a2) {
      a2.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      I2 = true;
    }
    function e() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      I2 = false;
      c();
    }
    function f(a2) {
      a2 = a2.target;
      a2.removeEventListener("dispose", f);
      g(a2);
      S2.remove(a2);
    }
    function g(a2) {
      var b2 = S2.get(a2).program;
      a2.program = void 0;
      void 0 !== b2 && ua2.releaseProgram(b2);
    }
    function k(a2, b2) {
      a2.render(function(a3) {
        A2.renderBufferImmediate(a3, b2);
      });
    }
    function l(a2, b2, c2, d2) {
      if (false !== a2.visible) {
        if (a2.layers.test(b2.layers)) {
          if (a2.isGroup) c2 = a2.renderOrder;
          else if (a2.isLOD) true === a2.autoUpdate && a2.update(b2);
          else if (a2.isLight) G.pushLight(a2), a2.castShadow && G.pushShadow(a2);
          else if (a2.isSprite) {
            if (!a2.frustumCulled || mg.intersectsSprite(a2)) {
              d2 && Ib.setFromMatrixPosition(a2.matrixWorld).applyMatrix4(Od);
              var e2 = ta2.update(a2), f2 = a2.material;
              f2.visible && B2.push(a2, e2, f2, c2, Ib.z, null);
            }
          } else if (a2.isImmediateRenderObject) d2 && Ib.setFromMatrixPosition(a2.matrixWorld).applyMatrix4(Od), B2.push(a2, null, a2.material, c2, Ib.z, null);
          else if (a2.isMesh || a2.isLine || a2.isPoints) {
            if (a2.isSkinnedMesh && a2.skeleton.frame !== da2.render.frame && (a2.skeleton.update(), a2.skeleton.frame = da2.render.frame), !a2.frustumCulled || mg.intersectsObject(a2)) if (d2 && Ib.setFromMatrixPosition(a2.matrixWorld).applyMatrix4(Od), e2 = ta2.update(a2), f2 = a2.material, Array.isArray(f2)) for (var g2 = e2.groups, k2 = 0, m2 = g2.length; k2 < m2; k2++) {
              var p2 = g2[k2], x2 = f2[p2.materialIndex];
              x2 && x2.visible && B2.push(a2, e2, x2, c2, Ib.z, p2);
            }
            else f2.visible && B2.push(a2, e2, f2, c2, Ib.z, null);
          }
        }
        a2 = a2.children;
        k2 = 0;
        for (m2 = a2.length; k2 < m2; k2++) l(a2[k2], b2, c2, d2);
      }
    }
    function m(a2, b2, c2, d2) {
      for (var e2 = 0, f2 = a2.length; e2 < f2; e2++) {
        var g2 = a2[e2], k2 = g2.object, l2 = g2.geometry, m2 = void 0 === d2 ? g2.material : d2;
        g2 = g2.group;
        if (c2.isArrayCamera) if (T2 = c2, la2.enabled && va2.isAvailable()) x(k2, b2, c2, l2, m2, g2);
        else for (var p2 = c2.cameras, h3 = 0, q = p2.length; h3 < q; h3++) {
          var r2 = p2[h3];
          k2.layers.test(r2.layers) && (aa.viewport(X.copy(r2.viewport)), G.setupLights(r2), x(k2, b2, r2, l2, m2, g2));
        }
        else T2 = null, x(k2, b2, c2, l2, m2, g2);
      }
    }
    function x(a2, c2, d2, e2, f2, g2) {
      a2.onBeforeRender(A2, c2, d2, e2, f2, g2);
      G = wa2.get(c2, T2 || d2);
      a2.modelViewMatrix.multiplyMatrices(d2.matrixWorldInverse, a2.matrixWorld);
      a2.normalMatrix.getNormalMatrix(a2.modelViewMatrix);
      if (a2.isImmediateRenderObject) {
        var l2 = h2(d2, c2, f2, a2);
        aa.setMaterial(f2);
        ha = b = null;
        xa = false;
        k(a2, l2);
      } else A2.renderBufferDirect(d2, c2, e2, f2, a2, g2);
      a2.onAfterRender(A2, c2, d2, e2, f2, g2);
      G = wa2.get(c2, T2 || d2);
    }
    function p(a2, b2, c2) {
      var d2 = S2.get(a2), e2 = G.state.lights, k2 = e2.state.version;
      c2 = ua2.getParameters(a2, e2.state, G.state.shadowsArray, b2, Va.numPlanes, Va.numIntersection, c2);
      var l2 = ua2.getProgramCacheKey(c2), m2 = d2.program, p2 = true;
      if (void 0 === m2) a2.addEventListener("dispose", f);
      else if (m2.cacheKey !== l2) g(a2);
      else {
        if (d2.lightsStateVersion !== k2) d2.lightsStateVersion = k2;
        else if (void 0 !== c2.shaderID) return;
        p2 = false;
      }
      p2 && (m2 = ua2.acquireProgram(c2, l2), d2.program = m2, d2.uniforms = c2.uniforms, d2.environment = a2.isMeshStandardMaterial ? b2.environment : null, d2.outputEncoding = A2.outputEncoding, a2.program = m2);
      c2 = m2.getAttributes();
      if (a2.morphTargets) for (l2 = a2.numSupportedMorphTargets = 0; l2 < A2.maxMorphTargets; l2++) 0 <= c2["morphTarget" + l2] && a2.numSupportedMorphTargets++;
      if (a2.morphNormals) for (l2 = a2.numSupportedMorphNormals = 0; l2 < A2.maxMorphNormals; l2++) 0 <= c2["morphNormal" + l2] && a2.numSupportedMorphNormals++;
      c2 = d2.uniforms;
      if (!a2.isShaderMaterial && !a2.isRawShaderMaterial || true === a2.clipping) d2.numClippingPlanes = Va.numPlanes, d2.numIntersection = Va.numIntersection, c2.clippingPlanes = Va.uniform;
      d2.fog = b2.fog;
      d2.needsLights = a2.isMeshLambertMaterial || a2.isMeshToonMaterial || a2.isMeshPhongMaterial || a2.isMeshStandardMaterial || a2.isShadowMaterial || a2.isShaderMaterial && true === a2.lights;
      d2.lightsStateVersion = k2;
      d2.needsLights && (c2.ambientLightColor.value = e2.state.ambient, c2.lightProbe.value = e2.state.probe, c2.directionalLights.value = e2.state.directional, c2.spotLights.value = e2.state.spot, c2.rectAreaLights.value = e2.state.rectArea, c2.pointLights.value = e2.state.point, c2.hemisphereLights.value = e2.state.hemi, c2.directionalShadowMap.value = e2.state.directionalShadowMap, c2.directionalShadowMatrix.value = e2.state.directionalShadowMatrix, c2.spotShadowMap.value = e2.state.spotShadowMap, c2.spotShadowMatrix.value = e2.state.spotShadowMatrix, c2.pointShadowMap.value = e2.state.pointShadowMap, c2.pointShadowMatrix.value = e2.state.pointShadowMatrix);
      a2 = d2.program.getUniforms();
      a2 = Fb.seqWithValue(a2.seq, c2);
      d2.uniformsList = a2;
    }
    function h2(a2, b2, c2, d2) {
      U2.resetTextureUnits();
      var e2 = b2.fog, f2 = c2.isMeshStandardMaterial ? b2.environment : null, g2 = S2.get(c2), k2 = G.state.lights;
      na2 && (ng || a2 !== Z2) && Va.setState(
        c2.clippingPlanes,
        c2.clipIntersection,
        c2.clipShadows,
        a2,
        g2,
        a2 === Z2 && c2.id === Pe
      );
      c2.version === g2.__version ? void 0 === g2.program ? p(c2, b2, d2) : c2.fog && g2.fog !== e2 ? p(c2, b2, d2) : g2.environment !== f2 ? p(c2, b2, d2) : g2.needsLights && g2.lightsStateVersion !== k2.state.version ? p(c2, b2, d2) : void 0 === g2.numClippingPlanes || g2.numClippingPlanes === Va.numPlanes && g2.numIntersection === Va.numIntersection ? g2.outputEncoding !== A2.outputEncoding && p(c2, b2, d2) : p(c2, b2, d2) : (p(c2, b2, d2), g2.__version = c2.version);
      var l2 = false, m2 = false, x2 = false;
      b2 = g2.program;
      k2 = b2.getUniforms();
      var h3 = g2.uniforms;
      aa.useProgram(b2.program) && (x2 = m2 = l2 = true);
      c2.id !== Pe && (Pe = c2.id, m2 = true);
      if (l2 || Z2 !== a2) {
        0 < b2.numMultiviewViews ? va2.updateCameraProjectionMatricesUniform(a2, k2) : k2.setValue(H, "projectionMatrix", a2.projectionMatrix);
        Ia.logarithmicDepthBuffer && k2.setValue(H, "logDepthBufFC", 2 / (Math.log(a2.far + 1) / Math.LN2));
        Z2 !== a2 && (Z2 = a2, x2 = m2 = true);
        if (c2.isShaderMaterial || c2.isMeshPhongMaterial || c2.isMeshToonMaterial || c2.isMeshStandardMaterial || c2.envMap) l2 = k2.map.cameraPosition, void 0 !== l2 && l2.setValue(H, Ib.setFromMatrixPosition(a2.matrixWorld));
        (c2.isMeshPhongMaterial || c2.isMeshToonMaterial || c2.isMeshLambertMaterial || c2.isMeshBasicMaterial || c2.isMeshStandardMaterial || c2.isShaderMaterial) && k2.setValue(H, "isOrthographic", true === a2.isOrthographicCamera);
        if (c2.isMeshPhongMaterial || c2.isMeshToonMaterial || c2.isMeshLambertMaterial || c2.isMeshBasicMaterial || c2.isMeshStandardMaterial || c2.isShaderMaterial || c2.skinning) 0 < b2.numMultiviewViews ? va2.updateCameraViewMatricesUniform(a2, k2) : k2.setValue(H, "viewMatrix", a2.matrixWorldInverse);
      }
      if (c2.skinning && (k2.setOptional(H, d2, "bindMatrix"), k2.setOptional(H, d2, "bindMatrixInverse"), l2 = d2.skeleton)) {
        var q = l2.bones;
        if (Ia.floatVertexTextures) {
          if (void 0 === l2.boneTexture) {
            q = Math.sqrt(4 * q.length);
            q = P.ceilPowerOfTwo(q);
            q = Math.max(q, 4);
            var n2 = new Float32Array(q * q * 4);
            n2.set(l2.boneMatrices);
            var u2 = new bc(n2, q, q, 1023, 1015);
            l2.boneMatrices = n2;
            l2.boneTexture = u2;
            l2.boneTextureSize = q;
          }
          k2.setValue(H, "boneTexture", l2.boneTexture, U2);
          k2.setValue(H, "boneTextureSize", l2.boneTextureSize);
        } else k2.setOptional(H, l2, "boneMatrices");
      }
      if (m2 || g2.receiveShadow !== d2.receiveShadow) g2.receiveShadow = d2.receiveShadow, k2.setValue(H, "receiveShadow", d2.receiveShadow);
      if (m2) {
        k2.setValue(H, "toneMappingExposure", A2.toneMappingExposure);
        k2.setValue(H, "toneMappingWhitePoint", A2.toneMappingWhitePoint);
        g2.needsLights && (m2 = x2, h3.ambientLightColor.needsUpdate = m2, h3.lightProbe.needsUpdate = m2, h3.directionalLights.needsUpdate = m2, h3.pointLights.needsUpdate = m2, h3.spotLights.needsUpdate = m2, h3.rectAreaLights.needsUpdate = m2, h3.hemisphereLights.needsUpdate = m2);
        e2 && c2.fog && (h3.fogColor.value.copy(e2.color), e2.isFog ? (h3.fogNear.value = e2.near, h3.fogFar.value = e2.far) : e2.isFogExp2 && (h3.fogDensity.value = e2.density));
        if (c2.isMeshBasicMaterial) t(h3, c2);
        else if (c2.isMeshLambertMaterial) t(h3, c2), c2.emissiveMap && (h3.emissiveMap.value = c2.emissiveMap);
        else if (c2.isMeshToonMaterial) t(h3, c2), h3.specular.value.copy(c2.specular), h3.shininess.value = Math.max(c2.shininess, 1e-4), c2.gradientMap && (h3.gradientMap.value = c2.gradientMap), c2.emissiveMap && (h3.emissiveMap.value = c2.emissiveMap), c2.bumpMap && (h3.bumpMap.value = c2.bumpMap, h3.bumpScale.value = c2.bumpScale, 1 === c2.side && (h3.bumpScale.value *= -1)), c2.normalMap && (h3.normalMap.value = c2.normalMap, h3.normalScale.value.copy(c2.normalScale), 1 === c2.side && h3.normalScale.value.negate()), c2.displacementMap && (h3.displacementMap.value = c2.displacementMap, h3.displacementScale.value = c2.displacementScale, h3.displacementBias.value = c2.displacementBias);
        else if (c2.isMeshPhongMaterial) t(h3, c2), h3.specular.value.copy(c2.specular), h3.shininess.value = Math.max(c2.shininess, 1e-4), c2.emissiveMap && (h3.emissiveMap.value = c2.emissiveMap), c2.bumpMap && (h3.bumpMap.value = c2.bumpMap, h3.bumpScale.value = c2.bumpScale, 1 === c2.side && (h3.bumpScale.value *= -1)), c2.normalMap && (h3.normalMap.value = c2.normalMap, h3.normalScale.value.copy(c2.normalScale), 1 === c2.side && h3.normalScale.value.negate()), c2.displacementMap && (h3.displacementMap.value = c2.displacementMap, h3.displacementScale.value = c2.displacementScale, h3.displacementBias.value = c2.displacementBias);
        else if (c2.isMeshStandardMaterial) t(h3, c2, f2), c2.isMeshPhysicalMaterial ? (r(h3, c2, f2), h3.reflectivity.value = c2.reflectivity, h3.clearcoat.value = c2.clearcoat, h3.clearcoatRoughness.value = c2.clearcoatRoughness, c2.sheen && h3.sheen.value.copy(c2.sheen), c2.clearcoatNormalMap && (h3.clearcoatNormalScale.value.copy(c2.clearcoatNormalScale), h3.clearcoatNormalMap.value = c2.clearcoatNormalMap, 1 === c2.side && h3.clearcoatNormalScale.value.negate()), h3.transparency.value = c2.transparency) : r(h3, c2, f2);
        else if (c2.isMeshMatcapMaterial) t(h3, c2), c2.matcap && (h3.matcap.value = c2.matcap), c2.bumpMap && (h3.bumpMap.value = c2.bumpMap, h3.bumpScale.value = c2.bumpScale, 1 === c2.side && (h3.bumpScale.value *= -1)), c2.normalMap && (h3.normalMap.value = c2.normalMap, h3.normalScale.value.copy(c2.normalScale), 1 === c2.side && h3.normalScale.value.negate()), c2.displacementMap && (h3.displacementMap.value = c2.displacementMap, h3.displacementScale.value = c2.displacementScale, h3.displacementBias.value = c2.displacementBias);
        else if (c2.isMeshDepthMaterial) t(h3, c2), c2.displacementMap && (h3.displacementMap.value = c2.displacementMap, h3.displacementScale.value = c2.displacementScale, h3.displacementBias.value = c2.displacementBias);
        else if (c2.isMeshDistanceMaterial) t(h3, c2), c2.displacementMap && (h3.displacementMap.value = c2.displacementMap, h3.displacementScale.value = c2.displacementScale, h3.displacementBias.value = c2.displacementBias), h3.referencePosition.value.copy(c2.referencePosition), h3.nearDistance.value = c2.nearDistance, h3.farDistance.value = c2.farDistance;
        else if (c2.isMeshNormalMaterial) t(h3, c2), c2.bumpMap && (h3.bumpMap.value = c2.bumpMap, h3.bumpScale.value = c2.bumpScale, 1 === c2.side && (h3.bumpScale.value *= -1)), c2.normalMap && (h3.normalMap.value = c2.normalMap, h3.normalScale.value.copy(c2.normalScale), 1 === c2.side && h3.normalScale.value.negate()), c2.displacementMap && (h3.displacementMap.value = c2.displacementMap, h3.displacementScale.value = c2.displacementScale, h3.displacementBias.value = c2.displacementBias);
        else if (c2.isLineBasicMaterial) h3.diffuse.value.copy(c2.color), h3.opacity.value = c2.opacity, c2.isLineDashedMaterial && (h3.dashSize.value = c2.dashSize, h3.totalSize.value = c2.dashSize + c2.gapSize, h3.scale.value = c2.scale);
        else if (c2.isPointsMaterial) {
          h3.diffuse.value.copy(c2.color);
          h3.opacity.value = c2.opacity;
          h3.size.value = c2.size * Q;
          h3.scale.value = 0.5 * J;
          c2.map && (h3.map.value = c2.map);
          c2.alphaMap && (h3.alphaMap.value = c2.alphaMap);
          if (c2.map) var v2 = c2.map;
          else c2.alphaMap && (v2 = c2.alphaMap);
          void 0 !== v2 && (true === v2.matrixAutoUpdate && v2.updateMatrix(), h3.uvTransform.value.copy(v2.matrix));
        } else if (c2.isSpriteMaterial) {
          h3.diffuse.value.copy(c2.color);
          h3.opacity.value = c2.opacity;
          h3.rotation.value = c2.rotation;
          c2.map && (h3.map.value = c2.map);
          c2.alphaMap && (h3.alphaMap.value = c2.alphaMap);
          if (c2.map) var y2 = c2.map;
          else c2.alphaMap && (y2 = c2.alphaMap);
          void 0 !== y2 && (true === y2.matrixAutoUpdate && y2.updateMatrix(), h3.uvTransform.value.copy(y2.matrix));
        } else c2.isShadowMaterial && (h3.color.value.copy(c2.color), h3.opacity.value = c2.opacity);
        void 0 !== h3.ltc_1 && (h3.ltc_1.value = F.LTC_1);
        void 0 !== h3.ltc_2 && (h3.ltc_2.value = F.LTC_2);
        Fb.upload(H, g2.uniformsList, h3, U2);
        c2.isShaderMaterial && (c2.uniformsNeedUpdate = false);
      }
      c2.isShaderMaterial && true === c2.uniformsNeedUpdate && (Fb.upload(H, g2.uniformsList, h3, U2), c2.uniformsNeedUpdate = false);
      c2.isSpriteMaterial && k2.setValue(H, "center", d2.center);
      0 < b2.numMultiviewViews ? va2.updateObjectMatricesUniforms(d2, a2, k2) : (k2.setValue(H, "modelViewMatrix", d2.modelViewMatrix), k2.setValue(H, "normalMatrix", d2.normalMatrix));
      k2.setValue(H, "modelMatrix", d2.matrixWorld);
      return b2;
    }
    function t(a2, b2, c2) {
      a2.opacity.value = b2.opacity;
      b2.color && a2.diffuse.value.copy(b2.color);
      b2.emissive && a2.emissive.value.copy(b2.emissive).multiplyScalar(b2.emissiveIntensity);
      b2.map && (a2.map.value = b2.map);
      b2.alphaMap && (a2.alphaMap.value = b2.alphaMap);
      b2.specularMap && (a2.specularMap.value = b2.specularMap);
      if (c2 = b2.envMap || c2) a2.envMap.value = c2, a2.flipEnvMap.value = c2.isCubeTexture ? -1 : 1, a2.reflectivity.value = b2.reflectivity, a2.refractionRatio.value = b2.refractionRatio, a2.maxMipLevel.value = S2.get(c2).__maxMipLevel;
      b2.lightMap && (a2.lightMap.value = b2.lightMap, a2.lightMapIntensity.value = b2.lightMapIntensity);
      b2.aoMap && (a2.aoMap.value = b2.aoMap, a2.aoMapIntensity.value = b2.aoMapIntensity);
      if (b2.map) var d2 = b2.map;
      else b2.specularMap ? d2 = b2.specularMap : b2.displacementMap ? d2 = b2.displacementMap : b2.normalMap ? d2 = b2.normalMap : b2.bumpMap ? d2 = b2.bumpMap : b2.roughnessMap ? d2 = b2.roughnessMap : b2.metalnessMap ? d2 = b2.metalnessMap : b2.alphaMap ? d2 = b2.alphaMap : b2.emissiveMap && (d2 = b2.emissiveMap);
      void 0 !== d2 && (d2.isWebGLRenderTarget && (d2 = d2.texture), true === d2.matrixAutoUpdate && d2.updateMatrix(), a2.uvTransform.value.copy(d2.matrix));
      if (b2.aoMap) var e2 = b2.aoMap;
      else b2.lightMap && (e2 = b2.lightMap);
      void 0 !== e2 && (e2.isWebGLRenderTarget && (e2 = e2.texture), true === e2.matrixAutoUpdate && e2.updateMatrix(), a2.uv2Transform.value.copy(e2.matrix));
    }
    function r(a2, b2, c2) {
      a2.roughness.value = b2.roughness;
      a2.metalness.value = b2.metalness;
      b2.roughnessMap && (a2.roughnessMap.value = b2.roughnessMap);
      b2.metalnessMap && (a2.metalnessMap.value = b2.metalnessMap);
      b2.emissiveMap && (a2.emissiveMap.value = b2.emissiveMap);
      b2.bumpMap && (a2.bumpMap.value = b2.bumpMap, a2.bumpScale.value = b2.bumpScale, 1 === b2.side && (a2.bumpScale.value *= -1));
      b2.normalMap && (a2.normalMap.value = b2.normalMap, a2.normalScale.value.copy(b2.normalScale), 1 === b2.side && a2.normalScale.value.negate());
      b2.displacementMap && (a2.displacementMap.value = b2.displacementMap, a2.displacementScale.value = b2.displacementScale, a2.displacementBias.value = b2.displacementBias);
      if (b2.envMap || c2) a2.envMapIntensity.value = b2.envMapIntensity;
    }
    a = a || {};
    var u = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), y = void 0 !== a.context ? a.context : null, v = void 0 !== a.alpha ? a.alpha : false, C = void 0 !== a.depth ? a.depth : true, W = void 0 !== a.stencil ? a.stencil : true, ja = void 0 !== a.antialias ? a.antialias : false, z = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : true, ra = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : false, D2 = void 0 !== a.powerPreference ? a.powerPreference : "default", E2 = void 0 !== a.failIfMajorPerformanceCaveat ? a.failIfMajorPerformanceCaveat : false, B2 = null, G = null;
    this.domElement = u;
    this.debug = { checkShaderErrors: true };
    this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2;
    this.outputEncoding = 3e3;
    this.physicallyCorrectLights = false;
    this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    var A2 = this, I2 = false, K2 = null, L2 = 0, M2 = 0, N2 = null, V2 = null, Pe = -1;
    var ha = b = null;
    var xa = false;
    var Z2 = null, T2 = null, X = new ia(), Y2 = new ia(), ba2 = null, ca2 = u.width, J = u.height, Q = 1, ka2 = null, ma2 = null, ea2 = new ia(0, 0, ca2, J), R2 = new ia(0, 0, ca2, J), lg = false, mg = new Hc(), Va = new yj(), na2 = false, ng = false, Od = new O(), Ib = new n();
    try {
      v = { alpha: v, depth: C, stencil: W, antialias: ja, premultipliedAlpha: z, preserveDrawingBuffer: ra, powerPreference: D2, failIfMajorPerformanceCaveat: E2, xrCompatible: true };
      u.addEventListener("webglcontextlost", d, false);
      u.addEventListener("webglcontextrestored", e, false);
      var H = y || u.getContext("webgl", v) || u.getContext("experimental-webgl", v);
      if (null === H) {
        if (null !== u.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
        throw Error("Error creating WebGL context.");
      }
      void 0 === H.getShaderPrecisionFormat && (H.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch ($h) {
      throw console.error("THREE.WebGLRenderer: " + $h.message), $h;
    }
    var sa, Ia, aa, da2, S2, U2, oa2, za2, ta2, ua2, ya2, wa2, pa2, Aa2, Ba2, Da2, qa2;
    c();
    var la2 = new Zh(A2, H);
    this.xr = la2;
    var va2 = new Jk(A2, H), Fa2 = new Wh(A2, ta2, Ia.maxTextureSize);
    this.shadowMap = Fa2;
    this.getContext = function() {
      return H;
    };
    this.getContextAttributes = function() {
      return H.getContextAttributes();
    };
    this.forceContextLoss = function() {
      var a2 = sa.get("WEBGL_lose_context");
      a2 && a2.loseContext();
    };
    this.forceContextRestore = function() {
      var a2 = sa.get("WEBGL_lose_context");
      a2 && a2.restoreContext();
    };
    this.getPixelRatio = function() {
      return Q;
    };
    this.setPixelRatio = function(a2) {
      void 0 !== a2 && (Q = a2, this.setSize(ca2, J, false));
    };
    this.getSize = function(a2) {
      void 0 === a2 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), a2 = new w());
      return a2.set(ca2, J);
    };
    this.setSize = function(a2, b2, c2) {
      la2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (ca2 = a2, J = b2, u.width = Math.floor(a2 * Q), u.height = Math.floor(b2 * Q), false !== c2 && (u.style.width = a2 + "px", u.style.height = b2 + "px"), this.setViewport(0, 0, a2, b2));
    };
    this.getDrawingBufferSize = function(a2) {
      void 0 === a2 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), a2 = new w());
      return a2.set(ca2 * Q, J * Q).floor();
    };
    this.setDrawingBufferSize = function(a2, b2, c2) {
      ca2 = a2;
      J = b2;
      Q = c2;
      u.width = Math.floor(a2 * c2);
      u.height = Math.floor(b2 * c2);
      this.setViewport(0, 0, a2, b2);
    };
    this.getCurrentViewport = function(a2) {
      void 0 === a2 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), a2 = new ia());
      return a2.copy(X);
    };
    this.getViewport = function(a2) {
      return a2.copy(ea2);
    };
    this.setViewport = function(a2, b2, c2, d2) {
      a2.isVector4 ? ea2.set(a2.x, a2.y, a2.z, a2.w) : ea2.set(a2, b2, c2, d2);
      aa.viewport(X.copy(ea2).multiplyScalar(Q).floor());
    };
    this.getScissor = function(a2) {
      return a2.copy(R2);
    };
    this.setScissor = function(a2, b2, c2, d2) {
      a2.isVector4 ? R2.set(a2.x, a2.y, a2.z, a2.w) : R2.set(a2, b2, c2, d2);
      aa.scissor(Y2.copy(R2).multiplyScalar(Q).floor());
    };
    this.getScissorTest = function() {
      return lg;
    };
    this.setScissorTest = function(a2) {
      aa.setScissorTest(lg = a2);
    };
    this.setOpaqueSort = function(a2) {
      ka2 = a2;
    };
    this.setTransparentSort = function(a2) {
      ma2 = a2;
    };
    this.getClearColor = function() {
      return pa2.getClearColor();
    };
    this.setClearColor = function() {
      pa2.setClearColor.apply(pa2, arguments);
    };
    this.getClearAlpha = function() {
      return pa2.getClearAlpha();
    };
    this.setClearAlpha = function() {
      pa2.setClearAlpha.apply(pa2, arguments);
    };
    this.clear = function(a2, b2, c2) {
      var d2 = 0;
      if (void 0 === a2 || a2) d2 |= 16384;
      if (void 0 === b2 || b2) d2 |= 256;
      if (void 0 === c2 || c2) d2 |= 1024;
      H.clear(d2);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      u.removeEventListener("webglcontextlost", d, false);
      u.removeEventListener("webglcontextrestored", e, false);
      ya2.dispose();
      wa2.dispose();
      S2.dispose();
      ta2.dispose();
      la2.dispose();
      Ca2.stop();
    };
    this.renderBufferImmediate = function(a2, b2) {
      aa.initAttributes();
      var c2 = S2.get(a2);
      a2.hasPositions && !c2.position && (c2.position = H.createBuffer());
      a2.hasNormals && !c2.normal && (c2.normal = H.createBuffer());
      a2.hasUvs && !c2.uv && (c2.uv = H.createBuffer());
      a2.hasColors && !c2.color && (c2.color = H.createBuffer());
      b2 = b2.getAttributes();
      a2.hasPositions && (H.bindBuffer(34962, c2.position), H.bufferData(34962, a2.positionArray, 35048), aa.enableAttribute(b2.position), H.vertexAttribPointer(b2.position, 3, 5126, false, 0, 0));
      a2.hasNormals && (H.bindBuffer(34962, c2.normal), H.bufferData(34962, a2.normalArray, 35048), aa.enableAttribute(b2.normal), H.vertexAttribPointer(b2.normal, 3, 5126, false, 0, 0));
      a2.hasUvs && (H.bindBuffer(34962, c2.uv), H.bufferData(34962, a2.uvArray, 35048), aa.enableAttribute(b2.uv), H.vertexAttribPointer(b2.uv, 2, 5126, false, 0, 0));
      a2.hasColors && (H.bindBuffer(34962, c2.color), H.bufferData(
        34962,
        a2.colorArray,
        35048
      ), aa.enableAttribute(b2.color), H.vertexAttribPointer(b2.color, 3, 5126, false, 0, 0));
      aa.disableUnusedAttributes();
      H.drawArrays(4, 0, a2.count);
      a2.count = 0;
    };
    var Ja2 = new pb();
    this.renderBufferDirect = function(a2, c2, d2, e2, f2, g2) {
      null === c2 && (c2 = Ja2);
      var k2 = f2.isMesh && 0 > f2.matrixWorld.determinant(), l2 = h2(a2, c2, e2, f2);
      aa.setMaterial(e2, k2);
      var m2 = false;
      if (b !== d2.id || ha !== l2.id || xa !== (true === e2.wireframe)) b = d2.id, ha = l2.id, xa = true === e2.wireframe, m2 = true;
      if (e2.morphTargets || e2.morphNormals) Aa2.update(f2, d2, e2, l2), m2 = true;
      a2 = d2.index;
      c2 = d2.attributes.position;
      if (null === a2) {
        if (void 0 === c2 || 0 === c2.count) return;
      } else if (0 === a2.count) return;
      var p2 = 1;
      true === e2.wireframe && (a2 = za2.getWireframeAttribute(d2), p2 = 2);
      k2 = Ba2;
      if (null !== a2) {
        var x2 = oa2.get(a2);
        k2 = Da2;
        k2.setIndex(x2);
      }
      if (m2) {
        if (false !== Ia.isWebGL2 || !f2.isInstancedMesh && !d2.isInstancedBufferGeometry || null !== sa.get("ANGLE_instanced_arrays")) {
          aa.initAttributes();
          m2 = d2.attributes;
          l2 = l2.getAttributes();
          var q = e2.defaultAttributeValues;
          for (W2 in l2) {
            var r2 = l2[W2];
            if (0 <= r2) {
              var t2 = m2[W2];
              if (void 0 !== t2) {
                var n2 = t2.normalized, u2 = t2.itemSize, v2 = oa2.get(t2);
                if (void 0 !== v2) {
                  var y2 = v2.buffer, z2 = v2.type;
                  v2 = v2.bytesPerElement;
                  if (t2.isInterleavedBufferAttribute) {
                    var C2 = t2.data, w2 = C2.stride;
                    t2 = t2.offset;
                    C2 && C2.isInstancedInterleavedBuffer ? (aa.enableAttributeAndDivisor(r2, C2.meshPerAttribute), void 0 === d2.maxInstancedCount && (d2.maxInstancedCount = C2.meshPerAttribute * C2.count)) : aa.enableAttribute(r2);
                    H.bindBuffer(34962, y2);
                    H.vertexAttribPointer(r2, u2, z2, n2, w2 * v2, t2 * v2);
                  } else t2.isInstancedBufferAttribute ? (aa.enableAttributeAndDivisor(r2, t2.meshPerAttribute), void 0 === d2.maxInstancedCount && (d2.maxInstancedCount = t2.meshPerAttribute * t2.count)) : aa.enableAttribute(r2), H.bindBuffer(34962, y2), H.vertexAttribPointer(r2, u2, z2, n2, 0, 0);
                }
              } else if ("instanceMatrix" === W2) v2 = oa2.get(f2.instanceMatrix), void 0 !== v2 && (y2 = v2.buffer, z2 = v2.type, aa.enableAttributeAndDivisor(r2 + 0, 1), aa.enableAttributeAndDivisor(r2 + 1, 1), aa.enableAttributeAndDivisor(r2 + 2, 1), aa.enableAttributeAndDivisor(r2 + 3, 1), H.bindBuffer(34962, y2), H.vertexAttribPointer(r2 + 0, 4, z2, false, 64, 0), H.vertexAttribPointer(r2 + 1, 4, z2, false, 64, 16), H.vertexAttribPointer(r2 + 2, 4, z2, false, 64, 32), H.vertexAttribPointer(r2 + 3, 4, z2, false, 64, 48));
              else if (void 0 !== q && (n2 = q[W2], void 0 !== n2)) switch (n2.length) {
                case 2:
                  H.vertexAttrib2fv(r2, n2);
                  break;
                case 3:
                  H.vertexAttrib3fv(r2, n2);
                  break;
                case 4:
                  H.vertexAttrib4fv(r2, n2);
                  break;
                default:
                  H.vertexAttrib1fv(r2, n2);
              }
            }
          }
          aa.disableUnusedAttributes();
        }
        null !== a2 && H.bindBuffer(34963, x2.buffer);
      }
      var W2 = d2.drawRange.start * p2;
      m2 = null !== g2 ? g2.start * p2 : 0;
      x2 = Math.max(W2, m2);
      g2 = Math.max(0, Math.min(null !== a2 ? a2.count : c2.count, W2 + d2.drawRange.count * p2, m2 + (null !== g2 ? g2.count * p2 : Infinity)) - 1 - x2 + 1);
      0 !== g2 && (f2.isMesh ? true === e2.wireframe ? (aa.setLineWidth(e2.wireframeLinewidth * (null === N2 ? Q : 1)), k2.setMode(1)) : k2.setMode(4) : f2.isLine ? (e2 = e2.linewidth, void 0 === e2 && (e2 = 1), aa.setLineWidth(e2 * (null === N2 ? Q : 1)), f2.isLineSegments ? k2.setMode(1) : f2.isLineLoop ? k2.setMode(2) : k2.setMode(3)) : f2.isPoints ? k2.setMode(0) : f2.isSprite && k2.setMode(4), f2.isInstancedMesh ? k2.renderInstances(d2, x2, g2, f2.count) : d2.isInstancedBufferGeometry ? k2.renderInstances(d2, x2, g2, d2.maxInstancedCount) : k2.render(x2, g2));
    };
    this.compile = function(a2, b2) {
      G = wa2.get(a2, b2);
      G.init();
      a2.traverse(function(a3) {
        a3.isLight && (G.pushLight(a3), a3.castShadow && G.pushShadow(a3));
      });
      G.setupLights(b2);
      var c2 = {};
      a2.traverse(function(b3) {
        if (b3.material) if (Array.isArray(b3.material)) for (var d2 = 0; d2 < b3.material.length; d2++) false === b3.material[d2].uuid in c2 && (p(b3.material[d2], a2, b3), c2[b3.material[d2].uuid] = true);
        else false === b3.material.uuid in c2 && (p(b3.material, a2, b3), c2[b3.material.uuid] = true);
      });
    };
    var Ea2 = null, Ca2 = new Ah();
    Ca2.setAnimationLoop(function(a2) {
      la2.isPresenting || Ea2 && Ea2(a2);
    });
    "undefined" !== typeof window && Ca2.setContext(window);
    this.setAnimationLoop = function(a2) {
      Ea2 = a2;
      la2.setAnimationLoop(a2);
      Ca2.start();
    };
    this.render = function(a2, c2, d2, e2) {
      if (void 0 !== d2) {
        console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
        var f2 = d2;
      }
      if (void 0 !== e2) {
        console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
        var g2 = e2;
      }
      c2 && c2.isCamera ? I2 || (ha = b = null, xa = false, Pe = -1, Z2 = null, true === a2.autoUpdate && a2.updateMatrixWorld(), null === c2.parent && c2.updateMatrixWorld(), la2.enabled && la2.isPresenting && (c2 = la2.getCamera(c2)), G = wa2.get(a2, c2), G.init(), a2.onBeforeRender(
        A2,
        a2,
        c2,
        f2 || N2
      ), Od.multiplyMatrices(c2.projectionMatrix, c2.matrixWorldInverse), mg.setFromProjectionMatrix(Od), ng = this.localClippingEnabled, na2 = Va.init(this.clippingPlanes, ng, c2), B2 = ya2.get(a2, c2), B2.init(), l(a2, c2, 0, A2.sortObjects), true === A2.sortObjects && B2.sort(ka2, ma2), na2 && Va.beginShadows(), Fa2.render(G.state.shadowsArray, a2, c2), G.setupLights(c2), na2 && Va.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== f2 && this.setRenderTarget(f2), la2.enabled && va2.isAvailable() && va2.attachCamera(c2), pa2.render(B2, a2, c2, g2), d2 = B2.opaque, e2 = B2.transparent, a2.overrideMaterial ? (f2 = a2.overrideMaterial, d2.length && m(d2, a2, c2, f2), e2.length && m(e2, a2, c2, f2)) : (d2.length && m(d2, a2, c2), e2.length && m(e2, a2, c2)), a2.onAfterRender(A2, a2, c2), null !== N2 && (U2.updateRenderTargetMipmap(N2), U2.updateMultisampleRenderTarget(N2)), aa.buffers.depth.setTest(true), aa.buffers.depth.setMask(true), aa.buffers.color.setMask(true), aa.setPolygonOffset(false), la2.enabled && va2.isAvailable() && va2.detachCamera(c2), G = B2 = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    };
    this.setFramebuffer = function(a2) {
      K2 !== a2 && null === N2 && H.bindFramebuffer(36160, a2);
      K2 = a2;
    };
    this.getActiveCubeFace = function() {
      return L2;
    };
    this.getActiveMipmapLevel = function() {
      return M2;
    };
    this.getRenderTarget = function() {
      return N2;
    };
    this.setRenderTarget = function(a2, b2, c2) {
      N2 = a2;
      L2 = b2;
      M2 = c2;
      a2 && void 0 === S2.get(a2).__webglFramebuffer && U2.setupRenderTarget(a2);
      var d2 = K2, e2 = false;
      a2 ? (d2 = S2.get(a2).__webglFramebuffer, a2.isWebGLCubeRenderTarget ? (d2 = d2[b2 || 0], e2 = true) : d2 = a2.isWebGLMultisampleRenderTarget ? S2.get(a2).__webglMultisampledFramebuffer : d2, X.copy(a2.viewport), Y2.copy(a2.scissor), ba2 = a2.scissorTest) : (X.copy(ea2).multiplyScalar(Q).floor(), Y2.copy(R2).multiplyScalar(Q).floor(), ba2 = lg);
      V2 !== d2 && (H.bindFramebuffer(36160, d2), V2 = d2);
      aa.viewport(X);
      aa.scissor(Y2);
      aa.setScissorTest(ba2);
      e2 && (a2 = S2.get(a2.texture), H.framebufferTexture2D(36160, 36064, 34069 + (b2 || 0), a2.__webglTexture, c2 || 0));
    };
    this.readRenderTargetPixels = function(a2, b2, c2, d2, e2, f2, g2) {
      if (a2 && a2.isWebGLRenderTarget) {
        var k2 = S2.get(a2).__webglFramebuffer;
        a2.isWebGLCubeRenderTarget && void 0 !== g2 && (k2 = k2[g2]);
        if (k2) {
          g2 = false;
          k2 !== V2 && (H.bindFramebuffer(36160, k2), g2 = true);
          try {
            var l2 = a2.texture, m2 = l2.format, h3 = l2.type;
            1023 !== m2 && qa2.convert(m2) !== H.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h3 || qa2.convert(h3) === H.getParameter(35738) || 1015 === h3 && (Ia.isWebGL2 || sa.get("OES_texture_float") || sa.get("WEBGL_color_buffer_float")) || 1016 === h3 && (Ia.isWebGL2 ? sa.get("EXT_color_buffer_float") : sa.get("EXT_color_buffer_half_float")) ? 36053 === H.checkFramebufferStatus(36160) ? 0 <= b2 && b2 <= a2.width - d2 && 0 <= c2 && c2 <= a2.height - e2 && H.readPixels(b2, c2, d2, e2, qa2.convert(m2), qa2.convert(h3), f2) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          } finally {
            g2 && H.bindFramebuffer(36160, V2);
          }
        }
      } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
    };
    this.copyFramebufferToTexture = function(a2, b2, c2) {
      void 0 === c2 && (c2 = 0);
      var d2 = Math.pow(2, -c2), e2 = Math.floor(b2.image.width * d2);
      d2 = Math.floor(b2.image.height * d2);
      var f2 = qa2.convert(b2.format);
      U2.setTexture2D(b2, 0);
      H.copyTexImage2D(3553, c2, f2, a2.x, a2.y, e2, d2, 0);
      aa.unbindTexture();
    };
    this.copyTextureToTexture = function(a2, b2, c2, d2) {
      var e2 = b2.image.width, f2 = b2.image.height, g2 = qa2.convert(c2.format), k2 = qa2.convert(c2.type);
      U2.setTexture2D(c2, 0);
      b2.isDataTexture ? H.texSubImage2D(3553, d2 || 0, a2.x, a2.y, e2, f2, g2, k2, b2.image.data) : H.texSubImage2D(3553, d2 || 0, a2.x, a2.y, g2, k2, b2.image);
      aa.unbindTexture();
    };
    this.initTexture = function(a2) {
      U2.setTexture2D(a2, 0);
      aa.unbindTexture();
    };
    "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  function Re(a, b) {
    this.name = "";
    this.color = new B(a);
    this.density = void 0 !== b ? b : 25e-5;
  }
  function Se(a, b, c) {
    this.name = "";
    this.color = new B(a);
    this.near = void 0 !== b ? b : 1;
    this.far = void 0 !== c ? c : 1e3;
  }
  function sb(a, b) {
    this.array = a;
    this.stride = b;
    this.count = void 0 !== a ? a.length / b : 0;
    this.usage = 35044;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  function Qd(a, b, c, d) {
    this.data = a;
    this.itemSize = b;
    this.offset = c;
    this.normalized = true === d;
  }
  function Jb(a) {
    K.call(this);
    this.type = "SpriteMaterial";
    this.color = new B(16777215);
    this.alphaMap = this.map = null;
    this.rotation = 0;
    this.transparent = this.sizeAttenuation = true;
    this.setValues(a);
  }
  function Rd(a) {
    D.call(this);
    this.type = "Sprite";
    if (void 0 === Nc) {
      Nc = new A();
      var b = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
      b = new sb(b, 5);
      Nc.setIndex([0, 1, 2, 0, 2, 3]);
      Nc.setAttribute(
        "position",
        new Qd(b, 3, 0, false)
      );
      Nc.setAttribute("uv", new Qd(b, 2, 3, false));
    }
    this.geometry = Nc;
    this.material = void 0 !== a ? a : new Jb();
    this.center = new w(0.5, 0.5);
  }
  function Te(a, b, c, d, e, f) {
    Oc.subVectors(a, c).addScalar(0.5).multiply(d);
    void 0 !== e ? (Sd.x = f * Oc.x - e * Oc.y, Sd.y = e * Oc.x + f * Oc.y) : Sd.copy(Oc);
    a.copy(b);
    a.x += Sd.x;
    a.y += Sd.y;
    a.applyMatrix4(ai);
  }
  function Td() {
    D.call(this);
    this.type = "LOD";
    Object.defineProperties(this, { levels: { enumerable: true, value: [] } });
    this.autoUpdate = true;
  }
  function Ud(a, b) {
    a && a.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    ca.call(this, a, b);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new O();
    this.bindMatrixInverse = new O();
  }
  function Ue(a, b) {
    a = a || [];
    this.bones = a.slice(0);
    this.boneMatrices = new Float32Array(16 * this.bones.length);
    this.frame = -1;
    if (void 0 === b) this.calculateInverses();
    else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
    else for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], a = 0, b = this.bones.length; a < b; a++) this.boneInverses.push(new O());
  }
  function rg() {
    D.call(this);
    this.type = "Bone";
  }
  function Ve(a, b, c) {
    ca.call(this, a, b);
    this.instanceMatrix = new M(new Float32Array(16 * c), 16);
    this.count = c;
    this.frustumCulled = false;
  }
  function ka(a) {
    K.call(this);
    this.type = "LineBasicMaterial";
    this.color = new B(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.setValues(a);
  }
  function La(a, b, c) {
    1 === c && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
    D.call(this);
    this.type = "Line";
    this.geometry = void 0 !== a ? a : new A();
    this.material = void 0 !== b ? b : new ka();
  }
  function ma(a, b) {
    La.call(this, a, b);
    this.type = "LineSegments";
  }
  function We(a, b) {
    La.call(this, a, b);
    this.type = "LineLoop";
  }
  function Wa(a) {
    K.call(this);
    this.type = "PointsMaterial";
    this.color = new B(16777215);
    this.alphaMap = this.map = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(a);
  }
  function Pc(a, b) {
    D.call(this);
    this.type = "Points";
    this.geometry = void 0 !== a ? a : new A();
    this.material = void 0 !== b ? b : new Wa();
    this.updateMorphTargets();
  }
  function sg(a, b, c, d, e, f, g) {
    var k = tg.distanceSqToPoint(a);
    k < c && (c = new n(), tg.closestPointToPoint(a, c), c.applyMatrix4(d), a = e.ray.origin.distanceTo(c), a < e.near || a > e.far || f.push({ distance: a, distanceToRay: Math.sqrt(k), point: c, index: b, face: null, object: g }));
  }
  function ug(a, b, c, d, e, f, g, k, l) {
    Z.call(this, a, b, c, d, e, f, g, k, l);
    this.format = void 0 !== g ? g : 1022;
    this.minFilter = void 0 !== f ? f : 1006;
    this.magFilter = void 0 !== e ? e : 1006;
    this.generateMipmaps = false;
  }
  function Qc(a, b, c, d, e, f, g, k, l, m, h2, p) {
    Z.call(this, null, f, g, k, l, m, d, e, h2, p);
    this.image = { width: b, height: c };
    this.mipmaps = a;
    this.generateMipmaps = this.flipY = false;
  }
  function Vd(a, b, c, d, e, f, g, k, l) {
    Z.call(this, a, b, c, d, e, f, g, k, l);
    this.needsUpdate = true;
  }
  function Wd(a, b, c, d, e, f, g, k, l, m) {
    m = void 0 !== m ? m : 1026;
    if (1026 !== m && 1027 !== m) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    void 0 === c && 1026 === m && (c = 1012);
    void 0 === c && 1027 === m && (c = 1020);
    Z.call(this, null, d, e, f, g, k, m, c, l);
    this.image = { width: a, height: b };
    this.magFilter = void 0 !== g ? g : 1003;
    this.minFilter = void 0 !== k ? k : 1003;
    this.generateMipmaps = this.flipY = false;
  }
  function Rc(a) {
    A.call(this);
    this.type = "WireframeGeometry";
    var b = [], c, d, e, f = [0, 0], g = {}, k = ["a", "b", "c"];
    if (a && a.isGeometry) {
      var l = a.faces;
      var m = 0;
      for (d = l.length; m < d; m++) {
        var h2 = l[m];
        for (c = 0; 3 > c; c++) {
          var p = h2[k[c]];
          var q = h2[k[(c + 1) % 3]];
          f[0] = Math.min(p, q);
          f[1] = Math.max(p, q);
          p = f[0] + "," + f[1];
          void 0 === g[p] && (g[p] = { index1: f[0], index2: f[1] });
        }
      }
      for (p in g) m = g[p], k = a.vertices[m.index1], b.push(k.x, k.y, k.z), k = a.vertices[m.index2], b.push(k.x, k.y, k.z);
    } else if (a && a.isBufferGeometry) if (k = new n(), null !== a.index) {
      l = a.attributes.position;
      h2 = a.index;
      var t = a.groups;
      0 === t.length && (t = [{ start: 0, count: h2.count, materialIndex: 0 }]);
      a = 0;
      for (e = t.length; a < e; ++a) for (m = t[a], c = m.start, d = m.count, m = c, d = c + d; m < d; m += 3) for (c = 0; 3 > c; c++) p = h2.getX(m + c), q = h2.getX(m + (c + 1) % 3), f[0] = Math.min(p, q), f[1] = Math.max(p, q), p = f[0] + "," + f[1], void 0 === g[p] && (g[p] = { index1: f[0], index2: f[1] });
      for (p in g) m = g[p], k.fromBufferAttribute(l, m.index1), b.push(k.x, k.y, k.z), k.fromBufferAttribute(l, m.index2), b.push(k.x, k.y, k.z);
    } else for (l = a.attributes.position, m = 0, d = l.count / 3; m < d; m++) for (c = 0; 3 > c; c++) g = 3 * m + c, k.fromBufferAttribute(l, g), b.push(k.x, k.y, k.z), g = 3 * m + (c + 1) % 3, k.fromBufferAttribute(l, g), b.push(k.x, k.y, k.z);
    this.setAttribute("position", new E(b, 3));
  }
  function Xd(a, b, c) {
    L.call(this);
    this.type = "ParametricGeometry";
    this.parameters = { func: a, slices: b, stacks: c };
    this.fromBufferGeometry(new Sc(a, b, c));
    this.mergeVertices();
  }
  function Sc(a, b, c) {
    A.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = { func: a, slices: b, stacks: c };
    var d = [], e = [], f = [], g = [], k = new n(), l = new n(), m = new n(), h2 = new n(), p = new n(), q, t;
    3 > a.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    var r = b + 1;
    for (q = 0; q <= c; q++) {
      var u = q / c;
      for (t = 0; t <= b; t++) {
        var y = t / b;
        a(y, u, l);
        e.push(l.x, l.y, l.z);
        0 <= y - 1e-5 ? (a(y - 1e-5, u, m), h2.subVectors(l, m)) : (a(y + 1e-5, u, m), h2.subVectors(m, l));
        0 <= u - 1e-5 ? (a(y, u - 1e-5, m), p.subVectors(l, m)) : (a(y, u + 1e-5, m), p.subVectors(m, l));
        k.crossVectors(h2, p).normalize();
        f.push(k.x, k.y, k.z);
        g.push(y, u);
      }
    }
    for (q = 0; q < c; q++) for (t = 0; t < b; t++) a = q * r + t + 1, k = (q + 1) * r + t + 1, l = (q + 1) * r + t, d.push(q * r + t, a, l), d.push(a, k, l);
    this.setIndex(d);
    this.setAttribute("position", new E(e, 3));
    this.setAttribute("normal", new E(f, 3));
    this.setAttribute("uv", new E(g, 2));
  }
  function Yd(a, b, c, d) {
    L.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = { vertices: a, indices: b, radius: c, detail: d };
    this.fromBufferGeometry(new Ja(a, b, c, d));
    this.mergeVertices();
  }
  function Ja(a, b, c, d) {
    function e(a2) {
      k.push(a2.x, a2.y, a2.z);
    }
    function f(b2, c2) {
      b2 *= 3;
      c2.x = a[b2 + 0];
      c2.y = a[b2 + 1];
      c2.z = a[b2 + 2];
    }
    function g(a2, b2, c2, d2) {
      0 > d2 && 1 === a2.x && (l[b2] = a2.x - 1);
      0 === c2.x && 0 === c2.z && (l[b2] = d2 / 2 / Math.PI + 0.5);
    }
    A.call(this);
    this.type = "PolyhedronBufferGeometry";
    this.parameters = { vertices: a, indices: b, radius: c, detail: d };
    c = c || 1;
    d = d || 0;
    var k = [], l = [];
    (function(a2) {
      for (var c2 = new n(), d2 = new n(), g2 = new n(), k2 = 0; k2 < b.length; k2 += 3) {
        f(b[k2 + 0], c2);
        f(b[k2 + 1], d2);
        f(b[k2 + 2], g2);
        var l2, m, h2 = c2, v = d2, C = g2, w2 = Math.pow(2, a2), ja = [];
        for (m = 0; m <= w2; m++) {
          ja[m] = [];
          var z = h2.clone().lerp(C, m / w2), A2 = v.clone().lerp(C, m / w2), B2 = w2 - m;
          for (l2 = 0; l2 <= B2; l2++) ja[m][l2] = 0 === l2 && m === w2 ? z : z.clone().lerp(A2, l2 / B2);
        }
        for (m = 0; m < w2; m++) for (l2 = 0; l2 < 2 * (w2 - m) - 1; l2++) h2 = Math.floor(l2 / 2), 0 === l2 % 2 ? (e(ja[m][h2 + 1]), e(ja[m + 1][h2]), e(ja[m][h2])) : (e(ja[m][h2 + 1]), e(ja[m + 1][h2 + 1]), e(ja[m + 1][h2]));
      }
    })(d);
    (function(a2) {
      for (var b2 = new n(), c2 = 0; c2 < k.length; c2 += 3) b2.x = k[c2 + 0], b2.y = k[c2 + 1], b2.z = k[c2 + 2], b2.normalize().multiplyScalar(a2), k[c2 + 0] = b2.x, k[c2 + 1] = b2.y, k[c2 + 2] = b2.z;
    })(c);
    (function() {
      for (var a2 = new n(), b2 = 0; b2 < k.length; b2 += 3) a2.x = k[b2 + 0], a2.y = k[b2 + 1], a2.z = k[b2 + 2], l.push(Math.atan2(a2.z, -a2.x) / 2 / Math.PI + 0.5, 1 - (Math.atan2(-a2.y, Math.sqrt(a2.x * a2.x + a2.z * a2.z)) / Math.PI + 0.5));
      a2 = new n();
      b2 = new n();
      for (var c2 = new n(), d2 = new n(), e2 = new w(), f2 = new w(), h2 = new w(), y = 0, v = 0; y < k.length; y += 9, v += 6) {
        a2.set(k[y + 0], k[y + 1], k[y + 2]);
        b2.set(k[y + 3], k[y + 4], k[y + 5]);
        c2.set(k[y + 6], k[y + 7], k[y + 8]);
        e2.set(l[v + 0], l[v + 1]);
        f2.set(l[v + 2], l[v + 3]);
        h2.set(l[v + 4], l[v + 5]);
        d2.copy(a2).add(b2).add(c2).divideScalar(3);
        var C = Math.atan2(d2.z, -d2.x);
        g(e2, v + 0, a2, C);
        g(f2, v + 2, b2, C);
        g(h2, v + 4, c2, C);
      }
      for (a2 = 0; a2 < l.length; a2 += 6) b2 = l[a2 + 0], c2 = l[a2 + 2], d2 = l[a2 + 4], e2 = Math.min(b2, c2, d2), 0.9 < Math.max(b2, c2, d2) && 0.1 > e2 && (0.2 > b2 && (l[a2 + 0] += 1), 0.2 > c2 && (l[a2 + 2] += 1), 0.2 > d2 && (l[a2 + 4] += 1));
    })();
    this.setAttribute("position", new E(k, 3));
    this.setAttribute(
      "normal",
      new E(k.slice(), 3)
    );
    this.setAttribute("uv", new E(l, 2));
    0 === d ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function Zd(a, b) {
    L.call(this);
    this.type = "TetrahedronGeometry";
    this.parameters = { radius: a, detail: b };
    this.fromBufferGeometry(new Tc(a, b));
    this.mergeVertices();
  }
  function Tc(a, b) {
    Ja.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
    this.type = "TetrahedronBufferGeometry";
    this.parameters = { radius: a, detail: b };
  }
  function $d(a, b) {
    L.call(this);
    this.type = "OctahedronGeometry";
    this.parameters = { radius: a, detail: b };
    this.fromBufferGeometry(new dc(a, b));
    this.mergeVertices();
  }
  function dc(a, b) {
    Ja.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
    this.type = "OctahedronBufferGeometry";
    this.parameters = { radius: a, detail: b };
  }
  function ae(a, b) {
    L.call(this);
    this.type = "IcosahedronGeometry";
    this.parameters = { radius: a, detail: b };
    this.fromBufferGeometry(new Uc(a, b));
    this.mergeVertices();
  }
  function Uc(a, b) {
    var c = (1 + Math.sqrt(5)) / 2;
    Ja.call(this, [
      -1,
      c,
      0,
      1,
      c,
      0,
      -1,
      -c,
      0,
      1,
      -c,
      0,
      0,
      -1,
      c,
      0,
      1,
      c,
      0,
      -1,
      -c,
      0,
      1,
      -c,
      c,
      0,
      -1,
      c,
      0,
      1,
      -c,
      0,
      -1,
      -c,
      0,
      1
    ], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);
    this.type = "IcosahedronBufferGeometry";
    this.parameters = { radius: a, detail: b };
  }
  function be(a, b) {
    L.call(this);
    this.type = "DodecahedronGeometry";
    this.parameters = { radius: a, detail: b };
    this.fromBufferGeometry(new Vc(a, b));
    this.mergeVertices();
  }
  function Vc(a, b) {
    var c = (1 + Math.sqrt(5)) / 2, d = 1 / c;
    Ja.call(
      this,
      [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d],
      [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9],
      a,
      b
    );
    this.type = "DodecahedronBufferGeometry";
    this.parameters = { radius: a, detail: b };
  }
  function ce(a, b, c, d, e, f) {
    L.call(this);
    this.type = "TubeGeometry";
    this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e };
    void 0 !== f && console.warn("THREE.TubeGeometry: taper has been removed.");
    a = new ec(a, b, c, d, e);
    this.tangents = a.tangents;
    this.normals = a.normals;
    this.binormals = a.binormals;
    this.fromBufferGeometry(a);
    this.mergeVertices();
  }
  function ec(a, b, c, d, e) {
    function f(e2) {
      h2 = a.getPointAt(e2 / b, h2);
      var f2 = g.normals[e2];
      e2 = g.binormals[e2];
      for (q = 0; q <= d; q++) {
        var m2 = q / d * Math.PI * 2, p2 = Math.sin(m2);
        m2 = -Math.cos(m2);
        l.x = m2 * f2.x + p2 * e2.x;
        l.y = m2 * f2.y + p2 * e2.y;
        l.z = m2 * f2.z + p2 * e2.z;
        l.normalize();
        r.push(l.x, l.y, l.z);
        k.x = h2.x + c * l.x;
        k.y = h2.y + c * l.y;
        k.z = h2.z + c * l.z;
        t.push(k.x, k.y, k.z);
      }
    }
    A.call(this);
    this.type = "TubeBufferGeometry";
    this.parameters = { path: a, tubularSegments: b, radius: c, radialSegments: d, closed: e };
    b = b || 64;
    c = c || 1;
    d = d || 8;
    e = e || false;
    var g = a.computeFrenetFrames(b, e);
    this.tangents = g.tangents;
    this.normals = g.normals;
    this.binormals = g.binormals;
    var k = new n(), l = new n(), m = new w(), h2 = new n(), p, q, t = [], r = [], u = [], y = [];
    for (p = 0; p < b; p++) f(p);
    f(false === e ? b : 0);
    for (p = 0; p <= b; p++) for (q = 0; q <= d; q++) m.x = p / b, m.y = q / d, u.push(m.x, m.y);
    (function() {
      for (q = 1; q <= b; q++) for (p = 1; p <= d; p++) {
        var a2 = (d + 1) * q + (p - 1), c2 = (d + 1) * q + p, e2 = (d + 1) * (q - 1) + p;
        y.push((d + 1) * (q - 1) + (p - 1), a2, e2);
        y.push(a2, c2, e2);
      }
    })();
    this.setIndex(y);
    this.setAttribute("position", new E(t, 3));
    this.setAttribute("normal", new E(r, 3));
    this.setAttribute("uv", new E(u, 2));
  }
  function de(a, b, c, d, e, f, g) {
    L.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f };
    void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
    this.fromBufferGeometry(new Wc(a, b, c, d, e, f));
    this.mergeVertices();
  }
  function Wc(a, b, c, d, e, f) {
    function g(a2, b2, c2, d2, e2) {
      var f2 = Math.sin(a2);
      b2 = c2 / b2 * a2;
      c2 = Math.cos(b2);
      e2.x = d2 * (2 + c2) * 0.5 * Math.cos(a2);
      e2.y = d2 * (2 + c2) * f2 * 0.5;
      e2.z = d2 * Math.sin(b2) * 0.5;
    }
    A.call(this);
    this.type = "TorusKnotBufferGeometry";
    this.parameters = { radius: a, tube: b, tubularSegments: c, radialSegments: d, p: e, q: f };
    a = a || 1;
    b = b || 0.4;
    c = Math.floor(c) || 64;
    d = Math.floor(d) || 8;
    e = e || 2;
    f = f || 3;
    var k = [], l = [], m = [], h2 = [], p, q = new n(), t = new n(), r = new n(), u = new n(), y = new n(), v = new n(), C = new n();
    for (p = 0; p <= c; ++p) {
      var w2 = p / c * e * Math.PI * 2;
      g(w2, e, f, a, r);
      g(w2 + 0.01, e, f, a, u);
      v.subVectors(u, r);
      C.addVectors(u, r);
      y.crossVectors(v, C);
      C.crossVectors(y, v);
      y.normalize();
      C.normalize();
      for (w2 = 0; w2 <= d; ++w2) {
        var ja = w2 / d * Math.PI * 2, z = -b * Math.cos(ja);
        ja = b * Math.sin(ja);
        q.x = r.x + (z * C.x + ja * y.x);
        q.y = r.y + (z * C.y + ja * y.y);
        q.z = r.z + (z * C.z + ja * y.z);
        l.push(q.x, q.y, q.z);
        t.subVectors(q, r).normalize();
        m.push(t.x, t.y, t.z);
        h2.push(p / c);
        h2.push(w2 / d);
      }
    }
    for (w2 = 1; w2 <= c; w2++) for (p = 1; p <= d; p++) a = (d + 1) * w2 + (p - 1), b = (d + 1) * w2 + p, e = (d + 1) * (w2 - 1) + p, k.push((d + 1) * (w2 - 1) + (p - 1), a, e), k.push(a, b, e);
    this.setIndex(k);
    this.setAttribute("position", new E(l, 3));
    this.setAttribute("normal", new E(m, 3));
    this.setAttribute("uv", new E(h2, 2));
  }
  function ee(a, b, c, d, e) {
    L.call(this);
    this.type = "TorusGeometry";
    this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e };
    this.fromBufferGeometry(new Xc(a, b, c, d, e));
    this.mergeVertices();
  }
  function Xc(a, b, c, d, e) {
    A.call(this);
    this.type = "TorusBufferGeometry";
    this.parameters = { radius: a, tube: b, radialSegments: c, tubularSegments: d, arc: e };
    a = a || 1;
    b = b || 0.4;
    c = Math.floor(c) || 8;
    d = Math.floor(d) || 6;
    e = e || 2 * Math.PI;
    var f = [], g = [], k = [], l = [], m = new n(), h2 = new n(), p = new n(), q, t;
    for (q = 0; q <= c; q++) for (t = 0; t <= d; t++) {
      var r = t / d * e, u = q / c * Math.PI * 2;
      h2.x = (a + b * Math.cos(u)) * Math.cos(r);
      h2.y = (a + b * Math.cos(u)) * Math.sin(r);
      h2.z = b * Math.sin(u);
      g.push(h2.x, h2.y, h2.z);
      m.x = a * Math.cos(r);
      m.y = a * Math.sin(r);
      p.subVectors(h2, m).normalize();
      k.push(p.x, p.y, p.z);
      l.push(t / d);
      l.push(q / c);
    }
    for (q = 1; q <= c; q++) for (t = 1; t <= d; t++) a = (d + 1) * (q - 1) + t - 1, b = (d + 1) * (q - 1) + t, e = (d + 1) * q + t, f.push((d + 1) * q + t - 1, a, e), f.push(
      a,
      b,
      e
    );
    this.setIndex(f);
    this.setAttribute("position", new E(g, 3));
    this.setAttribute("normal", new E(k, 3));
    this.setAttribute("uv", new E(l, 2));
  }
  function bi(a, b, c, d, e) {
    for (var f, g = 0, k = b, l = c - d; k < c; k += d) g += (a[l] - a[k]) * (a[k + 1] + a[l + 1]), l = k;
    if (e === 0 < g) for (e = b; e < c; e += d) f = ci(e, a[e], a[e + 1], f);
    else for (e = c - d; e >= b; e -= d) f = ci(e, a[e], a[e + 1], f);
    f && fc(f, f.next) && (fe(f), f = f.next);
    return f;
  }
  function ge(a, b) {
    if (!a) return a;
    b || (b = a);
    do {
      var c = false;
      if (a.steiner || !fc(a, a.next) && 0 !== ta(a.prev, a, a.next)) a = a.next;
      else {
        fe(a);
        a = b = a.prev;
        if (a === a.next) break;
        c = true;
      }
    } while (c || a !== b);
    return b;
  }
  function he(a, b, c, d, e, f, g) {
    if (a) {
      if (!g && f) {
        var k = a, l = k;
        do
          null === l.z && (l.z = vg(l.x, l.y, d, e, f)), l.prevZ = l.prev, l = l.nextZ = l.next;
        while (l !== k);
        l.prevZ.nextZ = null;
        l.prevZ = null;
        k = l;
        var m, h2, p, q, t = 1;
        do {
          l = k;
          var r = k = null;
          for (h2 = 0; l; ) {
            h2++;
            var n2 = l;
            for (m = p = 0; m < t && (p++, n2 = n2.nextZ, n2); m++) ;
            for (q = t; 0 < p || 0 < q && n2; ) 0 !== p && (0 === q || !n2 || l.z <= n2.z) ? (m = l, l = l.nextZ, p--) : (m = n2, n2 = n2.nextZ, q--), r ? r.nextZ = m : k = m, m.prevZ = r, r = m;
            l = n2;
          }
          r.nextZ = null;
          t *= 2;
        } while (1 < h2);
      }
      for (k = a; a.prev !== a.next; ) {
        l = a.prev;
        n2 = a.next;
        if (f) r = Kk(a, d, e, f);
        else a: if (r = a, h2 = r.prev, p = r, t = r.next, 0 <= ta(h2, p, t)) r = false;
        else {
          for (m = r.next.next; m !== r.prev; ) {
            if (Yc(h2.x, h2.y, p.x, p.y, t.x, t.y, m.x, m.y) && 0 <= ta(m.prev, m, m.next)) {
              r = false;
              break a;
            }
            m = m.next;
          }
          r = true;
        }
        if (r) b.push(l.i / c), b.push(a.i / c), b.push(n2.i / c), fe(a), k = a = n2.next;
        else if (a = n2, a === k) {
          if (!g) he(ge(a), b, c, d, e, f, 1);
          else if (1 === g) {
            g = b;
            k = c;
            l = a;
            do
              n2 = l.prev, r = l.next.next, !fc(n2, r) && di(n2, l, l.next, r) && ie(n2, r) && ie(r, n2) && (g.push(n2.i / k), g.push(l.i / k), g.push(r.i / k), fe(l), fe(l.next), l = a = r), l = l.next;
            while (l !== a);
            a = l;
            he(a, b, c, d, e, f, 2);
          } else if (2 === g) a: {
            g = a;
            do {
              for (k = g.next.next; k !== g.prev; ) {
                if (l = g.i !== k.i) {
                  l = g;
                  n2 = k;
                  if (r = l.next.i !== n2.i && l.prev.i !== n2.i) {
                    b: {
                      r = l;
                      do {
                        if (r.i !== l.i && r.next.i !== l.i && r.i !== n2.i && r.next.i !== n2.i && di(r, r.next, l, n2)) {
                          r = true;
                          break b;
                        }
                        r = r.next;
                      } while (r !== l);
                      r = false;
                    }
                    r = !r;
                  }
                  if (r = r && ie(l, n2) && ie(n2, l)) {
                    r = l;
                    h2 = false;
                    p = (l.x + n2.x) / 2;
                    n2 = (l.y + n2.y) / 2;
                    do
                      r.y > n2 !== r.next.y > n2 && r.next.y !== r.y && p < (r.next.x - r.x) * (n2 - r.y) / (r.next.y - r.y) + r.x && (h2 = !h2), r = r.next;
                    while (r !== l);
                    r = h2;
                  }
                  l = r;
                }
                if (l) {
                  a = ei(g, k);
                  g = ge(g, g.next);
                  a = ge(
                    a,
                    a.next
                  );
                  he(g, b, c, d, e, f);
                  he(a, b, c, d, e, f);
                  break a;
                }
                k = k.next;
              }
              g = g.next;
            } while (g !== a);
          }
          break;
        }
      }
    }
  }
  function Kk(a, b, c, d) {
    var e = a.prev, f = a.next;
    if (0 <= ta(e, a, f)) return false;
    var g = e.x > a.x ? e.x > f.x ? e.x : f.x : a.x > f.x ? a.x : f.x, k = e.y > a.y ? e.y > f.y ? e.y : f.y : a.y > f.y ? a.y : f.y, l = vg(e.x < a.x ? e.x < f.x ? e.x : f.x : a.x < f.x ? a.x : f.x, e.y < a.y ? e.y < f.y ? e.y : f.y : a.y < f.y ? a.y : f.y, b, c, d);
    b = vg(g, k, b, c, d);
    c = a.prevZ;
    for (d = a.nextZ; c && c.z >= l && d && d.z <= b; ) {
      if (c !== a.prev && c !== a.next && Yc(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) && 0 <= ta(c.prev, c, c.next)) return false;
      c = c.prevZ;
      if (d !== a.prev && d !== a.next && Yc(e.x, e.y, a.x, a.y, f.x, f.y, d.x, d.y) && 0 <= ta(d.prev, d, d.next)) return false;
      d = d.nextZ;
    }
    for (; c && c.z >= l; ) {
      if (c !== a.prev && c !== a.next && Yc(e.x, e.y, a.x, a.y, f.x, f.y, c.x, c.y) && 0 <= ta(c.prev, c, c.next)) return false;
      c = c.prevZ;
    }
    for (; d && d.z <= b; ) {
      if (d !== a.prev && d !== a.next && Yc(e.x, e.y, a.x, a.y, f.x, f.y, d.x, d.y) && 0 <= ta(d.prev, d, d.next)) return false;
      d = d.nextZ;
    }
    return true;
  }
  function Lk(a, b) {
    return a.x - b.x;
  }
  function Mk(a, b) {
    var c = b, d = a.x, e = a.y, f = -Infinity;
    do {
      if (e <= c.y && e >= c.next.y && c.next.y !== c.y) {
        var g = c.x + (e - c.y) * (c.next.x - c.x) / (c.next.y - c.y);
        if (g <= d && g > f) {
          f = g;
          if (g === d) {
            if (e === c.y) return c;
            if (e === c.next.y) return c.next;
          }
          var k = c.x < c.next.x ? c : c.next;
        }
      }
      c = c.next;
    } while (c !== b);
    if (!k) return null;
    if (d === f) return k.prev;
    b = k;
    g = k.x;
    var l = k.y, m = Infinity;
    for (c = k.next; c !== b; ) {
      if (d >= c.x && c.x >= g && d !== c.x && Yc(e < l ? d : f, e, g, l, e < l ? f : d, e, c.x, c.y)) {
        var h2 = Math.abs(e - c.y) / (d - c.x);
        (h2 < m || h2 === m && c.x > k.x) && ie(c, a) && (k = c, m = h2);
      }
      c = c.next;
    }
    return k;
  }
  function vg(a, b, c, d, e) {
    a = 32767 * (a - c) * e;
    b = 32767 * (b - d) * e;
    a = (a | a << 8) & 16711935;
    a = (a | a << 4) & 252645135;
    a = (a | a << 2) & 858993459;
    b = (b | b << 8) & 16711935;
    b = (b | b << 4) & 252645135;
    b = (b | b << 2) & 858993459;
    return (a | a << 1) & 1431655765 | ((b | b << 1) & 1431655765) << 1;
  }
  function Nk(a) {
    var b = a, c = a;
    do {
      if (b.x < c.x || b.x === c.x && b.y < c.y) c = b;
      b = b.next;
    } while (b !== a);
    return c;
  }
  function Yc(a, b, c, d, e, f, g, k) {
    return 0 <= (e - g) * (b - k) - (a - g) * (f - k) && 0 <= (a - g) * (d - k) - (c - g) * (b - k) && 0 <= (c - g) * (f - k) - (e - g) * (d - k);
  }
  function ta(a, b, c) {
    return (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
  }
  function fc(a, b) {
    return a.x === b.x && a.y === b.y;
  }
  function di(a, b, c, d) {
    return fc(a, c) && fc(
      b,
      d
    ) || fc(a, d) && fc(c, b) ? true : 0 < ta(a, b, c) !== 0 < ta(a, b, d) && 0 < ta(c, d, a) !== 0 < ta(c, d, b);
  }
  function ie(a, b) {
    return 0 > ta(a.prev, a, a.next) ? 0 <= ta(a, b, a.next) && 0 <= ta(a, a.prev, b) : 0 > ta(a, b, a.prev) || 0 > ta(a, a.next, b);
  }
  function ei(a, b) {
    var c = new wg(a.i, a.x, a.y), d = new wg(b.i, b.x, b.y), e = a.next, f = b.prev;
    a.next = b;
    b.prev = a;
    c.next = e;
    e.prev = c;
    d.next = c;
    c.prev = d;
    f.next = d;
    d.prev = f;
    return d;
  }
  function ci(a, b, c, d) {
    a = new wg(a, b, c);
    d ? (a.next = d.next, a.prev = d, d.next.prev = a, d.next = a) : (a.prev = a, a.next = a);
    return a;
  }
  function fe(a) {
    a.next.prev = a.prev;
    a.prev.next = a.next;
    a.prevZ && (a.prevZ.nextZ = a.nextZ);
    a.nextZ && (a.nextZ.prevZ = a.prevZ);
  }
  function wg(a, b, c) {
    this.i = a;
    this.x = b;
    this.y = c;
    this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
    this.steiner = false;
  }
  function fi(a) {
    var b = a.length;
    2 < b && a[b - 1].equals(a[0]) && a.pop();
  }
  function gi(a, b) {
    for (var c = 0; c < b.length; c++) a.push(b[c].x), a.push(b[c].y);
  }
  function gc(a, b) {
    L.call(this);
    this.type = "ExtrudeGeometry";
    this.parameters = { shapes: a, options: b };
    this.fromBufferGeometry(new gb(a, b));
    this.mergeVertices();
  }
  function gb(a, b) {
    function c(a2) {
      function c2(a3, b2, c3) {
        b2 || console.error("THREE.ExtrudeGeometry: vec does not exist");
        return b2.clone().multiplyScalar(c3).add(a3);
      }
      function g2(a3, b2, c3) {
        var d2 = a3.x - b2.x;
        var e2 = a3.y - b2.y;
        var f2 = c3.x - a3.x;
        var g3 = c3.y - a3.y, k3 = d2 * d2 + e2 * e2;
        if (Math.abs(d2 * g3 - e2 * f2) > Number.EPSILON) {
          var l2 = Math.sqrt(k3), m = Math.sqrt(f2 * f2 + g3 * g3);
          k3 = b2.x - e2 / l2;
          b2 = b2.y + d2 / l2;
          g3 = ((c3.x - g3 / m - k3) * g3 - (c3.y + f2 / m - b2) * f2) / (d2 * g3 - e2 * f2);
          f2 = k3 + d2 * g3 - a3.x;
          d2 = b2 + e2 * g3 - a3.y;
          e2 = f2 * f2 + d2 * d2;
          if (2 >= e2) return new w(f2, d2);
          e2 = Math.sqrt(e2 / 2);
        } else a3 = false, d2 > Number.EPSILON ? f2 > Number.EPSILON && (a3 = true) : d2 < -Number.EPSILON ? f2 < -Number.EPSILON && (a3 = true) : Math.sign(e2) === Math.sign(g3) && (a3 = true), a3 ? (f2 = -e2, e2 = Math.sqrt(k3)) : (f2 = d2, d2 = e2, e2 = Math.sqrt(k3 / 2));
        return new w(f2 / e2, d2 / e2);
      }
      function k2(a3, b2) {
        for (J = a3.length; 0 <= --J; ) {
          var c3 = J;
          var f2 = J - 1;
          0 > f2 && (f2 = a3.length - 1);
          var g3, k3 = C + 2 * E2;
          for (g3 = 0; g3 < k3; g3++) {
            var l2 = Y2 * g3, m = Y2 * (g3 + 1), h3 = b2 + f2 + l2, p = b2 + f2 + m;
            m = b2 + c3 + m;
            r(b2 + c3 + l2);
            r(h3);
            r(m);
            r(h3);
            r(p);
            r(m);
            l2 = e.length / 3;
            l2 = G.generateSideWallUV(d, e, l2 - 6, l2 - 3, l2 - 2, l2 - 1);
            u(l2[0]);
            u(l2[1]);
            u(l2[3]);
            u(l2[1]);
            u(l2[2]);
            u(l2[3]);
          }
        }
      }
      function l(a3, b2, c3) {
        y.push(a3);
        y.push(b2);
        y.push(c3);
      }
      function h2(a3, b2, c3) {
        r(a3);
        r(b2);
        r(c3);
        a3 = e.length / 3;
        a3 = G.generateTopUV(d, e, a3 - 3, a3 - 2, a3 - 1);
        u(a3[0]);
        u(a3[1]);
        u(a3[2]);
      }
      function r(a3) {
        e.push(y[3 * a3]);
        e.push(y[3 * a3 + 1]);
        e.push(y[3 * a3 + 2]);
      }
      function u(a3) {
        f.push(a3.x);
        f.push(a3.y);
      }
      var y = [], v = void 0 !== b.curveSegments ? b.curveSegments : 12, C = void 0 !== b.steps ? b.steps : 1, W = void 0 !== b.depth ? b.depth : 100, A2 = void 0 !== b.bevelEnabled ? b.bevelEnabled : true, z = void 0 !== b.bevelThickness ? b.bevelThickness : 6, B2 = void 0 !== b.bevelSize ? b.bevelSize : z - 2, D2 = void 0 !== b.bevelOffset ? b.bevelOffset : 0, E2 = void 0 !== b.bevelSegments ? b.bevelSegments : 3, F2 = b.extrudePath, G = void 0 !== b.UVGenerator ? b.UVGenerator : Ok;
      void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), W = b.amount);
      var I2 = false;
      if (F2) {
        var K2 = F2.getSpacedPoints(C);
        I2 = true;
        A2 = false;
        var L2 = F2.computeFrenetFrames(C, false);
        var M2 = new n();
        var P2 = new n();
        var N2 = new n();
      }
      A2 || (D2 = B2 = z = E2 = 0);
      var O2;
      v = a2.extractPoints(v);
      a2 = v.shape;
      var S2 = v.holes;
      if (!tb.isClockWise(a2)) {
        a2 = a2.reverse();
        var ha = 0;
        for (O2 = S2.length; ha < O2; ha++) {
          var xa = S2[ha];
          tb.isClockWise(xa) && (S2[ha] = xa.reverse());
        }
      }
      var Z2 = tb.triangulateShape(
        a2,
        S2
      ), V2 = a2;
      ha = 0;
      for (O2 = S2.length; ha < O2; ha++) xa = S2[ha], a2 = a2.concat(xa);
      var X, Y2 = a2.length, T2, ca2 = Z2.length;
      v = [];
      var J = 0;
      var Q = V2.length;
      var U2 = Q - 1;
      for (X = J + 1; J < Q; J++, U2++, X++) U2 === Q && (U2 = 0), X === Q && (X = 0), v[J] = g2(V2[J], V2[U2], V2[X]);
      F2 = [];
      var da2 = v.concat();
      ha = 0;
      for (O2 = S2.length; ha < O2; ha++) {
        xa = S2[ha];
        var ba2 = [];
        J = 0;
        Q = xa.length;
        U2 = Q - 1;
        for (X = J + 1; J < Q; J++, U2++, X++) U2 === Q && (U2 = 0), X === Q && (X = 0), ba2[J] = g2(xa[J], xa[U2], xa[X]);
        F2.push(ba2);
        da2 = da2.concat(ba2);
      }
      for (U2 = 0; U2 < E2; U2++) {
        Q = U2 / E2;
        var ea2 = z * Math.cos(Q * Math.PI / 2);
        X = B2 * Math.sin(Q * Math.PI / 2) + D2;
        J = 0;
        for (Q = V2.length; J < Q; J++) {
          var R2 = c2(V2[J], v[J], X);
          l(R2.x, R2.y, -ea2);
        }
        ha = 0;
        for (O2 = S2.length; ha < O2; ha++) for (xa = S2[ha], ba2 = F2[ha], J = 0, Q = xa.length; J < Q; J++) R2 = c2(xa[J], ba2[J], X), l(R2.x, R2.y, -ea2);
      }
      X = B2 + D2;
      for (J = 0; J < Y2; J++) R2 = A2 ? c2(a2[J], da2[J], X) : a2[J], I2 ? (P2.copy(L2.normals[0]).multiplyScalar(R2.x), M2.copy(L2.binormals[0]).multiplyScalar(R2.y), N2.copy(K2[0]).add(P2).add(M2), l(N2.x, N2.y, N2.z)) : l(R2.x, R2.y, 0);
      for (Q = 1; Q <= C; Q++) for (J = 0; J < Y2; J++) R2 = A2 ? c2(a2[J], da2[J], X) : a2[J], I2 ? (P2.copy(L2.normals[Q]).multiplyScalar(R2.x), M2.copy(L2.binormals[Q]).multiplyScalar(R2.y), N2.copy(K2[Q]).add(P2).add(M2), l(N2.x, N2.y, N2.z)) : l(R2.x, R2.y, W / C * Q);
      for (U2 = E2 - 1; 0 <= U2; U2--) {
        Q = U2 / E2;
        ea2 = z * Math.cos(Q * Math.PI / 2);
        X = B2 * Math.sin(Q * Math.PI / 2) + D2;
        J = 0;
        for (Q = V2.length; J < Q; J++) R2 = c2(V2[J], v[J], X), l(R2.x, R2.y, W + ea2);
        ha = 0;
        for (O2 = S2.length; ha < O2; ha++) for (xa = S2[ha], ba2 = F2[ha], J = 0, Q = xa.length; J < Q; J++) R2 = c2(xa[J], ba2[J], X), I2 ? l(R2.x, R2.y + K2[C - 1].y, K2[C - 1].x + ea2) : l(R2.x, R2.y, W + ea2);
      }
      (function() {
        var a3 = e.length / 3;
        if (A2) {
          var b2 = 0 * Y2;
          for (J = 0; J < ca2; J++) T2 = Z2[J], h2(T2[2] + b2, T2[1] + b2, T2[0] + b2);
          b2 = Y2 * (C + 2 * E2);
          for (J = 0; J < ca2; J++) T2 = Z2[J], h2(T2[0] + b2, T2[1] + b2, T2[2] + b2);
        } else {
          for (J = 0; J < ca2; J++) T2 = Z2[J], h2(T2[2], T2[1], T2[0]);
          for (J = 0; J < ca2; J++) T2 = Z2[J], h2(T2[0] + Y2 * C, T2[1] + Y2 * C, T2[2] + Y2 * C);
        }
        d.addGroup(a3, e.length / 3 - a3, 0);
      })();
      (function() {
        var a3 = e.length / 3, b2 = 0;
        k2(V2, b2);
        b2 += V2.length;
        ha = 0;
        for (O2 = S2.length; ha < O2; ha++) xa = S2[ha], k2(xa, b2), b2 += xa.length;
        d.addGroup(a3, e.length / 3 - a3, 1);
      })();
    }
    A.call(this);
    this.type = "ExtrudeBufferGeometry";
    this.parameters = { shapes: a, options: b };
    a = Array.isArray(a) ? a : [a];
    for (var d = this, e = [], f = [], g = 0, k = a.length; g < k; g++) c(a[g]);
    this.setAttribute("position", new E(e, 3));
    this.setAttribute("uv", new E(f, 2));
    this.computeVertexNormals();
  }
  function hi(a, b, c) {
    c.shapes = [];
    if (Array.isArray(a)) for (var d = 0, e = a.length; d < e; d++) c.shapes.push(a[d].uuid);
    else c.shapes.push(a.uuid);
    void 0 !== b.extrudePath && (c.options.extrudePath = b.extrudePath.toJSON());
    return c;
  }
  function je(a, b) {
    L.call(this);
    this.type = "TextGeometry";
    this.parameters = { text: a, parameters: b };
    this.fromBufferGeometry(new Zc(a, b));
    this.mergeVertices();
  }
  function Zc(a, b) {
    b = b || {};
    var c = b.font;
    if (!c || !c.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new L();
    a = c.generateShapes(a, b.size);
    b.depth = void 0 !== b.height ? b.height : 50;
    void 0 === b.bevelThickness && (b.bevelThickness = 10);
    void 0 === b.bevelSize && (b.bevelSize = 8);
    void 0 === b.bevelEnabled && (b.bevelEnabled = false);
    gb.call(this, a, b);
    this.type = "TextBufferGeometry";
  }
  function ke(a, b, c, d, e, f, g) {
    L.call(this);
    this.type = "SphereGeometry";
    this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g };
    this.fromBufferGeometry(new hc(a, b, c, d, e, f, g));
    this.mergeVertices();
  }
  function hc(a, b, c, d, e, f, g) {
    A.call(this);
    this.type = "SphereBufferGeometry";
    this.parameters = { radius: a, widthSegments: b, heightSegments: c, phiStart: d, phiLength: e, thetaStart: f, thetaLength: g };
    a = a || 1;
    b = Math.max(3, Math.floor(b) || 8);
    c = Math.max(2, Math.floor(c) || 6);
    d = void 0 !== d ? d : 0;
    e = void 0 !== e ? e : 2 * Math.PI;
    f = void 0 !== f ? f : 0;
    g = void 0 !== g ? g : Math.PI;
    var k = Math.min(f + g, Math.PI), l, m, h2 = 0, p = [], q = new n(), t = new n(), r = [], u = [], y = [], v = [];
    for (m = 0; m <= c; m++) {
      var w2 = [], W = m / c, B2 = 0;
      0 == m && 0 == f ? B2 = 0.5 / b : m == c && k == Math.PI && (B2 = -0.5 / b);
      for (l = 0; l <= b; l++) {
        var z = l / b;
        q.x = -a * Math.cos(d + z * e) * Math.sin(f + W * g);
        q.y = a * Math.cos(f + W * g);
        q.z = a * Math.sin(d + z * e) * Math.sin(f + W * g);
        u.push(q.x, q.y, q.z);
        t.copy(q).normalize();
        y.push(t.x, t.y, t.z);
        v.push(z + B2, 1 - W);
        w2.push(h2++);
      }
      p.push(w2);
    }
    for (m = 0; m < c; m++) for (l = 0; l < b; l++) a = p[m][l + 1], d = p[m][l], e = p[m + 1][l], g = p[m + 1][l + 1], (0 !== m || 0 < f) && r.push(a, d, g), (m !== c - 1 || k < Math.PI) && r.push(d, e, g);
    this.setIndex(r);
    this.setAttribute("position", new E(u, 3));
    this.setAttribute("normal", new E(y, 3));
    this.setAttribute("uv", new E(v, 2));
  }
  function le(a, b, c, d, e, f) {
    L.call(this);
    this.type = "RingGeometry";
    this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f };
    this.fromBufferGeometry(new $c(a, b, c, d, e, f));
    this.mergeVertices();
  }
  function $c(a, b, c, d, e, f) {
    A.call(this);
    this.type = "RingBufferGeometry";
    this.parameters = { innerRadius: a, outerRadius: b, thetaSegments: c, phiSegments: d, thetaStart: e, thetaLength: f };
    a = a || 0.5;
    b = b || 1;
    e = void 0 !== e ? e : 0;
    f = void 0 !== f ? f : 2 * Math.PI;
    c = void 0 !== c ? Math.max(3, c) : 8;
    d = void 0 !== d ? Math.max(1, d) : 1;
    var g = [], k = [], l = [], m = [], h2 = a, p = (b - a) / d, q = new n(), t = new w(), r, u;
    for (r = 0; r <= d; r++) {
      for (u = 0; u <= c; u++) a = e + u / c * f, q.x = h2 * Math.cos(a), q.y = h2 * Math.sin(a), k.push(q.x, q.y, q.z), l.push(0, 0, 1), t.x = (q.x / b + 1) / 2, t.y = (q.y / b + 1) / 2, m.push(t.x, t.y);
      h2 += p;
    }
    for (r = 0; r < d; r++) for (b = r * (c + 1), u = 0; u < c; u++) a = u + b, e = a + c + 1, f = a + c + 2, h2 = a + 1, g.push(a, e, h2), g.push(e, f, h2);
    this.setIndex(g);
    this.setAttribute("position", new E(k, 3));
    this.setAttribute("normal", new E(l, 3));
    this.setAttribute("uv", new E(m, 2));
  }
  function me(a, b, c, d) {
    L.call(this);
    this.type = "LatheGeometry";
    this.parameters = { points: a, segments: b, phiStart: c, phiLength: d };
    this.fromBufferGeometry(new ad(a, b, c, d));
    this.mergeVertices();
  }
  function ad(a, b, c, d) {
    A.call(this);
    this.type = "LatheBufferGeometry";
    this.parameters = { points: a, segments: b, phiStart: c, phiLength: d };
    b = Math.floor(b) || 12;
    c = c || 0;
    d = d || 2 * Math.PI;
    d = P.clamp(d, 0, 2 * Math.PI);
    var e = [], f = [], g = [], k = 1 / b, l = new n(), m = new w(), h2;
    for (h2 = 0; h2 <= b; h2++) {
      var p = c + h2 * k * d;
      var q = Math.sin(p), t = Math.cos(p);
      for (p = 0; p <= a.length - 1; p++) l.x = a[p].x * q, l.y = a[p].y, l.z = a[p].x * t, f.push(
        l.x,
        l.y,
        l.z
      ), m.x = h2 / b, m.y = p / (a.length - 1), g.push(m.x, m.y);
    }
    for (h2 = 0; h2 < b; h2++) for (p = 0; p < a.length - 1; p++) c = p + h2 * a.length, k = c + a.length, l = c + a.length + 1, m = c + 1, e.push(c, k, m), e.push(k, l, m);
    this.setIndex(e);
    this.setAttribute("position", new E(f, 3));
    this.setAttribute("uv", new E(g, 2));
    this.computeVertexNormals();
    if (d === 2 * Math.PI) for (d = this.attributes.normal.array, e = new n(), f = new n(), g = new n(), c = b * a.length * 3, p = h2 = 0; h2 < a.length; h2++, p += 3) e.x = d[p + 0], e.y = d[p + 1], e.z = d[p + 2], f.x = d[c + p + 0], f.y = d[c + p + 1], f.z = d[c + p + 2], g.addVectors(e, f).normalize(), d[p + 0] = d[c + p + 0] = g.x, d[p + 1] = d[c + p + 1] = g.y, d[p + 2] = d[c + p + 2] = g.z;
  }
  function ic(a, b) {
    L.call(this);
    this.type = "ShapeGeometry";
    "object" === typeof b && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments);
    this.parameters = { shapes: a, curveSegments: b };
    this.fromBufferGeometry(new jc(a, b));
    this.mergeVertices();
  }
  function jc(a, b) {
    function c(a2) {
      var c2, k2 = e.length / 3;
      a2 = a2.extractPoints(b);
      var m2 = a2.shape, h2 = a2.holes;
      false === tb.isClockWise(m2) && (m2 = m2.reverse());
      a2 = 0;
      for (c2 = h2.length; a2 < c2; a2++) {
        var x = h2[a2];
        true === tb.isClockWise(x) && (h2[a2] = x.reverse());
      }
      var n2 = tb.triangulateShape(m2, h2);
      a2 = 0;
      for (c2 = h2.length; a2 < c2; a2++) x = h2[a2], m2 = m2.concat(x);
      a2 = 0;
      for (c2 = m2.length; a2 < c2; a2++) x = m2[a2], e.push(x.x, x.y, 0), f.push(0, 0, 1), g.push(x.x, x.y);
      a2 = 0;
      for (c2 = n2.length; a2 < c2; a2++) m2 = n2[a2], d.push(m2[0] + k2, m2[1] + k2, m2[2] + k2), l += 3;
    }
    A.call(this);
    this.type = "ShapeBufferGeometry";
    this.parameters = { shapes: a, curveSegments: b };
    b = b || 12;
    var d = [], e = [], f = [], g = [], k = 0, l = 0;
    if (false === Array.isArray(a)) c(a);
    else for (var m = 0; m < a.length; m++) c(a[m]), this.addGroup(k, l, m), k += l, l = 0;
    this.setIndex(d);
    this.setAttribute("position", new E(e, 3));
    this.setAttribute("normal", new E(f, 3));
    this.setAttribute("uv", new E(g, 2));
  }
  function ii(a, b) {
    b.shapes = [];
    if (Array.isArray(a)) for (var c = 0, d = a.length; c < d; c++) b.shapes.push(a[c].uuid);
    else b.shapes.push(a.uuid);
    return b;
  }
  function bd(a, b) {
    A.call(this);
    this.type = "EdgesGeometry";
    this.parameters = { thresholdAngle: b };
    var c = [];
    b = Math.cos(P.DEG2RAD * (void 0 !== b ? b : 1));
    var d = [0, 0], e = {}, f = ["a", "b", "c"];
    if (a.isBufferGeometry) {
      var g = new L();
      g.fromBufferGeometry(a);
    } else g = a.clone();
    g.mergeVertices();
    g.computeFaceNormals();
    a = g.vertices;
    g = g.faces;
    for (var k = 0, l = g.length; k < l; k++) for (var m = g[k], h2 = 0; 3 > h2; h2++) {
      var p = m[f[h2]];
      var q = m[f[(h2 + 1) % 3]];
      d[0] = Math.min(p, q);
      d[1] = Math.max(p, q);
      p = d[0] + "," + d[1];
      void 0 === e[p] ? e[p] = { index1: d[0], index2: d[1], face1: k, face2: void 0 } : e[p].face2 = k;
    }
    for (p in e) if (d = e[p], void 0 === d.face2 || g[d.face1].normal.dot(g[d.face2].normal) <= b) f = a[d.index1], c.push(f.x, f.y, f.z), f = a[d.index2], c.push(f.x, f.y, f.z);
    this.setAttribute("position", new E(c, 3));
  }
  function kc(a, b, c, d, e, f, g, k) {
    L.call(this);
    this.type = "CylinderGeometry";
    this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: k };
    this.fromBufferGeometry(new ub(a, b, c, d, e, f, g, k));
    this.mergeVertices();
  }
  function ub(a, b, c, d, e, f, g, k) {
    function l(c2) {
      var e2, f2 = new w(), l2 = new n(), x = 0, u2 = true === c2 ? a : b, C = true === c2 ? 1 : -1;
      var A2 = r;
      for (e2 = 1; e2 <= d; e2++) p.push(0, y * C, 0), q.push(0, C, 0), t.push(0.5, 0.5), r++;
      var B2 = r;
      for (e2 = 0; e2 <= d; e2++) {
        var E2 = e2 / d * k + g, D2 = Math.cos(E2);
        E2 = Math.sin(E2);
        l2.x = u2 * E2;
        l2.y = y * C;
        l2.z = u2 * D2;
        p.push(l2.x, l2.y, l2.z);
        q.push(0, C, 0);
        f2.x = 0.5 * D2 + 0.5;
        f2.y = 0.5 * E2 * C + 0.5;
        t.push(f2.x, f2.y);
        r++;
      }
      for (e2 = 0; e2 < d; e2++) f2 = A2 + e2, l2 = B2 + e2, true === c2 ? h2.push(l2, l2 + 1, f2) : h2.push(l2 + 1, l2, f2), x += 3;
      m.addGroup(v, x, true === c2 ? 1 : 2);
      v += x;
    }
    A.call(this);
    this.type = "CylinderBufferGeometry";
    this.parameters = { radiusTop: a, radiusBottom: b, height: c, radialSegments: d, heightSegments: e, openEnded: f, thetaStart: g, thetaLength: k };
    var m = this;
    a = void 0 !== a ? a : 1;
    b = void 0 !== b ? b : 1;
    c = c || 1;
    d = Math.floor(d) || 8;
    e = Math.floor(e) || 1;
    f = void 0 !== f ? f : false;
    g = void 0 !== g ? g : 0;
    k = void 0 !== k ? k : 2 * Math.PI;
    var h2 = [], p = [], q = [], t = [], r = 0, u = [], y = c / 2, v = 0;
    (function() {
      var f2, l2, x = new n(), z = new n(), w2 = 0, A2 = (b - a) / c;
      for (l2 = 0; l2 <= e; l2++) {
        var B2 = [], E2 = l2 / e, G = E2 * (b - a) + a;
        for (f2 = 0; f2 <= d; f2++) {
          var D2 = f2 / d, F2 = D2 * k + g, I2 = Math.sin(F2);
          F2 = Math.cos(F2);
          z.x = G * I2;
          z.y = -E2 * c + y;
          z.z = G * F2;
          p.push(z.x, z.y, z.z);
          x.set(I2, A2, F2).normalize();
          q.push(x.x, x.y, x.z);
          t.push(D2, 1 - E2);
          B2.push(r++);
        }
        u.push(B2);
      }
      for (f2 = 0; f2 < d; f2++) for (l2 = 0; l2 < e; l2++) x = u[l2 + 1][f2], z = u[l2 + 1][f2 + 1], A2 = u[l2][f2 + 1], h2.push(u[l2][f2], x, A2), h2.push(x, z, A2), w2 += 6;
      m.addGroup(v, w2, 0);
      v += w2;
    })();
    false === f && (0 < a && l(true), 0 < b && l(false));
    this.setIndex(h2);
    this.setAttribute("position", new E(p, 3));
    this.setAttribute("normal", new E(q, 3));
    this.setAttribute("uv", new E(t, 2));
  }
  function ne(a, b, c, d, e, f, g) {
    kc.call(this, 0, a, b, c, d, e, f, g);
    this.type = "ConeGeometry";
    this.parameters = { radius: a, height: b, radialSegments: c, heightSegments: d, openEnded: e, thetaStart: f, thetaLength: g };
  }
  function oe(a, b, c, d, e, f, g) {
    ub.call(this, 0, a, b, c, d, e, f, g);
    this.type = "ConeBufferGeometry";
    this.parameters = {
      radius: a,
      height: b,
      radialSegments: c,
      heightSegments: d,
      openEnded: e,
      thetaStart: f,
      thetaLength: g
    };
  }
  function pe(a, b, c, d) {
    L.call(this);
    this.type = "CircleGeometry";
    this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d };
    this.fromBufferGeometry(new cd(a, b, c, d));
    this.mergeVertices();
  }
  function cd(a, b, c, d) {
    A.call(this);
    this.type = "CircleBufferGeometry";
    this.parameters = { radius: a, segments: b, thetaStart: c, thetaLength: d };
    a = a || 1;
    b = void 0 !== b ? Math.max(3, b) : 8;
    c = void 0 !== c ? c : 0;
    d = void 0 !== d ? d : 2 * Math.PI;
    var e = [], f = [], g = [], k = [], l, m = new n(), h2 = new w();
    f.push(0, 0, 0);
    g.push(0, 0, 1);
    k.push(
      0.5,
      0.5
    );
    var p = 0;
    for (l = 3; p <= b; p++, l += 3) {
      var q = c + p / b * d;
      m.x = a * Math.cos(q);
      m.y = a * Math.sin(q);
      f.push(m.x, m.y, m.z);
      g.push(0, 0, 1);
      h2.x = (f[l] / a + 1) / 2;
      h2.y = (f[l + 1] / a + 1) / 2;
      k.push(h2.x, h2.y);
    }
    for (l = 1; l <= b; l++) e.push(l, l + 1, 0);
    this.setIndex(e);
    this.setAttribute("position", new E(f, 3));
    this.setAttribute("normal", new E(g, 3));
    this.setAttribute("uv", new E(k, 2));
  }
  function lc(a) {
    K.call(this);
    this.type = "ShadowMaterial";
    this.color = new B(0);
    this.transparent = true;
    this.setValues(a);
  }
  function vb(a) {
    qa.call(this, a);
    this.type = "RawShaderMaterial";
  }
  function hb(a) {
    K.call(this);
    this.defines = { STANDARD: "" };
    this.type = "MeshStandardMaterial";
    this.color = new B(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new B(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new w(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = false;
    this.setValues(a);
  }
  function mc(a) {
    hb.call(this);
    this.defines = { STANDARD: "", PHYSICAL: "" };
    this.type = "MeshPhysicalMaterial";
    this.reflectivity = 0.5;
    this.clearcoatRoughness = this.clearcoat = 0;
    this.sheen = null;
    this.clearcoatNormalScale = new w(1, 1);
    this.clearcoatNormalMap = null;
    this.transparency = 0;
    this.setValues(a);
  }
  function Kb(a) {
    K.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new B(16777215);
    this.specular = new B(1118481);
    this.shininess = 30;
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new B(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new w(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.envMap = this.alphaMap = this.specularMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = false;
    this.setValues(a);
  }
  function nc(a) {
    K.call(this);
    this.defines = { TOON: "" };
    this.type = "MeshToonMaterial";
    this.color = new B(16777215);
    this.specular = new B(1118481);
    this.shininess = 30;
    this.lightMap = this.gradientMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new B(0);
    this.emissiveIntensity = 1;
    this.bumpMap = this.emissiveMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new w(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = this.specularMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = false;
    this.setValues(a);
  }
  function oc(a) {
    K.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new w(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.morphNormals = this.morphTargets = this.skinning = this.fog = false;
    this.setValues(a);
  }
  function pc(a) {
    K.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new B(16777215);
    this.lightMap = this.map = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new B(0);
    this.emissiveIntensity = 1;
    this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
    this.combine = 0;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.morphNormals = this.morphTargets = this.skinning = false;
    this.setValues(a);
  }
  function qc(a) {
    K.call(this);
    this.defines = { MATCAP: "" };
    this.type = "MeshMatcapMaterial";
    this.color = new B(16777215);
    this.bumpMap = this.map = this.matcap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = 0;
    this.normalScale = new w(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.morphNormals = this.morphTargets = this.skinning = false;
    this.setValues(a);
  }
  function rc(a) {
    ka.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(a);
  }
  function Ma(a, b, c, d) {
    this.parameterPositions = a;
    this._cachedIndex = 0;
    this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
    this.sampleValues = b;
    this.valueSize = c;
  }
  function Xe(a, b, c, d) {
    Ma.call(this, a, b, c, d);
    this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0;
  }
  function qe(a, b, c, d) {
    Ma.call(this, a, b, c, d);
  }
  function Ye(a, b, c, d) {
    Ma.call(this, a, b, c, d);
  }
  function ua(a, b, c, d) {
    if (void 0 === a) throw Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === b || 0 === b.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
    this.name = a;
    this.times = ea.convertArray(b, this.TimeBufferType);
    this.values = ea.convertArray(c, this.ValueBufferType);
    this.setInterpolation(d || this.DefaultInterpolation);
  }
  function Ze(a, b, c) {
    ua.call(this, a, b, c);
  }
  function $e(a, b, c, d) {
    ua.call(this, a, b, c, d);
  }
  function dd(a, b, c, d) {
    ua.call(this, a, b, c, d);
  }
  function af(a, b, c, d) {
    Ma.call(this, a, b, c, d);
  }
  function re(a, b, c, d) {
    ua.call(this, a, b, c, d);
  }
  function bf(a, b, c, d) {
    ua.call(this, a, b, c, d);
  }
  function ed(a, b, c, d) {
    ua.call(this, a, b, c, d);
  }
  function Ra(a, b, c) {
    this.name = a;
    this.tracks = c;
    this.duration = void 0 !== b ? b : -1;
    this.uuid = P.generateUUID();
    0 > this.duration && this.resetDuration();
  }
  function Pk(a) {
    switch (a.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return dd;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ed;
      case "color":
        return $e;
      case "quaternion":
        return re;
      case "bool":
      case "boolean":
        return Ze;
      case "string":
        return bf;
    }
    throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
  }
  function Qk(a) {
    if (void 0 === a.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var b = Pk(a.type);
    if (void 0 === a.times) {
      var c = [], d = [];
      ea.flattenJSON(a.keys, c, d, "value");
      a.times = c;
      a.values = d;
    }
    return void 0 !== b.parse ? b.parse(a) : new b(
      a.name,
      a.times,
      a.values,
      a.interpolation
    );
  }
  function xg(a, b, c) {
    var d = this, e = false, f = 0, g = 0, k = void 0, l = [];
    this.onStart = void 0;
    this.onLoad = a;
    this.onProgress = b;
    this.onError = c;
    this.itemStart = function(a2) {
      g++;
      if (false === e && void 0 !== d.onStart) d.onStart(a2, f, g);
      e = true;
    };
    this.itemEnd = function(a2) {
      f++;
      if (void 0 !== d.onProgress) d.onProgress(a2, f, g);
      if (f === g && (e = false, void 0 !== d.onLoad)) d.onLoad();
    };
    this.itemError = function(a2) {
      if (void 0 !== d.onError) d.onError(a2);
    };
    this.resolveURL = function(a2) {
      return k ? k(a2) : a2;
    };
    this.setURLModifier = function(a2) {
      k = a2;
      return this;
    };
    this.addHandler = function(a2, b2) {
      l.push(a2, b2);
      return this;
    };
    this.removeHandler = function(a2) {
      a2 = l.indexOf(a2);
      -1 !== a2 && l.splice(a2, 2);
      return this;
    };
    this.getHandler = function(a2) {
      for (var b2 = 0, c2 = l.length; b2 < c2; b2 += 2) {
        var d2 = l[b2], e2 = l[b2 + 1];
        d2.global && (d2.lastIndex = 0);
        if (d2.test(a2)) return e2;
      }
      return null;
    };
  }
  function V(a) {
    this.manager = void 0 !== a ? a : ji;
    this.crossOrigin = "anonymous";
    this.resourcePath = this.path = "";
  }
  function Sa(a) {
    V.call(this, a);
  }
  function yg(a) {
    V.call(this, a);
  }
  function zg(a) {
    V.call(this, a);
  }
  function cf(a) {
    V.call(
      this,
      a
    );
  }
  function fd(a) {
    V.call(this, a);
  }
  function df(a) {
    V.call(this, a);
  }
  function ef(a) {
    V.call(this, a);
  }
  function I() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  function Na(a, b, c, d, e, f, g, k) {
    I.call(this);
    this.type = "EllipseCurve";
    this.aX = a || 0;
    this.aY = b || 0;
    this.xRadius = c || 1;
    this.yRadius = d || 1;
    this.aStartAngle = e || 0;
    this.aEndAngle = f || 2 * Math.PI;
    this.aClockwise = g || false;
    this.aRotation = k || 0;
  }
  function gd(a, b, c, d, e, f) {
    Na.call(this, a, b, c, c, d, e, f);
    this.type = "ArcCurve";
  }
  function Ag() {
    var a = 0, b = 0, c = 0, d = 0;
    return { initCatmullRom: function(e, f, g, k, l) {
      e = l * (g - e);
      k = l * (k - f);
      a = f;
      b = e;
      c = -3 * f + 3 * g - 2 * e - k;
      d = 2 * f - 2 * g + e + k;
    }, initNonuniformCatmullRom: function(e, f, g, k, l, m, h2) {
      e = ((f - e) / l - (g - e) / (l + m) + (g - f) / m) * m;
      k = ((g - f) / m - (k - f) / (m + h2) + (k - g) / h2) * m;
      a = f;
      b = e;
      c = -3 * f + 3 * g - 2 * e - k;
      d = 2 * f - 2 * g + e + k;
    }, calc: function(e) {
      var f = e * e;
      return a + b * e + c * f + d * f * e;
    } };
  }
  function Aa(a, b, c, d) {
    I.call(this);
    this.type = "CatmullRomCurve3";
    this.points = a || [];
    this.closed = b || false;
    this.curveType = c || "centripetal";
    this.tension = d || 0.5;
  }
  function ki(a, b, c, d, e) {
    b = 0.5 * (d - b);
    e = 0.5 * (e - c);
    var f = a * a;
    return (2 * c - 2 * d + b + e) * a * f + (-3 * c + 3 * d - 2 * b - e) * f + b * a + c;
  }
  function se(a, b, c, d) {
    var e = 1 - a;
    return e * e * b + 2 * (1 - a) * a * c + a * a * d;
  }
  function te(a, b, c, d, e) {
    var f = 1 - a, g = 1 - a;
    return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e;
  }
  function Xa(a, b, c, d) {
    I.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = a || new w();
    this.v1 = b || new w();
    this.v2 = c || new w();
    this.v3 = d || new w();
  }
  function ib(a, b, c, d) {
    I.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = a || new n();
    this.v1 = b || new n();
    this.v2 = c || new n();
    this.v3 = d || new n();
  }
  function Ea(a, b) {
    I.call(this);
    this.type = "LineCurve";
    this.v1 = a || new w();
    this.v2 = b || new w();
  }
  function Ya(a, b) {
    I.call(this);
    this.type = "LineCurve3";
    this.v1 = a || new n();
    this.v2 = b || new n();
  }
  function Za(a, b, c) {
    I.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = a || new w();
    this.v1 = b || new w();
    this.v2 = c || new w();
  }
  function jb(a, b, c) {
    I.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = a || new n();
    this.v1 = b || new n();
    this.v2 = c || new n();
  }
  function $a(a) {
    I.call(this);
    this.type = "SplineCurve";
    this.points = a || [];
  }
  function wb() {
    I.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  function ab(a) {
    wb.call(this);
    this.type = "Path";
    this.currentPoint = new w();
    a && this.setFromPoints(a);
  }
  function Lb(a) {
    ab.call(this, a);
    this.uuid = P.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  function ba(a, b) {
    D.call(this);
    this.type = "Light";
    this.color = new B(a);
    this.intensity = void 0 !== b ? b : 1;
    this.receiveShadow = void 0;
  }
  function ff(a, b, c) {
    ba.call(this, a, c);
    this.type = "HemisphereLight";
    this.castShadow = void 0;
    this.position.copy(D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new B(b);
  }
  function kb(a) {
    this.camera = a;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new w(512, 512);
    this.mapPass = this.map = null;
    this.matrix = new O();
    this._frustum = new Hc();
    this._frameExtents = new w(1, 1);
    this._viewportCount = 1;
    this._viewports = [new ia(0, 0, 1, 1)];
  }
  function gf() {
    kb.call(this, new da(50, 1, 0.5, 500));
  }
  function hf(a, b, c, d, e, f) {
    ba.call(this, a, b);
    this.type = "SpotLight";
    this.position.copy(D.DefaultUp);
    this.updateMatrix();
    this.target = new D();
    Object.defineProperty(this, "power", { get: function() {
      return this.intensity * Math.PI;
    }, set: function(a2) {
      this.intensity = a2 / Math.PI;
    } });
    this.distance = void 0 !== c ? c : 0;
    this.angle = void 0 !== d ? d : Math.PI / 3;
    this.penumbra = void 0 !== e ? e : 0;
    this.decay = void 0 !== f ? f : 1;
    this.shadow = new gf();
  }
  function Bg() {
    kb.call(this, new da(90, 1, 0.5, 500));
    this._frameExtents = new w(4, 2);
    this._viewportCount = 6;
    this._viewports = [new ia(2, 1, 1, 1), new ia(0, 1, 1, 1), new ia(3, 1, 1, 1), new ia(1, 1, 1, 1), new ia(3, 0, 1, 1), new ia(1, 0, 1, 1)];
    this._cubeDirections = [new n(1, 0, 0), new n(-1, 0, 0), new n(0, 0, 1), new n(0, 0, -1), new n(0, 1, 0), new n(0, -1, 0)];
    this._cubeUps = [new n(0, 1, 0), new n(0, 1, 0), new n(0, 1, 0), new n(
      0,
      1,
      0
    ), new n(0, 0, 1), new n(0, 0, -1)];
  }
  function jf(a, b, c, d) {
    ba.call(this, a, b);
    this.type = "PointLight";
    Object.defineProperty(this, "power", { get: function() {
      return 4 * this.intensity * Math.PI;
    }, set: function(a2) {
      this.intensity = a2 / (4 * Math.PI);
    } });
    this.distance = void 0 !== c ? c : 0;
    this.decay = void 0 !== d ? d : 1;
    this.shadow = new Bg();
  }
  function hd(a, b, c, d, e, f) {
    eb.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = void 0 !== a ? a : -1;
    this.right = void 0 !== b ? b : 1;
    this.top = void 0 !== c ? c : 1;
    this.bottom = void 0 !== d ? d : -1;
    this.near = void 0 !== e ? e : 0.1;
    this.far = void 0 !== f ? f : 2e3;
    this.updateProjectionMatrix();
  }
  function kf() {
    kb.call(this, new hd(-5, 5, 5, -5, 0.5, 500));
  }
  function lf(a, b) {
    ba.call(this, a, b);
    this.type = "DirectionalLight";
    this.position.copy(D.DefaultUp);
    this.updateMatrix();
    this.target = new D();
    this.shadow = new kf();
  }
  function mf(a, b) {
    ba.call(this, a, b);
    this.type = "AmbientLight";
    this.castShadow = void 0;
  }
  function nf(a, b, c, d) {
    ba.call(this, a, b);
    this.type = "RectAreaLight";
    this.width = void 0 !== c ? c : 10;
    this.height = void 0 !== d ? d : 10;
  }
  function of(a) {
    V.call(
      this,
      a
    );
    this.textures = {};
  }
  function pf() {
    A.call(this);
    this.type = "InstancedBufferGeometry";
    this.maxInstancedCount = void 0;
  }
  function qf(a, b, c, d) {
    "number" === typeof c && (d = c, c = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));
    M.call(this, a, b, c);
    this.meshPerAttribute = d || 1;
  }
  function rf(a) {
    V.call(this, a);
  }
  function sf(a) {
    V.call(this, a);
  }
  function Cg(a) {
    "undefined" === typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    "undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    V.call(this, a);
    this.options = void 0;
  }
  function Dg() {
    this.type = "ShapePath";
    this.color = new B();
    this.subPaths = [];
    this.currentPath = null;
  }
  function Eg(a) {
    this.type = "Font";
    this.data = a;
  }
  function Fg(a) {
    V.call(this, a);
  }
  function tf(a) {
    V.call(this, a);
  }
  function uf() {
    this.coefficients = [];
    for (var a = 0; 9 > a; a++) this.coefficients.push(new n());
  }
  function bb(a, b) {
    ba.call(this, void 0, b);
    this.sh = void 0 !== a ? a : new uf();
  }
  function Gg(a, b, c) {
    bb.call(
      this,
      void 0,
      c
    );
    a = new B().set(a);
    c = new B().set(b);
    b = new n(a.r, a.g, a.b);
    a = new n(c.r, c.g, c.b);
    c = Math.sqrt(Math.PI);
    var d = c * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(b).add(a).multiplyScalar(c);
    this.sh.coefficients[1].copy(b).sub(a).multiplyScalar(d);
  }
  function Hg(a, b) {
    bb.call(this, void 0, b);
    a = new B().set(a);
    this.sh.coefficients[0].set(a.r, a.g, a.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
  function li() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new da();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new da();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  function Ig(a) {
    this.autoStart = void 0 !== a ? a : true;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = false;
  }
  function Jg() {
    D.call(this);
    this.type = "AudioListener";
    this.context = Kg.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Ig();
  }
  function id(a) {
    D.call(this);
    this.type = "Audio";
    this.listener = a;
    this.context = a.context;
    this.gain = this.context.createGain();
    this.gain.connect(a.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.offset = this.loopEnd = this.loopStart = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.sourceType = "empty";
    this._pausedAt = this._startedAt = 0;
    this.filters = [];
  }
  function Lg(a) {
    id.call(this, a);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  function Mg(a, b) {
    this.analyser = a.context.createAnalyser();
    this.analyser.fftSize = void 0 !== b ? b : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    a.getOutput().connect(this.analyser);
  }
  function Ng(a, b, c) {
    this.binding = a;
    this.valueSize = c;
    a = Float64Array;
    switch (b) {
      case "quaternion":
        b = this._slerp;
        break;
      case "string":
      case "bool":
        a = Array;
        b = this._select;
        break;
      default:
        b = this._lerp;
    }
    this.buffer = new a(4 * c);
    this._mixBufferRegion = b;
    this.referenceCount = this.useCount = this.cumulativeWeight = 0;
  }
  function mi(a, b, c) {
    c = c || Ba.parseTrackName(b);
    this._targetGroup = a;
    this._bindings = a.subscribe_(b, c);
  }
  function Ba(a, b, c) {
    this.path = b;
    this.parsedPath = c || Ba.parseTrackName(b);
    this.node = Ba.findNode(a, this.parsedPath.nodeName) || a;
    this.rootNode = a;
  }
  function ni() {
    this.uuid = P.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var a = {};
    this._indicesByUUID = a;
    for (var b = 0, c = arguments.length; b !== c; ++b) a[arguments[b].uuid] = b;
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var d = this;
    this.stats = { objects: { get total() {
      return d._objects.length;
    }, get inUse() {
      return this.total - d.nCachedObjects_;
    } }, get bindingsPerObject() {
      return d._bindings.length;
    } };
  }
  function oi(a, b, c) {
    this._mixer = a;
    this._clip = b;
    this._localRoot = c || null;
    a = b.tracks;
    b = a.length;
    c = Array(b);
    for (var d = { endingStart: 2400, endingEnd: 2400 }, e = 0; e !== b; ++e) {
      var f = a[e].createInterpolant(null);
      c[e] = f;
      f.settings = d;
    }
    this._interpolantSettings = d;
    this._interpolants = c;
    this._propertyBindings = Array(b);
    this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
    this.loop = 2201;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtEnd = this.zeroSlopeAtStart = true;
  }
  function Og(a) {
    this._root = a;
    this._initMemoryManager();
    this.time = this._accuIndex = 0;
    this.timeScale = 1;
  }
  function vf(a, b) {
    "string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b);
    this.value = a;
  }
  function Pg(a, b, c) {
    sb.call(this, a, b);
    this.meshPerAttribute = c || 1;
  }
  function pi(a, b, c, d) {
    this.ray = new Wb(a, b);
    this.near = c || 0;
    this.far = d || Infinity;
    this.camera = null;
    this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
    Object.defineProperties(this.params, { PointCloud: { get: function() {
      console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
      return this.Points;
    } } });
  }
  function qi(a, b) {
    return a.distance - b.distance;
  }
  function Qg(a, b, c, d) {
    if (false !== a.visible && (a.raycast(b, c), true === d)) {
      a = a.children;
      d = 0;
      for (var e = a.length; d < e; d++) Qg(a[d], b, c, true);
    }
  }
  function ri(a, b, c) {
    this.radius = void 0 !== a ? a : 1;
    this.phi = void 0 !== b ? b : 0;
    this.theta = void 0 !== c ? c : 0;
    return this;
  }
  function si(a, b, c) {
    this.radius = void 0 !== a ? a : 1;
    this.theta = void 0 !== b ? b : 0;
    this.y = void 0 !== c ? c : 0;
    return this;
  }
  function Rg(a, b) {
    this.min = void 0 !== a ? a : new w(Infinity, Infinity);
    this.max = void 0 !== b ? b : new w(-Infinity, -Infinity);
  }
  function Sg(a, b) {
    this.start = void 0 !== a ? a : new n();
    this.end = void 0 !== b ? b : new n();
  }
  function ue(a) {
    D.call(this);
    this.material = a;
    this.render = function() {
    };
  }
  function jd(a, b) {
    D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = b;
    a = new A();
    b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (var c = 0, d = 1; 32 > c; c++, d++) {
      var e = c / 32 * Math.PI * 2, f = d / 32 * Math.PI * 2;
      b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1);
    }
    a.setAttribute("position", new E(b, 3));
    b = new ka({ fog: false });
    this.cone = new ma(a, b);
    this.add(this.cone);
    this.update();
  }
  function ti(a) {
    var b = [];
    a && a.isBone && b.push(a);
    for (var c = 0; c < a.children.length; c++) b.push.apply(b, ti(a.children[c]));
    return b;
  }
  function kd(a) {
    for (var b = ti(a), c = new A(), d = [], e = [], f = new B(0, 0, 1), g = new B(0, 1, 0), k = 0; k < b.length; k++) {
      var l = b[k];
      l.parent && l.parent.isBone && (d.push(0, 0, 0), d.push(0, 0, 0), e.push(f.r, f.g, f.b), e.push(g.r, g.g, g.b));
    }
    c.setAttribute("position", new E(d, 3));
    c.setAttribute("color", new E(e, 3));
    d = new ka({ vertexColors: 2, depthTest: false, depthWrite: false, transparent: true });
    ma.call(this, c, d);
    this.root = a;
    this.bones = b;
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  function ld(a, b, c) {
    this.light = a;
    this.light.updateMatrixWorld();
    this.color = c;
    a = new hc(b, 4, 2);
    b = new Pa({ wireframe: true, fog: false });
    ca.call(this, a, b);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  function md(a, b, c) {
    D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = c;
    a = new dc(b);
    a.rotateY(0.5 * Math.PI);
    this.material = new Pa({ wireframe: true, fog: false });
    void 0 === this.color && (this.material.vertexColors = 2);
    b = a.getAttribute("position");
    b = new Float32Array(3 * b.count);
    a.setAttribute("color", new M(b, 3));
    this.add(new ca(a, this.material));
    this.update();
  }
  function wf(a, b, c, d) {
    a = a || 10;
    b = b || 10;
    c = new B(void 0 !== c ? c : 4473924);
    d = new B(void 0 !== d ? d : 8947848);
    var e = b / 2, f = a / b, g = a / 2;
    a = [];
    for (var k = [], l = 0, m = 0, h2 = -g; l <= b; l++, h2 += f) {
      a.push(-g, 0, h2, g, 0, h2);
      a.push(h2, 0, -g, h2, 0, g);
      var p = l === e ? c : d;
      p.toArray(k, m);
      m += 3;
      p.toArray(k, m);
      m += 3;
      p.toArray(k, m);
      m += 3;
      p.toArray(k, m);
      m += 3;
    }
    b = new A();
    b.setAttribute("position", new E(a, 3));
    b.setAttribute(
      "color",
      new E(k, 3)
    );
    c = new ka({ vertexColors: 2 });
    ma.call(this, b, c);
  }
  function xf(a, b, c, d, e, f) {
    a = a || 10;
    b = b || 16;
    c = c || 8;
    d = d || 64;
    e = new B(void 0 !== e ? e : 4473924);
    f = new B(void 0 !== f ? f : 8947848);
    var g = [], k = [], l;
    for (l = 0; l <= b; l++) {
      var m = l / b * 2 * Math.PI;
      var h2 = Math.sin(m) * a;
      m = Math.cos(m) * a;
      g.push(0, 0, 0);
      g.push(h2, 0, m);
      var p = l & 1 ? e : f;
      k.push(p.r, p.g, p.b);
      k.push(p.r, p.g, p.b);
    }
    for (l = 0; l <= c; l++) {
      p = l & 1 ? e : f;
      var q = a - a / c * l;
      for (b = 0; b < d; b++) m = b / d * 2 * Math.PI, h2 = Math.sin(m) * q, m = Math.cos(m) * q, g.push(h2, 0, m), k.push(p.r, p.g, p.b), m = (b + 1) / d * 2 * Math.PI, h2 = Math.sin(m) * q, m = Math.cos(m) * q, g.push(h2, 0, m), k.push(p.r, p.g, p.b);
    }
    a = new A();
    a.setAttribute("position", new E(g, 3));
    a.setAttribute("color", new E(k, 3));
    g = new ka({ vertexColors: 2 });
    ma.call(this, a, g);
  }
  function nd(a, b, c) {
    D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = c;
    void 0 === b && (b = 1);
    a = new A();
    a.setAttribute("position", new E([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
    b = new ka({ fog: false });
    this.lightPlane = new La(a, b);
    this.add(this.lightPlane);
    a = new A();
    a.setAttribute("position", new E([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new La(a, b);
    this.add(this.targetLine);
    this.update();
  }
  function ve(a) {
    function b(a2, b2, d2) {
      c(a2, d2);
      c(b2, d2);
    }
    function c(a2, b2) {
      f.push(0, 0, 0);
      g.push(b2.r, b2.g, b2.b);
      void 0 === k[a2] && (k[a2] = []);
      k[a2].push(f.length / 3 - 1);
    }
    var d = new A(), e = new ka({ color: 16777215, vertexColors: 1 }), f = [], g = [], k = {}, l = new B(16755200), m = new B(16711680), h2 = new B(43775), p = new B(16777215), q = new B(3355443);
    b("n1", "n2", l);
    b("n2", "n4", l);
    b("n4", "n3", l);
    b("n3", "n1", l);
    b("f1", "f2", l);
    b("f2", "f4", l);
    b("f4", "f3", l);
    b("f3", "f1", l);
    b("n1", "f1", l);
    b("n2", "f2", l);
    b("n3", "f3", l);
    b("n4", "f4", l);
    b("p", "n1", m);
    b("p", "n2", m);
    b("p", "n3", m);
    b("p", "n4", m);
    b("u1", "u2", h2);
    b("u2", "u3", h2);
    b("u3", "u1", h2);
    b("c", "t", p);
    b("p", "c", q);
    b("cn1", "cn2", q);
    b("cn3", "cn4", q);
    b("cf1", "cf2", q);
    b("cf3", "cf4", q);
    d.setAttribute("position", new E(f, 3));
    d.setAttribute("color", new E(g, 3));
    ma.call(this, d, e);
    this.camera = a;
    this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
    this.matrix = a.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = k;
    this.update();
  }
  function na(a, b, c, d, e, f, g) {
    yf.set(e, f, g).unproject(d);
    a = b[a];
    if (void 0 !== a) for (c = c.getAttribute("position"), b = 0, d = a.length; b < d; b++) c.setXYZ(a[b], yf.x, yf.y, yf.z);
  }
  function xb(a, b) {
    this.object = a;
    void 0 === b && (b = 16776960);
    a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var c = new Float32Array(24), d = new A();
    d.setIndex(new M(a, 1));
    d.setAttribute("position", new M(c, 3));
    ma.call(this, d, new ka({ color: b }));
    this.matrixAutoUpdate = false;
    this.update();
  }
  function we(a, b) {
    this.type = "Box3Helper";
    this.box = a;
    b = b || 16776960;
    a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var c = new A();
    c.setIndex(new M(a, 1));
    c.setAttribute("position", new E([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3));
    ma.call(this, c, new ka({ color: b }));
    this.geometry.computeBoundingSphere();
  }
  function xe(a, b, c) {
    this.type = "PlaneHelper";
    this.plane = a;
    this.size = void 0 === b ? 1 : b;
    a = void 0 !== c ? c : 16776960;
    b = new A();
    b.setAttribute("position", new E([
      1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      0,
      0,
      0
    ], 3));
    b.computeBoundingSphere();
    La.call(this, b, new ka({ color: a }));
    b = new A();
    b.setAttribute("position", new E([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3));
    b.computeBoundingSphere();
    this.add(new ca(b, new Pa({ color: a, opacity: 0.2, transparent: true, depthWrite: false })));
  }
  function yb(a, b, c, d, e, f) {
    D.call(this);
    void 0 === a && (a = new n(0, 0, 1));
    void 0 === b && (b = new n(0, 0, 0));
    void 0 === c && (c = 1);
    void 0 === d && (d = 16776960);
    void 0 === e && (e = 0.2 * c);
    void 0 === f && (f = 0.2 * e);
    void 0 === zf && (zf = new A(), zf.setAttribute("position", new E([0, 0, 0, 0, 1, 0], 3)), Tg = new ub(0, 0.5, 1, 5, 1), Tg.translate(0, -0.5, 0));
    this.position.copy(b);
    this.line = new La(zf, new ka({ color: d }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new ca(Tg, new Pa({ color: d }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(a);
    this.setLength(c, e, f);
  }
  function ye(a) {
    a = a || 1;
    var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
    a = new A();
    a.setAttribute("position", new E(b, 3));
    a.setAttribute("color", new E([
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], 3));
    b = new ka({ vertexColors: 2 });
    ma.call(this, a, b);
  }
  function Ug(a) {
    Y = a;
    Vg(Af);
  }
  function ui(a) {
    var b = { magFilter: 1003, minFilter: 1003, generateMipmaps: false, type: a ? a.type : 1009, format: a ? a.format : 1023, encoding: a ? a.encoding : 3002, depthBuffer: false, stencilBuffer: false }, c = vi(b);
    c.depthBuffer = a ? false : true;
    Bf = vi(b);
    return c;
  }
  function wi(a) {
    Bf.dispose();
    Y.setRenderTarget(Wg);
    a.scissorTest = false;
    a.setSize(a.width, a.height);
  }
  function Vg(a) {
    var b = new pb();
    b.add(new ca(ze[0], a));
    Y.compile(b, Xg);
  }
  function vi(a) {
    a = new wa(3 * lb, 3 * lb, a);
    a.texture.mapping = 306;
    a.texture.name = "PMREM.cubeUv";
    a.scissorTest = true;
    return a;
  }
  function Yg(a, b, c, d, e) {
    a.viewport.set(b, c, d, e);
    a.scissor.set(b, c, d, e);
  }
  function xi(a) {
    var b = Y.autoClear;
    Y.autoClear = false;
    for (var c = 1; c < yi; c++) zi(a, c - 1, c, Math.sqrt(Cf[c] * Cf[c] - Cf[c - 1] * Cf[c - 1]), Ai[(c - 1) % Ai.length]);
    Y.autoClear = b;
  }
  function zi(a, b, c, d, e) {
    Bi(a, Bf, b, c, d, "latitudinal", e);
    Bi(Bf, a, c, c, d, "longitudinal", e);
  }
  function Bi(a, b, c, d, e, f, g) {
    "latitudinal" !== f && "longitudinal" !== f && console.error("blur direction must be either latitudinal or longitudinal!");
    var k = new pb();
    k.add(new ca(ze[d], Af));
    var l = Af.uniforms, m = Ci[c] - 1;
    m = isFinite(e) ? Math.PI / (2 * m) : 2 * Math.PI / 39;
    var h2 = e / m, p = isFinite(e) ? 1 + Math.floor(3 * h2) : 20;
    20 < p && console.warn("sigmaRadians, " + e + ", is too large and will clip, as it requested " + p + " samples when the maximum is set to 20");
    e = [];
    for (var q = 0, n2 = 0; 20 > n2; ++n2) {
      var r = n2 / h2;
      r = Math.exp(-r * r / 2);
      e.push(r);
      0 == n2 ? q += r : n2 < p && (q += 2 * r);
    }
    for (n2 = 0; n2 < e.length; n2++) e[n2] /= q;
    l.envMap.value = a.texture;
    l.samples.value = p;
    l.weights.value = e;
    l.latitudinal.value = "latitudinal" === f;
    g && (l.poleAxis.value = g);
    l.dTheta.value = m;
    l.mipInt.value = 8 - c;
    l.inputEncoding.value = mb[a.texture.encoding];
    l.outputEncoding.value = mb[a.texture.encoding];
    a = Ci[d];
    r = 3 * Math.max(0, lb - 2 * a);
    Yg(b, r, (0 === d ? 0 : 2 * lb) + 2 * a * (4 < d ? d - 8 + 4 : 0), 3 * a, 2 * a);
    Y.setRenderTarget(b);
    Y.render(k, Xg);
  }
  function Di() {
    var a = new w(1, 1);
    a = new vb({
      uniforms: { envMap: { value: null }, texelSize: { value: a }, inputEncoding: { value: mb[3e3] }, outputEncoding: { value: mb[3e3] } },
      vertexShader: Zg(),
      fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n" + $g() + "\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n	gl_FragColor = vec4(0.0);\n	vec3 outputDirection = normalize(vOutputDirection);\n	vec2 uv;\n	uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n	uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n	vec2 f = fract(uv / texelSize - 0.5);\n	uv -= f * texelSize;\n	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n	uv.x += texelSize.x;\n	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n	uv.y += texelSize.y;\n	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n	uv.x -= texelSize.x;\n	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n	vec3 tm = mix(tl, tr, f.x);\n	vec3 bm = mix(bl, br, f.x);\n	gl_FragColor.rgb = mix(tm, bm, f.y);\n	gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n		",
      blending: 0,
      depthTest: false,
      depthWrite: false
    });
    a.type = "EquirectangularToCubeUV";
    return a;
  }
  function Ei() {
    var a = new vb({
      uniforms: { envMap: { value: null }, inputEncoding: { value: mb[3e3] }, outputEncoding: { value: mb[3e3] } },
      vertexShader: Zg(),
      fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n" + $g() + "\n\nvoid main() {\n	gl_FragColor = vec4(0.0);\n	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n	gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n		",
      blending: 0,
      depthTest: false,
      depthWrite: false
    });
    a.type = "CubemapToCubeUV";
    return a;
  }
  function Zg() {
    return "\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n	uv = 2.0 * uv - 1.0;\n	vec3 direction = vec3(uv, 1.0);\n	if (face == 0.0) {\n		direction = direction.zyx;\n		direction.z *= -1.0;\n	} else if (face == 1.0) {\n		direction = direction.xzy;\n		direction.z *= -1.0;\n	} else if (face == 3.0) {\n		direction = direction.zyx;\n		direction.x *= -1.0;\n	} else if (face == 4.0) {\n		direction = direction.xzy;\n		direction.y *= -1.0;\n	} else if (face == 5.0) {\n		direction.xz *= -1.0;\n	}\n	return direction;\n}\nvoid main() {\n	vOutputDirection = getDirection(uv, faceIndex);\n	gl_Position = vec4( position, 1.0 );\n}\n	";
  }
  function $g() {
    return "\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n	if(inputEncoding == 0){\n		return value;\n	}else if(inputEncoding == 1){\n		return sRGBToLinear(value);\n	}else if(inputEncoding == 2){\n		return RGBEToLinear(value);\n	}else if(inputEncoding == 3){\n		return RGBMToLinear(value, 7.0);\n	}else if(inputEncoding == 4){\n		return RGBMToLinear(value, 16.0);\n	}else if(inputEncoding == 5){\n		return RGBDToLinear(value, 256.0);\n	}else{\n		return GammaToLinear(value, 2.2);\n	}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n	if(outputEncoding == 0){\n		return value;\n	}else if(outputEncoding == 1){\n		return LinearTosRGB(value);\n	}else if(outputEncoding == 2){\n		return LinearToRGBE(value);\n	}else if(outputEncoding == 3){\n		return LinearToRGBM(value, 7.0);\n	}else if(outputEncoding == 4){\n		return LinearToRGBM(value, 16.0);\n	}else if(outputEncoding == 5){\n		return LinearToRGBD(value, 256.0);\n	}else{\n		return LinearToGamma(value, 2.2);\n	}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n	return inputTexelToLinear(color);\n}\n	";
  }
  function Fi(a) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    Aa.call(this, a);
    this.type = "catmullrom";
    this.closed = true;
  }
  function Gi(a) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    Aa.call(this, a);
    this.type = "catmullrom";
  }
  function ah(a) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    Aa.call(this, a);
    this.type = "catmullrom";
  }
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(
    2,
    -52
  ));
  void 0 === Number.isInteger && (Number.isInteger = function(a) {
    return "number" === typeof a && isFinite(a) && Math.floor(a) === a;
  });
  void 0 === Math.sign && (Math.sign = function(a) {
    return 0 > a ? -1 : 0 < a ? 1 : +a;
  });
  false === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", { get: function() {
    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
  } });
  void 0 === Object.assign && (Object.assign = function(a) {
    if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
    for (var b = Object(a), c = 1; c < arguments.length; c++) {
      var d = arguments[c];
      if (void 0 !== d && null !== d) for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e]);
    }
    return b;
  });
  Object.assign(Fa.prototype, { addEventListener: function(a, b) {
    void 0 === this._listeners && (this._listeners = {});
    var c = this._listeners;
    void 0 === c[a] && (c[a] = []);
    -1 === c[a].indexOf(b) && c[a].push(b);
  }, hasEventListener: function(a, b) {
    if (void 0 === this._listeners) return false;
    var c = this._listeners;
    return void 0 !== c[a] && -1 !== c[a].indexOf(b);
  }, removeEventListener: function(a, b) {
    void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b, 1)));
  }, dispatchEvent: function(a) {
    if (void 0 !== this._listeners) {
      var b = this._listeners[a.type];
      if (void 0 !== b) {
        a.target = this;
        b = b.slice(0);
        for (var c = 0, d = b.length; c < d; c++) b[c].call(this, a);
      }
    }
  } });
  for (var ya = [], Ae = 0; 256 > Ae; Ae++) ya[Ae] = (16 > Ae ? "0" : "") + Ae.toString(16);
  var P = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function() {
    var a = 4294967295 * Math.random() | 0, b = 4294967295 * Math.random() | 0, c = 4294967295 * Math.random() | 0, d = 4294967295 * Math.random() | 0;
    return (ya[a & 255] + ya[a >> 8 & 255] + ya[a >> 16 & 255] + ya[a >> 24 & 255] + "-" + ya[b & 255] + ya[b >> 8 & 255] + "-" + ya[b >> 16 & 15 | 64] + ya[b >> 24 & 255] + "-" + ya[c & 63 | 128] + ya[c >> 8 & 255] + "-" + ya[c >> 16 & 255] + ya[c >> 24 & 255] + ya[d & 255] + ya[d >> 8 & 255] + ya[d >> 16 & 255] + ya[d >> 24 & 255]).toUpperCase();
  }, clamp: function(a, b, c) {
    return Math.max(b, Math.min(c, a));
  }, euclideanModulo: function(a, b) {
    return (a % b + b) % b;
  }, mapLinear: function(a, b, c, d, e) {
    return d + (a - b) * (e - d) / (c - b);
  }, lerp: function(a, b, c) {
    return (1 - c) * a + c * b;
  }, smoothstep: function(a, b, c) {
    if (a <= b) return 0;
    if (a >= c) return 1;
    a = (a - b) / (c - b);
    return a * a * (3 - 2 * a);
  }, smootherstep: function(a, b, c) {
    if (a <= b) return 0;
    if (a >= c) return 1;
    a = (a - b) / (c - b);
    return a * a * a * (a * (6 * a - 15) + 10);
  }, randInt: function(a, b) {
    return a + Math.floor(Math.random() * (b - a + 1));
  }, randFloat: function(a, b) {
    return a + Math.random() * (b - a);
  }, randFloatSpread: function(a) {
    return a * (0.5 - Math.random());
  }, degToRad: function(a) {
    return a * P.DEG2RAD;
  }, radToDeg: function(a) {
    return a * P.RAD2DEG;
  }, isPowerOfTwo: function(a) {
    return 0 === (a & a - 1) && 0 !== a;
  }, ceilPowerOfTwo: function(a) {
    return Math.pow(
      2,
      Math.ceil(Math.log(a) / Math.LN2)
    );
  }, floorPowerOfTwo: function(a) {
    return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
  }, setQuaternionFromProperEuler: function(a, b, c, d, e) {
    var f = Math.cos, g = Math.sin, k = f(c / 2);
    c = g(c / 2);
    var l = f((b + d) / 2), m = g((b + d) / 2), h2 = f((b - d) / 2), p = g((b - d) / 2);
    f = f((d - b) / 2);
    b = g((d - b) / 2);
    "XYX" === e ? a.set(k * m, c * h2, c * p, k * l) : "YZY" === e ? a.set(c * p, k * m, c * h2, k * l) : "ZXZ" === e ? a.set(c * h2, c * p, k * m, k * l) : "XZX" === e ? a.set(k * m, c * b, c * f, k * l) : "YXY" === e ? a.set(c * f, k * m, c * b, k * l) : "ZYZ" === e ? a.set(c * b, c * f, k * m, k * l) : console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.");
  } };
  Object.defineProperties(w.prototype, { width: { get: function() {
    return this.x;
  }, set: function(a) {
    this.x = a;
  } }, height: { get: function() {
    return this.y;
  }, set: function(a) {
    this.y = a;
  } } });
  Object.assign(w.prototype, {
    isVector2: true,
    set: function(a, b) {
      this.x = a;
      this.y = b;
      return this;
    },
    setScalar: function(a) {
      this.y = this.x = a;
      return this;
    },
    setX: function(a) {
      this.x = a;
      return this;
    },
    setY: function(a) {
      this.y = a;
      return this;
    },
    setComponent: function(a, b) {
      switch (a) {
        case 0:
          this.x = b;
          break;
        case 1:
          this.y = b;
          break;
        default:
          throw Error("index is out of range: " + a);
      }
      return this;
    },
    getComponent: function(a) {
      switch (a) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw Error("index is out of range: " + a);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y);
    },
    copy: function(a) {
      this.x = a.x;
      this.y = a.y;
      return this;
    },
    add: function(a, b) {
      if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
      this.x += a.x;
      this.y += a.y;
      return this;
    },
    addScalar: function(a) {
      this.x += a;
      this.y += a;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    },
    addScaledVector: function(a, b) {
      this.x += a.x * b;
      this.y += a.y * b;
      return this;
    },
    sub: function(a, b) {
      if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
      this.x -= a.x;
      this.y -= a.y;
      return this;
    },
    subScalar: function(a) {
      this.x -= a;
      this.y -= a;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    },
    multiply: function(a) {
      this.x *= a.x;
      this.y *= a.y;
      return this;
    },
    multiplyScalar: function(a) {
      this.x *= a;
      this.y *= a;
      return this;
    },
    divide: function(a) {
      this.x /= a.x;
      this.y /= a.y;
      return this;
    },
    divideScalar: function(a) {
      return this.multiplyScalar(1 / a);
    },
    applyMatrix3: function(a) {
      var b = this.x, c = this.y;
      a = a.elements;
      this.x = a[0] * b + a[3] * c + a[6];
      this.y = a[1] * b + a[4] * c + a[7];
      return this;
    },
    min: function(a) {
      this.x = Math.min(this.x, a.x);
      this.y = Math.min(this.y, a.y);
      return this;
    },
    max: function(a) {
      this.x = Math.max(this.x, a.x);
      this.y = Math.max(this.y, a.y);
      return this;
    },
    clamp: function(a, b) {
      this.x = Math.max(a.x, Math.min(b.x, this.x));
      this.y = Math.max(a.y, Math.min(b.y, this.y));
      return this;
    },
    clampScalar: function(a, b) {
      this.x = Math.max(a, Math.min(b, this.x));
      this.y = Math.max(a, Math.min(b, this.y));
      return this;
    },
    clampLength: function(a, b) {
      var c = this.length();
      return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    roundToZero: function() {
      this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    },
    dot: function(a) {
      return this.x * a.x + this.y * a.y;
    },
    cross: function(a) {
      return this.x * a.y - this.y * a.x;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    angle: function() {
      var a = Math.atan2(this.y, this.x);
      0 > a && (a += 2 * Math.PI);
      return a;
    },
    distanceTo: function(a) {
      return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
      var b = this.x - a.x;
      a = this.y - a.y;
      return b * b + a * a;
    },
    manhattanDistanceTo: function(a) {
      return Math.abs(this.x - a.x) + Math.abs(this.y - a.y);
    },
    setLength: function(a) {
      return this.normalize().multiplyScalar(a);
    },
    lerp: function(a, b) {
      this.x += (a.x - this.x) * b;
      this.y += (a.y - this.y) * b;
      return this;
    },
    lerpVectors: function(a, b, c) {
      return this.subVectors(b, a).multiplyScalar(c).add(a);
    },
    equals: function(a) {
      return a.x === this.x && a.y === this.y;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this.x = a[b];
      this.y = a[b + 1];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this.x;
      a[b + 1] = this.y;
      return a;
    },
    fromBufferAttribute: function(a, b, c) {
      void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
      this.x = a.getX(b);
      this.y = a.getY(b);
      return this;
    },
    rotateAround: function(a, b) {
      var c = Math.cos(b);
      b = Math.sin(b);
      var d = this.x - a.x, e = this.y - a.y;
      this.x = d * c - e * b + a.x;
      this.y = d * b + e * c + a.y;
      return this;
    }
  });
  Object.assign(za.prototype, { isMatrix3: true, set: function(a, b, c, d, e, f, g, k, l) {
    var m = this.elements;
    m[0] = a;
    m[1] = d;
    m[2] = g;
    m[3] = b;
    m[4] = e;
    m[5] = k;
    m[6] = c;
    m[7] = f;
    m[8] = l;
    return this;
  }, identity: function() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }, clone: function() {
    return new this.constructor().fromArray(this.elements);
  }, copy: function(a) {
    var b = this.elements;
    a = a.elements;
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    return this;
  }, setFromMatrix4: function(a) {
    a = a.elements;
    this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
    return this;
  }, multiply: function(a) {
    return this.multiplyMatrices(this, a);
  }, premultiply: function(a) {
    return this.multiplyMatrices(a, this);
  }, multiplyMatrices: function(a, b) {
    var c = a.elements, d = b.elements;
    b = this.elements;
    a = c[0];
    var e = c[3], f = c[6], g = c[1], k = c[4], l = c[7], m = c[2], h2 = c[5];
    c = c[8];
    var p = d[0], q = d[3], n2 = d[6], r = d[1], u = d[4], y = d[7], v = d[2], w2 = d[5];
    d = d[8];
    b[0] = a * p + e * r + f * v;
    b[3] = a * q + e * u + f * w2;
    b[6] = a * n2 + e * y + f * d;
    b[1] = g * p + k * r + l * v;
    b[4] = g * q + k * u + l * w2;
    b[7] = g * n2 + k * y + l * d;
    b[2] = m * p + h2 * r + c * v;
    b[5] = m * q + h2 * u + c * w2;
    b[8] = m * n2 + h2 * y + c * d;
    return this;
  }, multiplyScalar: function(a) {
    var b = this.elements;
    b[0] *= a;
    b[3] *= a;
    b[6] *= a;
    b[1] *= a;
    b[4] *= a;
    b[7] *= a;
    b[2] *= a;
    b[5] *= a;
    b[8] *= a;
    return this;
  }, determinant: function() {
    var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], k = a[6], l = a[7];
    a = a[8];
    return b * f * a - b * g * l - c * e * a + c * g * k + d * e * l - d * f * k;
  }, getInverse: function(a, b) {
    a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
    var c = a.elements;
    a = this.elements;
    var d = c[0], e = c[1], f = c[2], g = c[3], k = c[4], l = c[5], m = c[6], h2 = c[7];
    c = c[8];
    var p = c * k - l * h2, q = l * m - c * g, n2 = h2 * g - k * m, r = d * p + e * q + f * n2;
    if (0 === r) {
      if (true === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
      console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
      return this.identity();
    }
    b = 1 / r;
    a[0] = p * b;
    a[1] = (f * h2 - c * e) * b;
    a[2] = (l * e - f * k) * b;
    a[3] = q * b;
    a[4] = (c * d - f * m) * b;
    a[5] = (f * g - l * d) * b;
    a[6] = n2 * b;
    a[7] = (e * m - h2 * d) * b;
    a[8] = (k * d - e * g) * b;
    return this;
  }, transpose: function() {
    var a = this.elements;
    var b = a[1];
    a[1] = a[3];
    a[3] = b;
    b = a[2];
    a[2] = a[6];
    a[6] = b;
    b = a[5];
    a[5] = a[7];
    a[7] = b;
    return this;
  }, getNormalMatrix: function(a) {
    return this.setFromMatrix4(a).getInverse(this).transpose();
  }, transposeIntoArray: function(a) {
    var b = this.elements;
    a[0] = b[0];
    a[1] = b[3];
    a[2] = b[6];
    a[3] = b[1];
    a[4] = b[4];
    a[5] = b[7];
    a[6] = b[2];
    a[7] = b[5];
    a[8] = b[8];
    return this;
  }, setUvTransform: function(a, b, c, d, e, f, g) {
    var k = Math.cos(e);
    e = Math.sin(e);
    this.set(c * k, c * e, -c * (k * f + e * g) + f + a, -d * e, d * k, -d * (-e * f + k * g) + g + b, 0, 0, 1);
  }, scale: function(a, b) {
    var c = this.elements;
    c[0] *= a;
    c[3] *= a;
    c[6] *= a;
    c[1] *= b;
    c[4] *= b;
    c[7] *= b;
    return this;
  }, rotate: function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    var c = this.elements, d = c[0], e = c[3], f = c[6], g = c[1], k = c[4], l = c[7];
    c[0] = b * d + a * g;
    c[3] = b * e + a * k;
    c[6] = b * f + a * l;
    c[1] = -a * d + b * g;
    c[4] = -a * e + b * k;
    c[7] = -a * f + b * l;
    return this;
  }, translate: function(a, b) {
    var c = this.elements;
    c[0] += a * c[2];
    c[3] += a * c[5];
    c[6] += a * c[8];
    c[1] += b * c[2];
    c[4] += b * c[5];
    c[7] += b * c[8];
    return this;
  }, equals: function(a) {
    var b = this.elements;
    a = a.elements;
    for (var c = 0; 9 > c; c++) if (b[c] !== a[c]) return false;
    return true;
  }, fromArray: function(a, b) {
    void 0 === b && (b = 0);
    for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
    return this;
  }, toArray: function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    var c = this.elements;
    a[b] = c[0];
    a[b + 1] = c[1];
    a[b + 2] = c[2];
    a[b + 3] = c[3];
    a[b + 4] = c[4];
    a[b + 5] = c[5];
    a[b + 6] = c[6];
    a[b + 7] = c[7];
    a[b + 8] = c[8];
    return a;
  } });
  var od, Mb = { getDataURL: function(a) {
    if ("undefined" == typeof HTMLCanvasElement) return a.src;
    if (!(a instanceof HTMLCanvasElement)) {
      void 0 === od && (od = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"));
      od.width = a.width;
      od.height = a.height;
      var b = od.getContext("2d");
      a instanceof ImageData ? b.putImageData(a, 0, 0) : b.drawImage(a, 0, 0, a.width, a.height);
      a = od;
    }
    return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", 0.6) : a.toDataURL("image/png");
  } }, pj = 0;
  Z.DEFAULT_IMAGE = void 0;
  Z.DEFAULT_MAPPING = 300;
  Z.prototype = Object.assign(
    Object.create(Fa.prototype),
    { constructor: Z, isTexture: true, updateMatrix: function() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }, clone: function() {
      return new this.constructor().copy(this);
    }, copy: function(a) {
      this.name = a.name;
      this.image = a.image;
      this.mipmaps = a.mipmaps.slice(0);
      this.mapping = a.mapping;
      this.wrapS = a.wrapS;
      this.wrapT = a.wrapT;
      this.magFilter = a.magFilter;
      this.minFilter = a.minFilter;
      this.anisotropy = a.anisotropy;
      this.format = a.format;
      this.internalFormat = a.internalFormat;
      this.type = a.type;
      this.offset.copy(a.offset);
      this.repeat.copy(a.repeat);
      this.center.copy(a.center);
      this.rotation = a.rotation;
      this.matrixAutoUpdate = a.matrixAutoUpdate;
      this.matrix.copy(a.matrix);
      this.generateMipmaps = a.generateMipmaps;
      this.premultiplyAlpha = a.premultiplyAlpha;
      this.flipY = a.flipY;
      this.unpackAlignment = a.unpackAlignment;
      this.encoding = a.encoding;
      return this;
    }, toJSON: function(a) {
      var b = void 0 === a || "string" === typeof a;
      if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
      var c = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      if (void 0 !== this.image) {
        var d = this.image;
        void 0 === d.uuid && (d.uuid = P.generateUUID());
        if (!b && void 0 === a.images[d.uuid]) {
          if (Array.isArray(d)) {
            var e = [];
            for (var f = 0, g = d.length; f < g; f++) e.push(Mb.getDataURL(d[f]));
          } else e = Mb.getDataURL(d);
          a.images[d.uuid] = { uuid: d.uuid, url: e };
        }
        c.image = d.uuid;
      }
      b || (a.textures[this.uuid] = c);
      return c;
    }, dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }, transformUv: function(a) {
      if (300 !== this.mapping) return a;
      a.applyMatrix3(this.matrix);
      if (0 > a.x || 1 < a.x) switch (this.wrapS) {
        case 1e3:
          a.x -= Math.floor(a.x);
          break;
        case 1001:
          a.x = 0 > a.x ? 0 : 1;
          break;
        case 1002:
          a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x);
      }
      if (0 > a.y || 1 < a.y) switch (this.wrapT) {
        case 1e3:
          a.y -= Math.floor(a.y);
          break;
        case 1001:
          a.y = 0 > a.y ? 0 : 1;
          break;
        case 1002:
          a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y);
      }
      this.flipY && (a.y = 1 - a.y);
      return a;
    } }
  );
  Object.defineProperty(Z.prototype, "needsUpdate", { set: function(a) {
    true === a && this.version++;
  } });
  Object.defineProperties(ia.prototype, { width: {
    get: function() {
      return this.z;
    },
    set: function(a) {
      this.z = a;
    }
  }, height: { get: function() {
    return this.w;
  }, set: function(a) {
    this.w = a;
  } } });
  Object.assign(ia.prototype, {
    isVector4: true,
    set: function(a, b, c, d) {
      this.x = a;
      this.y = b;
      this.z = c;
      this.w = d;
      return this;
    },
    setScalar: function(a) {
      this.w = this.z = this.y = this.x = a;
      return this;
    },
    setX: function(a) {
      this.x = a;
      return this;
    },
    setY: function(a) {
      this.y = a;
      return this;
    },
    setZ: function(a) {
      this.z = a;
      return this;
    },
    setW: function(a) {
      this.w = a;
      return this;
    },
    setComponent: function(a, b) {
      switch (a) {
        case 0:
          this.x = b;
          break;
        case 1:
          this.y = b;
          break;
        case 2:
          this.z = b;
          break;
        case 3:
          this.w = b;
          break;
        default:
          throw Error("index is out of range: " + a);
      }
      return this;
    },
    getComponent: function(a) {
      switch (a) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw Error("index is out of range: " + a);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(a) {
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      this.w = void 0 !== a.w ? a.w : 1;
      return this;
    },
    add: function(a, b) {
      if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
      this.x += a.x;
      this.y += a.y;
      this.z += a.z;
      this.w += a.w;
      return this;
    },
    addScalar: function(a) {
      this.x += a;
      this.y += a;
      this.z += a;
      this.w += a;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    },
    addScaledVector: function(a, b) {
      this.x += a.x * b;
      this.y += a.y * b;
      this.z += a.z * b;
      this.w += a.w * b;
      return this;
    },
    sub: function(a, b) {
      if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(
        a,
        b
      );
      this.x -= a.x;
      this.y -= a.y;
      this.z -= a.z;
      this.w -= a.w;
      return this;
    },
    subScalar: function(a) {
      this.x -= a;
      this.y -= a;
      this.z -= a;
      this.w -= a;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    },
    multiplyScalar: function(a) {
      this.x *= a;
      this.y *= a;
      this.z *= a;
      this.w *= a;
      return this;
    },
    applyMatrix4: function(a) {
      var b = this.x, c = this.y, d = this.z, e = this.w;
      a = a.elements;
      this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
      this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
      this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
      this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
      return this;
    },
    divideScalar: function(a) {
      return this.multiplyScalar(1 / a);
    },
    setAxisAngleFromQuaternion: function(a) {
      this.w = 2 * Math.acos(a.w);
      var b = Math.sqrt(1 - a.w * a.w);
      1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
      return this;
    },
    setAxisAngleFromRotationMatrix: function(a) {
      a = a.elements;
      var b = a[0];
      var c = a[4];
      var d = a[8], e = a[1], f = a[5], g = a[9];
      var k = a[2];
      var l = a[6];
      var m = a[10];
      if (0.01 > Math.abs(c - e) && 0.01 > Math.abs(d - k) && 0.01 > Math.abs(g - l)) {
        if (0.1 > Math.abs(c + e) && 0.1 > Math.abs(d + k) && 0.1 > Math.abs(g + l) && 0.1 > Math.abs(b + f + m - 3)) return this.set(1, 0, 0, 0), this;
        a = Math.PI;
        b = (b + 1) / 2;
        f = (f + 1) / 2;
        m = (m + 1) / 2;
        c = (c + e) / 4;
        d = (d + k) / 4;
        g = (g + l) / 4;
        b > f && b > m ? 0.01 > b ? (l = 0, c = k = 0.707106781) : (l = Math.sqrt(b), k = c / l, c = d / l) : f > m ? 0.01 > f ? (l = 0.707106781, k = 0, c = 0.707106781) : (k = Math.sqrt(f), l = c / k, c = g / k) : 0.01 > m ? (k = l = 0.707106781, c = 0) : (c = Math.sqrt(m), l = d / c, k = g / c);
        this.set(l, k, c, a);
        return this;
      }
      a = Math.sqrt((l - g) * (l - g) + (d - k) * (d - k) + (e - c) * (e - c));
      1e-3 > Math.abs(a) && (a = 1);
      this.x = (l - g) / a;
      this.y = (d - k) / a;
      this.z = (e - c) / a;
      this.w = Math.acos((b + f + m - 1) / 2);
      return this;
    },
    min: function(a) {
      this.x = Math.min(this.x, a.x);
      this.y = Math.min(this.y, a.y);
      this.z = Math.min(this.z, a.z);
      this.w = Math.min(this.w, a.w);
      return this;
    },
    max: function(a) {
      this.x = Math.max(this.x, a.x);
      this.y = Math.max(this.y, a.y);
      this.z = Math.max(this.z, a.z);
      this.w = Math.max(this.w, a.w);
      return this;
    },
    clamp: function(a, b) {
      this.x = Math.max(a.x, Math.min(b.x, this.x));
      this.y = Math.max(a.y, Math.min(b.y, this.y));
      this.z = Math.max(a.z, Math.min(b.z, this.z));
      this.w = Math.max(a.w, Math.min(
        b.w,
        this.w
      ));
      return this;
    },
    clampScalar: function(a, b) {
      this.x = Math.max(a, Math.min(b, this.x));
      this.y = Math.max(a, Math.min(b, this.y));
      this.z = Math.max(a, Math.min(b, this.z));
      this.w = Math.max(a, Math.min(b, this.w));
      return this;
    },
    clampLength: function(a, b) {
      var c = this.length();
      return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    },
    roundToZero: function() {
      this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    },
    dot: function(a) {
      return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(a) {
      return this.normalize().multiplyScalar(a);
    },
    lerp: function(a, b) {
      this.x += (a.x - this.x) * b;
      this.y += (a.y - this.y) * b;
      this.z += (a.z - this.z) * b;
      this.w += (a.w - this.w) * b;
      return this;
    },
    lerpVectors: function(a, b, c) {
      return this.subVectors(b, a).multiplyScalar(c).add(a);
    },
    equals: function(a) {
      return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this.x = a[b];
      this.y = a[b + 1];
      this.z = a[b + 2];
      this.w = a[b + 3];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this.x;
      a[b + 1] = this.y;
      a[b + 2] = this.z;
      a[b + 3] = this.w;
      return a;
    },
    fromBufferAttribute: function(a, b, c) {
      void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
      this.x = a.getX(b);
      this.y = a.getY(b);
      this.z = a.getZ(b);
      this.w = a.getW(b);
      return this;
    }
  });
  wa.prototype = Object.assign(Object.create(Fa.prototype), { constructor: wa, isWebGLRenderTarget: true, setSize: function(a, b) {
    if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.texture.image.width = a, this.texture.image.height = b, this.dispose();
    this.viewport.set(
      0,
      0,
      a,
      b
    );
    this.scissor.set(0, 0, a, b);
  }, clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    this.width = a.width;
    this.height = a.height;
    this.viewport.copy(a.viewport);
    this.texture = a.texture.clone();
    this.depthBuffer = a.depthBuffer;
    this.stencilBuffer = a.stencilBuffer;
    this.depthTexture = a.depthTexture;
    return this;
  }, dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  } });
  $f.prototype = Object.assign(Object.create(wa.prototype), { constructor: $f, isWebGLMultisampleRenderTarget: true, copy: function(a) {
    wa.prototype.copy.call(
      this,
      a
    );
    this.samples = a.samples;
    return this;
  } });
  Object.assign(Da, { slerp: function(a, b, c, d) {
    return c.copy(a).slerp(b, d);
  }, slerpFlat: function(a, b, c, d, e, f, g) {
    var k = c[d + 0], l = c[d + 1], m = c[d + 2];
    c = c[d + 3];
    d = e[f + 0];
    var h2 = e[f + 1], p = e[f + 2];
    e = e[f + 3];
    if (c !== e || k !== d || l !== h2 || m !== p) {
      f = 1 - g;
      var q = k * d + l * h2 + m * p + c * e, n2 = 0 <= q ? 1 : -1, r = 1 - q * q;
      r > Number.EPSILON && (r = Math.sqrt(r), q = Math.atan2(r, q * n2), f = Math.sin(f * q) / r, g = Math.sin(g * q) / r);
      n2 *= g;
      k = k * f + d * n2;
      l = l * f + h2 * n2;
      m = m * f + p * n2;
      c = c * f + e * n2;
      f === 1 - g && (g = 1 / Math.sqrt(k * k + l * l + m * m + c * c), k *= g, l *= g, m *= g, c *= g);
    }
    a[b] = k;
    a[b + 1] = l;
    a[b + 2] = m;
    a[b + 3] = c;
  } });
  Object.defineProperties(Da.prototype, { x: { get: function() {
    return this._x;
  }, set: function(a) {
    this._x = a;
    this._onChangeCallback();
  } }, y: { get: function() {
    return this._y;
  }, set: function(a) {
    this._y = a;
    this._onChangeCallback();
  } }, z: { get: function() {
    return this._z;
  }, set: function(a) {
    this._z = a;
    this._onChangeCallback();
  } }, w: { get: function() {
    return this._w;
  }, set: function(a) {
    this._w = a;
    this._onChangeCallback();
  } } });
  Object.assign(Da.prototype, { isQuaternion: true, set: function(a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._w = d;
    this._onChangeCallback();
    return this;
  }, clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }, copy: function(a) {
    this._x = a.x;
    this._y = a.y;
    this._z = a.z;
    this._w = a.w;
    this._onChangeCallback();
    return this;
  }, setFromEuler: function(a, b) {
    if (!a || !a.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    var c = a._x, d = a._y, e = a._z;
    a = a.order;
    var f = Math.cos, g = Math.sin, k = f(c / 2), l = f(d / 2);
    f = f(e / 2);
    c = g(c / 2);
    d = g(d / 2);
    e = g(e / 2);
    "XYZ" === a ? (this._x = c * l * f + k * d * e, this._y = k * d * f - c * l * e, this._z = k * l * e + c * d * f, this._w = k * l * f - c * d * e) : "YXZ" === a ? (this._x = c * l * f + k * d * e, this._y = k * d * f - c * l * e, this._z = k * l * e - c * d * f, this._w = k * l * f + c * d * e) : "ZXY" === a ? (this._x = c * l * f - k * d * e, this._y = k * d * f + c * l * e, this._z = k * l * e + c * d * f, this._w = k * l * f - c * d * e) : "ZYX" === a ? (this._x = c * l * f - k * d * e, this._y = k * d * f + c * l * e, this._z = k * l * e - c * d * f, this._w = k * l * f + c * d * e) : "YZX" === a ? (this._x = c * l * f + k * d * e, this._y = k * d * f + c * l * e, this._z = k * l * e - c * d * f, this._w = k * l * f - c * d * e) : "XZY" === a && (this._x = c * l * f - k * d * e, this._y = k * d * f - c * l * e, this._z = k * l * e + c * d * f, this._w = k * l * f + c * d * e);
    false !== b && this._onChangeCallback();
    return this;
  }, setFromAxisAngle: function(a, b) {
    b /= 2;
    var c = Math.sin(b);
    this._x = a.x * c;
    this._y = a.y * c;
    this._z = a.z * c;
    this._w = Math.cos(b);
    this._onChangeCallback();
    return this;
  }, setFromRotationMatrix: function(a) {
    var b = a.elements, c = b[0];
    a = b[4];
    var d = b[8], e = b[1], f = b[5], g = b[9], k = b[2], l = b[6];
    b = b[10];
    var m = c + f + b;
    0 < m ? (c = 0.5 / Math.sqrt(m + 1), this._w = 0.25 / c, this._x = (l - g) * c, this._y = (d - k) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (l - g) / c, this._x = 0.25 * c, this._y = (a + e) / c, this._z = (d + k) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - k) / c, this._x = (a + e) / c, this._y = 0.25 * c, this._z = (g + l) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + k) / c, this._y = (g + l) / c, this._z = 0.25 * c);
    this._onChangeCallback();
    return this;
  }, setFromUnitVectors: function(a, b) {
    var c = a.dot(b) + 1;
    1e-6 > c ? (c = 0, Math.abs(a.x) > Math.abs(a.z) ? (this._x = -a.y, this._y = a.x, this._z = 0) : (this._x = 0, this._y = -a.z, this._z = a.y)) : (this._x = a.y * b.z - a.z * b.y, this._y = a.z * b.x - a.x * b.z, this._z = a.x * b.y - a.y * b.x);
    this._w = c;
    return this.normalize();
  }, angleTo: function(a) {
    return 2 * Math.acos(Math.abs(P.clamp(this.dot(a), -1, 1)));
  }, rotateTowards: function(a, b) {
    var c = this.angleTo(a);
    if (0 === c) return this;
    this.slerp(a, Math.min(1, b / c));
    return this;
  }, inverse: function() {
    return this.conjugate();
  }, conjugate: function() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }, dot: function(a) {
    return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w;
  }, lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }, length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }, normalize: function() {
    var a = this.length();
    0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
    this._onChangeCallback();
    return this;
  }, multiply: function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(
      a,
      b
    )) : this.multiplyQuaternions(this, a);
  }, premultiply: function(a) {
    return this.multiplyQuaternions(a, this);
  }, multiplyQuaternions: function(a, b) {
    var c = a._x, d = a._y, e = a._z;
    a = a._w;
    var f = b._x, g = b._y, k = b._z;
    b = b._w;
    this._x = c * b + a * f + d * k - e * g;
    this._y = d * b + a * g + e * f - c * k;
    this._z = e * b + a * k + c * g - d * f;
    this._w = a * b - c * f - d * g - e * k;
    this._onChangeCallback();
    return this;
  }, slerp: function(a, b) {
    if (0 === b) return this;
    if (1 === b) return this.copy(a);
    var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
    0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
    if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
    a = 1 - g * g;
    if (a <= Number.EPSILON) return g = 1 - b, this._w = g * f + b * this._w, this._x = g * c + b * this._x, this._y = g * d + b * this._y, this._z = g * e + b * this._z, this.normalize(), this._onChangeCallback(), this;
    a = Math.sqrt(a);
    var k = Math.atan2(a, g);
    g = Math.sin((1 - b) * k) / a;
    b = Math.sin(b * k) / a;
    this._w = f * g + this._w * b;
    this._x = c * g + this._x * b;
    this._y = d * g + this._y * b;
    this._z = e * g + this._z * b;
    this._onChangeCallback();
    return this;
  }, equals: function(a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
  }, fromArray: function(a, b) {
    void 0 === b && (b = 0);
    this._x = a[b];
    this._y = a[b + 1];
    this._z = a[b + 2];
    this._w = a[b + 3];
    this._onChangeCallback();
    return this;
  }, toArray: function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this._x;
    a[b + 1] = this._y;
    a[b + 2] = this._z;
    a[b + 3] = this._w;
    return a;
  }, _onChange: function(a) {
    this._onChangeCallback = a;
    return this;
  }, _onChangeCallback: function() {
  } });
  var bh = new n(), Hi = new Da();
  Object.assign(n.prototype, {
    isVector3: true,
    set: function(a, b, c) {
      this.x = a;
      this.y = b;
      this.z = c;
      return this;
    },
    setScalar: function(a) {
      this.z = this.y = this.x = a;
      return this;
    },
    setX: function(a) {
      this.x = a;
      return this;
    },
    setY: function(a) {
      this.y = a;
      return this;
    },
    setZ: function(a) {
      this.z = a;
      return this;
    },
    setComponent: function(a, b) {
      switch (a) {
        case 0:
          this.x = b;
          break;
        case 1:
          this.y = b;
          break;
        case 2:
          this.z = b;
          break;
        default:
          throw Error("index is out of range: " + a);
      }
      return this;
    },
    getComponent: function(a) {
      switch (a) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw Error("index is out of range: " + a);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(a) {
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      return this;
    },
    add: function(a, b) {
      if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
      this.x += a.x;
      this.y += a.y;
      this.z += a.z;
      return this;
    },
    addScalar: function(a) {
      this.x += a;
      this.y += a;
      this.z += a;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    },
    addScaledVector: function(a, b) {
      this.x += a.x * b;
      this.y += a.y * b;
      this.z += a.z * b;
      return this;
    },
    sub: function(a, b) {
      if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
      this.x -= a.x;
      this.y -= a.y;
      this.z -= a.z;
      return this;
    },
    subScalar: function(a) {
      this.x -= a;
      this.y -= a;
      this.z -= a;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    },
    multiply: function(a, b) {
      if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
      this.x *= a.x;
      this.y *= a.y;
      this.z *= a.z;
      return this;
    },
    multiplyScalar: function(a) {
      this.x *= a;
      this.y *= a;
      this.z *= a;
      return this;
    },
    multiplyVectors: function(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    },
    applyEuler: function(a) {
      a && a.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      return this.applyQuaternion(Hi.setFromEuler(a));
    },
    applyAxisAngle: function(a, b) {
      return this.applyQuaternion(Hi.setFromAxisAngle(
        a,
        b
      ));
    },
    applyMatrix3: function(a) {
      var b = this.x, c = this.y, d = this.z;
      a = a.elements;
      this.x = a[0] * b + a[3] * c + a[6] * d;
      this.y = a[1] * b + a[4] * c + a[7] * d;
      this.z = a[2] * b + a[5] * c + a[8] * d;
      return this;
    },
    applyNormalMatrix: function(a) {
      return this.applyMatrix3(a).normalize();
    },
    applyMatrix4: function(a) {
      var b = this.x, c = this.y, d = this.z;
      a = a.elements;
      var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
      this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
      this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
      this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
      return this;
    },
    applyQuaternion: function(a) {
      var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
      a = a.w;
      var k = a * b + f * d - g * c, l = a * c + g * b - e * d, m = a * d + e * c - f * b;
      b = -e * b - f * c - g * d;
      this.x = k * a + b * -e + l * -g - m * -f;
      this.y = l * a + b * -f + m * -e - k * -g;
      this.z = m * a + b * -g + k * -f - l * -e;
      return this;
    },
    project: function(a) {
      return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix);
    },
    unproject: function(a) {
      return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld);
    },
    transformDirection: function(a) {
      var b = this.x, c = this.y, d = this.z;
      a = a.elements;
      this.x = a[0] * b + a[4] * c + a[8] * d;
      this.y = a[1] * b + a[5] * c + a[9] * d;
      this.z = a[2] * b + a[6] * c + a[10] * d;
      return this.normalize();
    },
    divide: function(a) {
      this.x /= a.x;
      this.y /= a.y;
      this.z /= a.z;
      return this;
    },
    divideScalar: function(a) {
      return this.multiplyScalar(1 / a);
    },
    min: function(a) {
      this.x = Math.min(this.x, a.x);
      this.y = Math.min(this.y, a.y);
      this.z = Math.min(this.z, a.z);
      return this;
    },
    max: function(a) {
      this.x = Math.max(this.x, a.x);
      this.y = Math.max(this.y, a.y);
      this.z = Math.max(this.z, a.z);
      return this;
    },
    clamp: function(a, b) {
      this.x = Math.max(a.x, Math.min(b.x, this.x));
      this.y = Math.max(a.y, Math.min(b.y, this.y));
      this.z = Math.max(a.z, Math.min(b.z, this.z));
      return this;
    },
    clampScalar: function(a, b) {
      this.x = Math.max(a, Math.min(b, this.x));
      this.y = Math.max(a, Math.min(b, this.y));
      this.z = Math.max(a, Math.min(b, this.z));
      return this;
    },
    clampLength: function(a, b) {
      var c = this.length();
      return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)));
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    },
    roundToZero: function() {
      this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    },
    dot: function(a) {
      return this.x * a.x + this.y * a.y + this.z * a.z;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(a) {
      return this.normalize().multiplyScalar(a);
    },
    lerp: function(a, b) {
      this.x += (a.x - this.x) * b;
      this.y += (a.y - this.y) * b;
      this.z += (a.z - this.z) * b;
      return this;
    },
    lerpVectors: function(a, b, c) {
      return this.subVectors(b, a).multiplyScalar(c).add(a);
    },
    cross: function(a, b) {
      return void 0 !== b ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b)) : this.crossVectors(this, a);
    },
    crossVectors: function(a, b) {
      var c = a.x, d = a.y;
      a = a.z;
      var e = b.x, f = b.y;
      b = b.z;
      this.x = d * b - a * f;
      this.y = a * e - c * b;
      this.z = c * f - d * e;
      return this;
    },
    projectOnVector: function(a) {
      var b = a.lengthSq();
      if (0 === b) return this.set(0, 0, 0);
      b = a.dot(this) / b;
      return this.copy(a).multiplyScalar(b);
    },
    projectOnPlane: function(a) {
      bh.copy(this).projectOnVector(a);
      return this.sub(bh);
    },
    reflect: function(a) {
      return this.sub(bh.copy(a).multiplyScalar(2 * this.dot(a)));
    },
    angleTo: function(a) {
      var b = Math.sqrt(this.lengthSq() * a.lengthSq());
      if (0 === b) return Math.PI / 2;
      a = this.dot(a) / b;
      return Math.acos(P.clamp(a, -1, 1));
    },
    distanceTo: function(a) {
      return Math.sqrt(this.distanceToSquared(a));
    },
    distanceToSquared: function(a) {
      var b = this.x - a.x, c = this.y - a.y;
      a = this.z - a.z;
      return b * b + c * c + a * a;
    },
    manhattanDistanceTo: function(a) {
      return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z);
    },
    setFromSpherical: function(a) {
      return this.setFromSphericalCoords(a.radius, a.phi, a.theta);
    },
    setFromSphericalCoords: function(a, b, c) {
      var d = Math.sin(b) * a;
      this.x = d * Math.sin(c);
      this.y = Math.cos(b) * a;
      this.z = d * Math.cos(c);
      return this;
    },
    setFromCylindrical: function(a) {
      return this.setFromCylindricalCoords(a.radius, a.theta, a.y);
    },
    setFromCylindricalCoords: function(a, b, c) {
      this.x = a * Math.sin(b);
      this.y = c;
      this.z = a * Math.cos(b);
      return this;
    },
    setFromMatrixPosition: function(a) {
      a = a.elements;
      this.x = a[12];
      this.y = a[13];
      this.z = a[14];
      return this;
    },
    setFromMatrixScale: function(a) {
      var b = this.setFromMatrixColumn(a, 0).length(), c = this.setFromMatrixColumn(a, 1).length();
      a = this.setFromMatrixColumn(a, 2).length();
      this.x = b;
      this.y = c;
      this.z = a;
      return this;
    },
    setFromMatrixColumn: function(a, b) {
      return this.fromArray(a.elements, 4 * b);
    },
    setFromMatrix3Column: function(a, b) {
      return this.fromArray(a.elements, 3 * b);
    },
    equals: function(a) {
      return a.x === this.x && a.y === this.y && a.z === this.z;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this.x = a[b];
      this.y = a[b + 1];
      this.z = a[b + 2];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this.x;
      a[b + 1] = this.y;
      a[b + 2] = this.z;
      return a;
    },
    fromBufferAttribute: function(a, b, c) {
      void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
      this.x = a.getX(b);
      this.y = a.getY(b);
      this.z = a.getZ(b);
      return this;
    }
  });
  var pd = new n(), S = new O(), Rk = new n(0, 0, 0), Sk = new n(1, 1, 1), Nb = new n(), Df = new n(), la = new n();
  Object.assign(O.prototype, { isMatrix4: true, set: function(a, b, c, d, e, f, g, k, l, m, h2, p, q, n2, r, u) {
    var x = this.elements;
    x[0] = a;
    x[4] = b;
    x[8] = c;
    x[12] = d;
    x[1] = e;
    x[5] = f;
    x[9] = g;
    x[13] = k;
    x[2] = l;
    x[6] = m;
    x[10] = h2;
    x[14] = p;
    x[3] = q;
    x[7] = n2;
    x[11] = r;
    x[15] = u;
    return this;
  }, identity: function() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }, clone: function() {
    return new O().fromArray(this.elements);
  }, copy: function(a) {
    var b = this.elements;
    a = a.elements;
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    b[4] = a[4];
    b[5] = a[5];
    b[6] = a[6];
    b[7] = a[7];
    b[8] = a[8];
    b[9] = a[9];
    b[10] = a[10];
    b[11] = a[11];
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    b[15] = a[15];
    return this;
  }, copyPosition: function(a) {
    var b = this.elements;
    a = a.elements;
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    return this;
  }, extractBasis: function(a, b, c) {
    a.setFromMatrixColumn(this, 0);
    b.setFromMatrixColumn(this, 1);
    c.setFromMatrixColumn(this, 2);
    return this;
  }, makeBasis: function(a, b, c) {
    this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
    return this;
  }, extractRotation: function(a) {
    var b = this.elements, c = a.elements, d = 1 / pd.setFromMatrixColumn(a, 0).length(), e = 1 / pd.setFromMatrixColumn(
      a,
      1
    ).length();
    a = 1 / pd.setFromMatrixColumn(a, 2).length();
    b[0] = c[0] * d;
    b[1] = c[1] * d;
    b[2] = c[2] * d;
    b[3] = 0;
    b[4] = c[4] * e;
    b[5] = c[5] * e;
    b[6] = c[6] * e;
    b[7] = 0;
    b[8] = c[8] * a;
    b[9] = c[9] * a;
    b[10] = c[10] * a;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this;
  }, makeRotationFromEuler: function(a) {
    a && a.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c);
    c = Math.sin(c);
    var g = Math.cos(d);
    d = Math.sin(d);
    var k = Math.cos(e);
    e = Math.sin(e);
    if ("XYZ" === a.order) {
      a = f * k;
      var l = f * e, m = c * k, h2 = c * e;
      b[0] = g * k;
      b[4] = -g * e;
      b[8] = d;
      b[1] = l + m * d;
      b[5] = a - h2 * d;
      b[9] = -c * g;
      b[2] = h2 - a * d;
      b[6] = m + l * d;
      b[10] = f * g;
    } else "YXZ" === a.order ? (a = g * k, l = g * e, m = d * k, h2 = d * e, b[0] = a + h2 * c, b[4] = m * c - l, b[8] = f * d, b[1] = f * e, b[5] = f * k, b[9] = -c, b[2] = l * c - m, b[6] = h2 + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * k, l = g * e, m = d * k, h2 = d * e, b[0] = a - h2 * c, b[4] = -f * e, b[8] = m + l * c, b[1] = l + m * c, b[5] = f * k, b[9] = h2 - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * k, l = f * e, m = c * k, h2 = c * e, b[0] = g * k, b[4] = m * d - l, b[8] = a * d + h2, b[1] = g * e, b[5] = h2 * d + a, b[9] = l * d - m, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, l = f * d, m = c * g, h2 = c * d, b[0] = g * k, b[4] = h2 - a * e, b[8] = m * e + l, b[1] = e, b[5] = f * k, b[9] = -c * k, b[2] = -d * k, b[6] = l * e + m, b[10] = a - h2 * e) : "XZY" === a.order && (a = f * g, l = f * d, m = c * g, h2 = c * d, b[0] = g * k, b[4] = -e, b[8] = d * k, b[1] = a * e + h2, b[5] = f * k, b[9] = l * e - m, b[2] = m * e - l, b[6] = c * k, b[10] = h2 * e + a);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this;
  }, makeRotationFromQuaternion: function(a) {
    return this.compose(Rk, a, Sk);
  }, lookAt: function(a, b, c) {
    var d = this.elements;
    la.subVectors(a, b);
    0 === la.lengthSq() && (la.z = 1);
    la.normalize();
    Nb.crossVectors(c, la);
    0 === Nb.lengthSq() && (1 === Math.abs(c.z) ? la.x += 1e-4 : la.z += 1e-4, la.normalize(), Nb.crossVectors(c, la));
    Nb.normalize();
    Df.crossVectors(la, Nb);
    d[0] = Nb.x;
    d[4] = Df.x;
    d[8] = la.x;
    d[1] = Nb.y;
    d[5] = Df.y;
    d[9] = la.y;
    d[2] = Nb.z;
    d[6] = Df.z;
    d[10] = la.z;
    return this;
  }, multiply: function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(
      a,
      b
    )) : this.multiplyMatrices(this, a);
  }, premultiply: function(a) {
    return this.multiplyMatrices(a, this);
  }, multiplyMatrices: function(a, b) {
    var c = a.elements, d = b.elements;
    b = this.elements;
    a = c[0];
    var e = c[4], f = c[8], g = c[12], k = c[1], l = c[5], m = c[9], h2 = c[13], p = c[2], q = c[6], n2 = c[10], r = c[14], u = c[3], y = c[7], v = c[11];
    c = c[15];
    var w2 = d[0], A2 = d[4], B2 = d[8], z = d[12], E2 = d[1], D2 = d[5], F2 = d[9], I2 = d[13], G = d[2], K2 = d[6], L2 = d[10], M2 = d[14], N2 = d[3], O2 = d[7], P2 = d[11];
    d = d[15];
    b[0] = a * w2 + e * E2 + f * G + g * N2;
    b[4] = a * A2 + e * D2 + f * K2 + g * O2;
    b[8] = a * B2 + e * F2 + f * L2 + g * P2;
    b[12] = a * z + e * I2 + f * M2 + g * d;
    b[1] = k * w2 + l * E2 + m * G + h2 * N2;
    b[5] = k * A2 + l * D2 + m * K2 + h2 * O2;
    b[9] = k * B2 + l * F2 + m * L2 + h2 * P2;
    b[13] = k * z + l * I2 + m * M2 + h2 * d;
    b[2] = p * w2 + q * E2 + n2 * G + r * N2;
    b[6] = p * A2 + q * D2 + n2 * K2 + r * O2;
    b[10] = p * B2 + q * F2 + n2 * L2 + r * P2;
    b[14] = p * z + q * I2 + n2 * M2 + r * d;
    b[3] = u * w2 + y * E2 + v * G + c * N2;
    b[7] = u * A2 + y * D2 + v * K2 + c * O2;
    b[11] = u * B2 + y * F2 + v * L2 + c * P2;
    b[15] = u * z + y * I2 + v * M2 + c * d;
    return this;
  }, multiplyScalar: function(a) {
    var b = this.elements;
    b[0] *= a;
    b[4] *= a;
    b[8] *= a;
    b[12] *= a;
    b[1] *= a;
    b[5] *= a;
    b[9] *= a;
    b[13] *= a;
    b[2] *= a;
    b[6] *= a;
    b[10] *= a;
    b[14] *= a;
    b[3] *= a;
    b[7] *= a;
    b[11] *= a;
    b[15] *= a;
    return this;
  }, determinant: function() {
    var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], k = a[9], l = a[13], m = a[2], h2 = a[6], p = a[10], q = a[14];
    return a[3] * (+e * k * h2 - d * l * h2 - e * g * p + c * l * p + d * g * q - c * k * q) + a[7] * (+b * k * q - b * l * p + e * f * p - d * f * q + d * l * m - e * k * m) + a[11] * (+b * l * h2 - b * g * q - e * f * h2 + c * f * q + e * g * m - c * l * m) + a[15] * (-d * g * m - b * k * h2 + b * g * p + d * f * h2 - c * f * p + c * k * m);
  }, transpose: function() {
    var a = this.elements;
    var b = a[1];
    a[1] = a[4];
    a[4] = b;
    b = a[2];
    a[2] = a[8];
    a[8] = b;
    b = a[6];
    a[6] = a[9];
    a[9] = b;
    b = a[3];
    a[3] = a[12];
    a[12] = b;
    b = a[7];
    a[7] = a[13];
    a[13] = b;
    b = a[11];
    a[11] = a[14];
    a[14] = b;
    return this;
  }, setPosition: function(a, b, c) {
    var d = this.elements;
    a.isVector3 ? (d[12] = a.x, d[13] = a.y, d[14] = a.z) : (d[12] = a, d[13] = b, d[14] = c);
    return this;
  }, getInverse: function(a, b) {
    var c = this.elements, d = a.elements;
    a = d[0];
    var e = d[1], f = d[2], g = d[3], k = d[4], l = d[5], m = d[6], h2 = d[7], p = d[8], q = d[9], n2 = d[10], r = d[11], u = d[12], y = d[13], v = d[14];
    d = d[15];
    var w2 = q * v * h2 - y * n2 * h2 + y * m * r - l * v * r - q * m * d + l * n2 * d, A2 = u * n2 * h2 - p * v * h2 - u * m * r + k * v * r + p * m * d - k * n2 * d, B2 = p * y * h2 - u * q * h2 + u * l * r - k * y * r - p * l * d + k * q * d, z = u * q * m - p * y * m - u * l * n2 + k * y * n2 + p * l * v - k * q * v, E2 = a * w2 + e * A2 + f * B2 + g * z;
    if (0 === E2) {
      if (true === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
      console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
      return this.identity();
    }
    b = 1 / E2;
    c[0] = w2 * b;
    c[1] = (y * n2 * g - q * v * g - y * f * r + e * v * r + q * f * d - e * n2 * d) * b;
    c[2] = (l * v * g - y * m * g + y * f * h2 - e * v * h2 - l * f * d + e * m * d) * b;
    c[3] = (q * m * g - l * n2 * g - q * f * h2 + e * n2 * h2 + l * f * r - e * m * r) * b;
    c[4] = A2 * b;
    c[5] = (p * v * g - u * n2 * g + u * f * r - a * v * r - p * f * d + a * n2 * d) * b;
    c[6] = (u * m * g - k * v * g - u * f * h2 + a * v * h2 + k * f * d - a * m * d) * b;
    c[7] = (k * n2 * g - p * m * g + p * f * h2 - a * n2 * h2 - k * f * r + a * m * r) * b;
    c[8] = B2 * b;
    c[9] = (u * q * g - p * y * g - u * e * r + a * y * r + p * e * d - a * q * d) * b;
    c[10] = (k * y * g - u * l * g + u * e * h2 - a * y * h2 - k * e * d + a * l * d) * b;
    c[11] = (p * l * g - k * q * g - p * e * h2 + a * q * h2 + k * e * r - a * l * r) * b;
    c[12] = z * b;
    c[13] = (p * y * f - u * q * f + u * e * n2 - a * y * n2 - p * e * v + a * q * v) * b;
    c[14] = (u * l * f - k * y * f - u * e * m + a * y * m + k * e * v - a * l * v) * b;
    c[15] = (k * q * f - p * l * f + p * e * m - a * q * m - k * e * n2 + a * l * n2) * b;
    return this;
  }, scale: function(a) {
    var b = this.elements, c = a.x, d = a.y;
    a = a.z;
    b[0] *= c;
    b[4] *= d;
    b[8] *= a;
    b[1] *= c;
    b[5] *= d;
    b[9] *= a;
    b[2] *= c;
    b[6] *= d;
    b[10] *= a;
    b[3] *= c;
    b[7] *= d;
    b[11] *= a;
    return this;
  }, getMaxScaleOnAxis: function() {
    var a = this.elements;
    return Math.sqrt(Math.max(
      a[0] * a[0] + a[1] * a[1] + a[2] * a[2],
      a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
      a[8] * a[8] + a[9] * a[9] + a[10] * a[10]
    ));
  }, makeTranslation: function(a, b, c) {
    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
    return this;
  }, makeRotationX: function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationY: function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationZ: function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }, makeRotationAxis: function(a, b) {
    var c = Math.cos(b);
    b = Math.sin(b);
    var d = 1 - c, e = a.x, f = a.y;
    a = a.z;
    var g = d * e, k = d * f;
    this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, k * f + c, k * a - b * e, 0, g * a - b * f, k * a + b * e, d * a * a + c, 0, 0, 0, 0, 1);
    return this;
  }, makeScale: function(a, b, c) {
    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
    return this;
  }, makeShear: function(a, b, c) {
    this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
    return this;
  }, compose: function(a, b, c) {
    var d = this.elements, e = b._x, f = b._y, g = b._z, k = b._w, l = e + e, m = f + f, h2 = g + g;
    b = e * l;
    var p = e * m;
    e *= h2;
    var n2 = f * m;
    f *= h2;
    g *= h2;
    l *= k;
    m *= k;
    k *= h2;
    h2 = c.x;
    var t = c.y;
    c = c.z;
    d[0] = (1 - (n2 + g)) * h2;
    d[1] = (p + k) * h2;
    d[2] = (e - m) * h2;
    d[3] = 0;
    d[4] = (p - k) * t;
    d[5] = (1 - (b + g)) * t;
    d[6] = (f + l) * t;
    d[7] = 0;
    d[8] = (e + m) * c;
    d[9] = (f - l) * c;
    d[10] = (1 - (b + n2)) * c;
    d[11] = 0;
    d[12] = a.x;
    d[13] = a.y;
    d[14] = a.z;
    d[15] = 1;
    return this;
  }, decompose: function(a, b, c) {
    var d = this.elements, e = pd.set(d[0], d[1], d[2]).length(), f = pd.set(d[4], d[5], d[6]).length(), g = pd.set(d[8], d[9], d[10]).length();
    0 > this.determinant() && (e = -e);
    a.x = d[12];
    a.y = d[13];
    a.z = d[14];
    S.copy(this);
    a = 1 / e;
    d = 1 / f;
    var k = 1 / g;
    S.elements[0] *= a;
    S.elements[1] *= a;
    S.elements[2] *= a;
    S.elements[4] *= d;
    S.elements[5] *= d;
    S.elements[6] *= d;
    S.elements[8] *= k;
    S.elements[9] *= k;
    S.elements[10] *= k;
    b.setFromRotationMatrix(S);
    c.x = e;
    c.y = f;
    c.z = g;
    return this;
  }, makePerspective: function(a, b, c, d, e, f) {
    void 0 === f && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    var g = this.elements;
    g[0] = 2 * e / (b - a);
    g[4] = 0;
    g[8] = (b + a) / (b - a);
    g[12] = 0;
    g[1] = 0;
    g[5] = 2 * e / (c - d);
    g[9] = (c + d) / (c - d);
    g[13] = 0;
    g[2] = 0;
    g[6] = 0;
    g[10] = -(f + e) / (f - e);
    g[14] = -2 * f * e / (f - e);
    g[3] = 0;
    g[7] = 0;
    g[11] = -1;
    g[15] = 0;
    return this;
  }, makeOrthographic: function(a, b, c, d, e, f) {
    var g = this.elements, k = 1 / (b - a), l = 1 / (c - d), m = 1 / (f - e);
    g[0] = 2 * k;
    g[4] = 0;
    g[8] = 0;
    g[12] = -((b + a) * k);
    g[1] = 0;
    g[5] = 2 * l;
    g[9] = 0;
    g[13] = -((c + d) * l);
    g[2] = 0;
    g[6] = 0;
    g[10] = -2 * m;
    g[14] = -((f + e) * m);
    g[3] = 0;
    g[7] = 0;
    g[11] = 0;
    g[15] = 1;
    return this;
  }, equals: function(a) {
    var b = this.elements;
    a = a.elements;
    for (var c = 0; 16 > c; c++) if (b[c] !== a[c]) return false;
    return true;
  }, fromArray: function(a, b) {
    void 0 === b && (b = 0);
    for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
    return this;
  }, toArray: function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    var c = this.elements;
    a[b] = c[0];
    a[b + 1] = c[1];
    a[b + 2] = c[2];
    a[b + 3] = c[3];
    a[b + 4] = c[4];
    a[b + 5] = c[5];
    a[b + 6] = c[6];
    a[b + 7] = c[7];
    a[b + 8] = c[8];
    a[b + 9] = c[9];
    a[b + 10] = c[10];
    a[b + 11] = c[11];
    a[b + 12] = c[12];
    a[b + 13] = c[13];
    a[b + 14] = c[14];
    a[b + 15] = c[15];
    return a;
  } });
  var Ii = new O(), Ji = new Da();
  Ub.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
  Ub.DefaultOrder = "XYZ";
  Object.defineProperties(Ub.prototype, { x: { get: function() {
    return this._x;
  }, set: function(a) {
    this._x = a;
    this._onChangeCallback();
  } }, y: {
    get: function() {
      return this._y;
    },
    set: function(a) {
      this._y = a;
      this._onChangeCallback();
    }
  }, z: { get: function() {
    return this._z;
  }, set: function(a) {
    this._z = a;
    this._onChangeCallback();
  } }, order: { get: function() {
    return this._order;
  }, set: function(a) {
    this._order = a;
    this._onChangeCallback();
  } } });
  Object.assign(Ub.prototype, { isEuler: true, set: function(a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._order = d || this._order;
    this._onChangeCallback();
    return this;
  }, clone: function() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }, copy: function(a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._order = a._order;
    this._onChangeCallback();
    return this;
  }, setFromRotationMatrix: function(a, b, c) {
    var d = P.clamp, e = a.elements;
    a = e[0];
    var f = e[4], g = e[8], k = e[1], l = e[5], m = e[9], h2 = e[2], p = e[6];
    e = e[10];
    b = b || this._order;
    "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), 0.9999999 > Math.abs(g) ? (this._x = Math.atan2(-m, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(p, l), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(m, -1, 1)), 0.9999999 > Math.abs(m) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(k, l)) : (this._y = Math.atan2(-h2, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(p, -1, 1)), 0.9999999 > Math.abs(p) ? (this._y = Math.atan2(-h2, e), this._z = Math.atan2(-f, l)) : (this._y = 0, this._z = Math.atan2(k, a))) : "ZYX" === b ? (this._y = Math.asin(-d(h2, -1, 1)), 0.9999999 > Math.abs(h2) ? (this._x = Math.atan2(p, e), this._z = Math.atan2(k, a)) : (this._x = 0, this._z = Math.atan2(-f, l))) : "YZX" === b ? (this._z = Math.asin(d(k, -1, 1)), 0.9999999 > Math.abs(k) ? (this._x = Math.atan2(-m, l), this._y = Math.atan2(-h2, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), 0.9999999 > Math.abs(f) ? (this._x = Math.atan2(p, l), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-m, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
    this._order = b;
    false !== c && this._onChangeCallback();
    return this;
  }, setFromQuaternion: function(a, b, c) {
    Ii.makeRotationFromQuaternion(a);
    return this.setFromRotationMatrix(Ii, b, c);
  }, setFromVector3: function(a, b) {
    return this.set(a.x, a.y, a.z, b || this._order);
  }, reorder: function(a) {
    Ji.setFromEuler(this);
    return this.setFromQuaternion(
      Ji,
      a
    );
  }, equals: function(a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
  }, fromArray: function(a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    void 0 !== a[3] && (this._order = a[3]);
    this._onChangeCallback();
    return this;
  }, toArray: function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this._x;
    a[b + 1] = this._y;
    a[b + 2] = this._z;
    a[b + 3] = this._order;
    return a;
  }, toVector3: function(a) {
    return a ? a.set(this._x, this._y, this._z) : new n(this._x, this._y, this._z);
  }, _onChange: function(a) {
    this._onChangeCallback = a;
    return this;
  }, _onChangeCallback: function() {
  } });
  Object.assign(ag.prototype, { set: function(a) {
    this.mask = 1 << a | 0;
  }, enable: function(a) {
    this.mask = this.mask | 1 << a | 0;
  }, enableAll: function() {
    this.mask = -1;
  }, toggle: function(a) {
    this.mask ^= 1 << a | 0;
  }, disable: function(a) {
    this.mask &= ~(1 << a | 0);
  }, disableAll: function() {
    this.mask = 0;
  }, test: function(a) {
    return 0 !== (this.mask & a.mask);
  } });
  var qj = 0, Ki = new n(), qd = new Da(), zb = new O(), Ef = new n(), Be = new n(), Tk = new n(), Uk = new Da(), Li = new n(1, 0, 0), Mi = new n(0, 1, 0), Ni = new n(0, 0, 1), Vk = { type: "added" }, Wk = { type: "removed" };
  D.DefaultUp = new n(0, 1, 0);
  D.DefaultMatrixAutoUpdate = true;
  D.prototype = Object.assign(Object.create(Fa.prototype), {
    constructor: D,
    isObject3D: true,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix4: function(a) {
      this.matrixAutoUpdate && this.updateMatrix();
      this.matrix.premultiply(a);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(a) {
      this.quaternion.premultiply(a);
      return this;
    },
    setRotationFromAxisAngle: function(a, b) {
      this.quaternion.setFromAxisAngle(a, b);
    },
    setRotationFromEuler: function(a) {
      this.quaternion.setFromEuler(a, true);
    },
    setRotationFromMatrix: function(a) {
      this.quaternion.setFromRotationMatrix(a);
    },
    setRotationFromQuaternion: function(a) {
      this.quaternion.copy(a);
    },
    rotateOnAxis: function(a, b) {
      qd.setFromAxisAngle(a, b);
      this.quaternion.multiply(qd);
      return this;
    },
    rotateOnWorldAxis: function(a, b) {
      qd.setFromAxisAngle(a, b);
      this.quaternion.premultiply(qd);
      return this;
    },
    rotateX: function(a) {
      return this.rotateOnAxis(Li, a);
    },
    rotateY: function(a) {
      return this.rotateOnAxis(
        Mi,
        a
      );
    },
    rotateZ: function(a) {
      return this.rotateOnAxis(Ni, a);
    },
    translateOnAxis: function(a, b) {
      Ki.copy(a).applyQuaternion(this.quaternion);
      this.position.add(Ki.multiplyScalar(b));
      return this;
    },
    translateX: function(a) {
      return this.translateOnAxis(Li, a);
    },
    translateY: function(a) {
      return this.translateOnAxis(Mi, a);
    },
    translateZ: function(a) {
      return this.translateOnAxis(Ni, a);
    },
    localToWorld: function(a) {
      return a.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(a) {
      return a.applyMatrix4(zb.getInverse(this.matrixWorld));
    },
    lookAt: function(a, b, c) {
      a.isVector3 ? Ef.copy(a) : Ef.set(a, b, c);
      a = this.parent;
      this.updateWorldMatrix(true, false);
      Be.setFromMatrixPosition(this.matrixWorld);
      this.isCamera || this.isLight ? zb.lookAt(Be, Ef, this.up) : zb.lookAt(Ef, Be, this.up);
      this.quaternion.setFromRotationMatrix(zb);
      a && (zb.extractRotation(a.matrixWorld), qd.setFromRotationMatrix(zb), this.quaternion.premultiply(qd.inverse()));
    },
    add: function(a) {
      if (1 < arguments.length) {
        for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
        return this;
      }
      if (a === this) return console.error(
        "THREE.Object3D.add: object can't be added as a child of itself.",
        a
      ), this;
      a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, this.children.push(a), a.dispatchEvent(Vk)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
      return this;
    },
    remove: function(a) {
      if (1 < arguments.length) {
        for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
        return this;
      }
      b = this.children.indexOf(a);
      -1 !== b && (a.parent = null, this.children.splice(b, 1), a.dispatchEvent(Wk));
      return this;
    },
    attach: function(a) {
      this.updateWorldMatrix(true, false);
      zb.getInverse(this.matrixWorld);
      null !== a.parent && (a.parent.updateWorldMatrix(true, false), zb.multiply(a.parent.matrixWorld));
      a.applyMatrix4(zb);
      a.updateWorldMatrix(false, false);
      this.add(a);
      return this;
    },
    getObjectById: function(a) {
      return this.getObjectByProperty("id", a);
    },
    getObjectByName: function(a) {
      return this.getObjectByProperty("name", a);
    },
    getObjectByProperty: function(a, b) {
      if (this[a] === b) return this;
      for (var c = 0, d = this.children.length; c < d; c++) {
        var e = this.children[c].getObjectByProperty(a, b);
        if (void 0 !== e) return e;
      }
    },
    getWorldPosition: function(a) {
      void 0 === a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new n());
      this.updateMatrixWorld(true);
      return a.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(a) {
      void 0 === a && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), a = new Da());
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(Be, a, Tk);
      return a;
    },
    getWorldScale: function(a) {
      void 0 === a && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), a = new n());
      this.updateMatrixWorld(true);
      this.matrixWorld.decompose(Be, Uk, a);
      return a;
    },
    getWorldDirection: function(a) {
      void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), a = new n());
      this.updateMatrixWorld(true);
      var b = this.matrixWorld.elements;
      return a.set(b[8], b[9], b[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(a) {
      a(this);
      for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a);
    },
    traverseVisible: function(a) {
      if (false !== this.visible) {
        a(this);
        for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a);
      }
    },
    traverseAncestors: function(a) {
      var b = this.parent;
      null !== b && (a(b), b.traverseAncestors(a));
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(a) {
      this.matrixAutoUpdate && this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, a = true;
      for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a);
    },
    updateWorldMatrix: function(a, b) {
      var c = this.parent;
      true === a && null !== c && c.updateWorldMatrix(true, false);
      this.matrixAutoUpdate && this.updateMatrix();
      null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      if (true === b) for (a = this.children, b = 0, c = a.length; b < c; b++) a[b].updateWorldMatrix(false, true);
    },
    toJSON: function(a) {
      function b(b2, c2) {
        void 0 === b2[c2.uuid] && (b2[c2.uuid] = c2.toJSON(a));
        return c2.uuid;
      }
      function c(a2) {
        var b2 = [], c2;
        for (c2 in a2) {
          var d2 = a2[c2];
          delete d2.metadata;
          b2.push(d2);
        }
        return b2;
      }
      var d = void 0 === a || "string" === typeof a, e = {};
      d && (a = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, e.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
      var f = {};
      f.uuid = this.uuid;
      f.type = this.type;
      "" !== this.name && (f.name = this.name);
      true === this.castShadow && (f.castShadow = true);
      true === this.receiveShadow && (f.receiveShadow = true);
      false === this.visible && (f.visible = false);
      false === this.frustumCulled && (f.frustumCulled = false);
      0 !== this.renderOrder && (f.renderOrder = this.renderOrder);
      "{}" !== JSON.stringify(this.userData) && (f.userData = this.userData);
      f.layers = this.layers.mask;
      f.matrix = this.matrix.toArray();
      false === this.matrixAutoUpdate && (f.matrixAutoUpdate = false);
      this.isInstancedMesh && (f.type = "InstancedMesh", f.count = this.count, f.instanceMatrix = this.instanceMatrix.toJSON());
      if (this.isMesh || this.isLine || this.isPoints) {
        f.geometry = b(a.geometries, this.geometry);
        var g = this.geometry.parameters;
        if (void 0 !== g && void 0 !== g.shapes) if (g = g.shapes, Array.isArray(g)) for (var k = 0, l = g.length; k < l; k++) b(a.shapes, g[k]);
        else b(a.shapes, g);
      }
      if (void 0 !== this.material) if (Array.isArray(this.material)) {
        g = [];
        k = 0;
        for (l = this.material.length; k < l; k++) g.push(b(a.materials, this.material[k]));
        f.material = g;
      } else f.material = b(a.materials, this.material);
      if (0 < this.children.length) for (f.children = [], k = 0; k < this.children.length; k++) f.children.push(this.children[k].toJSON(a).object);
      if (d) {
        d = c(a.geometries);
        k = c(a.materials);
        l = c(a.textures);
        var h2 = c(a.images);
        g = c(a.shapes);
        0 < d.length && (e.geometries = d);
        0 < k.length && (e.materials = k);
        0 < l.length && (e.textures = l);
        0 < h2.length && (e.images = h2);
        0 < g.length && (e.shapes = g);
      }
      e.object = f;
      return e;
    },
    clone: function(a) {
      return new this.constructor().copy(this, a);
    },
    copy: function(a, b) {
      void 0 === b && (b = true);
      this.name = a.name;
      this.up.copy(a.up);
      this.position.copy(a.position);
      this.quaternion.copy(a.quaternion);
      this.scale.copy(a.scale);
      this.matrix.copy(a.matrix);
      this.matrixWorld.copy(a.matrixWorld);
      this.matrixAutoUpdate = a.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
      this.layers.mask = a.layers.mask;
      this.visible = a.visible;
      this.castShadow = a.castShadow;
      this.receiveShadow = a.receiveShadow;
      this.frustumCulled = a.frustumCulled;
      this.renderOrder = a.renderOrder;
      this.userData = JSON.parse(JSON.stringify(a.userData));
      if (true === b) for (b = 0; b < a.children.length; b++) this.add(a.children[b].clone());
      return this;
    }
  });
  pb.prototype = Object.assign(Object.create(D.prototype), { constructor: pb, isScene: true, copy: function(a, b) {
    D.prototype.copy.call(this, a, b);
    null !== a.background && (this.background = a.background.clone());
    null !== a.environment && (this.environment = a.environment.clone());
    null !== a.fog && (this.fog = a.fog.clone());
    null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
    this.autoUpdate = a.autoUpdate;
    this.matrixAutoUpdate = a.matrixAutoUpdate;
    return this;
  }, toJSON: function(a) {
    var b = D.prototype.toJSON.call(this, a);
    null !== this.background && (b.object.background = this.background.toJSON(a));
    null !== this.environment && (b.object.environment = this.environment.toJSON(a));
    null !== this.fog && (b.object.fog = this.fog.toJSON());
    return b;
  }, dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  } });
  var Ab = [new n(), new n(), new n(), new n(), new n(), new n(), new n(), new n()], Ce = new n(), Ff = new Ta(), rd = new n(), sd = new n(), td = new n(), Ob = new n(), Pb = new n(), sc = new n(), De = new n(), Gf = new n(), Hf = new n(), Vb = new n();
  Object.assign(Ta.prototype, { isBox3: true, set: function(a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  }, setFromArray: function(a) {
    for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, k = 0, l = a.length; k < l; k += 3) {
      var h2 = a[k], n2 = a[k + 1], p = a[k + 2];
      h2 < b && (b = h2);
      n2 < c && (c = n2);
      p < d && (d = p);
      h2 > e && (e = h2);
      n2 > f && (f = n2);
      p > g && (g = p);
    }
    this.min.set(b, c, d);
    this.max.set(e, f, g);
    return this;
  }, setFromBufferAttribute: function(a) {
    for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, k = 0, l = a.count; k < l; k++) {
      var h2 = a.getX(k), n2 = a.getY(k), p = a.getZ(k);
      h2 < b && (b = h2);
      n2 < c && (c = n2);
      p < d && (d = p);
      h2 > e && (e = h2);
      n2 > f && (f = n2);
      p > g && (g = p);
    }
    this.min.set(b, c, d);
    this.max.set(e, f, g);
    return this;
  }, setFromPoints: function(a) {
    this.makeEmpty();
    for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
    return this;
  }, setFromCenterAndSize: function(a, b) {
    b = Ce.copy(b).multiplyScalar(0.5);
    this.min.copy(a).sub(b);
    this.max.copy(a).add(b);
    return this;
  }, setFromObject: function(a) {
    this.makeEmpty();
    return this.expandByObject(a);
  }, clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  }, makeEmpty: function() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }, isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }, getCenter: function(a) {
    void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new n());
    return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(0.5);
  }, getSize: function(a) {
    void 0 === a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new n());
    return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min);
  }, expandByPoint: function(a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  }, expandByVector: function(a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  }, expandByScalar: function(a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  }, expandByObject: function(a) {
    a.updateWorldMatrix(false, false);
    var b = a.geometry;
    void 0 !== b && (null === b.boundingBox && b.computeBoundingBox(), Ff.copy(b.boundingBox), Ff.applyMatrix4(a.matrixWorld), this.expandByPoint(Ff.min), this.expandByPoint(Ff.max));
    a = a.children;
    b = 0;
    for (var c = a.length; b < c; b++) this.expandByObject(a[b]);
    return this;
  }, containsPoint: function(a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? false : true;
  }, containsBox: function(a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z;
  }, getParameter: function(a, b) {
    void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new n());
    return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
  }, intersectsBox: function(a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? false : true;
  }, intersectsSphere: function(a) {
    this.clampPoint(a.center, Ce);
    return Ce.distanceToSquared(a.center) <= a.radius * a.radius;
  }, intersectsPlane: function(a) {
    if (0 < a.normal.x) {
      var b = a.normal.x * this.min.x;
      var c = a.normal.x * this.max.x;
    } else b = a.normal.x * this.max.x, c = a.normal.x * this.min.x;
    0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y);
    0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z);
    return b <= -a.constant && c >= -a.constant;
  }, intersectsTriangle: function(a) {
    if (this.isEmpty()) return false;
    this.getCenter(De);
    Gf.subVectors(this.max, De);
    rd.subVectors(a.a, De);
    sd.subVectors(a.b, De);
    td.subVectors(a.c, De);
    Ob.subVectors(sd, rd);
    Pb.subVectors(td, sd);
    sc.subVectors(rd, td);
    a = [
      0,
      -Ob.z,
      Ob.y,
      0,
      -Pb.z,
      Pb.y,
      0,
      -sc.z,
      sc.y,
      Ob.z,
      0,
      -Ob.x,
      Pb.z,
      0,
      -Pb.x,
      sc.z,
      0,
      -sc.x,
      -Ob.y,
      Ob.x,
      0,
      -Pb.y,
      Pb.x,
      0,
      -sc.y,
      sc.x,
      0
    ];
    if (!bg(a, rd, sd, td, Gf)) return false;
    a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!bg(a, rd, sd, td, Gf)) return false;
    Hf.crossVectors(Ob, Pb);
    a = [Hf.x, Hf.y, Hf.z];
    return bg(a, rd, sd, td, Gf);
  }, clampPoint: function(a, b) {
    void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new n());
    return b.copy(a).clamp(this.min, this.max);
  }, distanceToPoint: function(a) {
    return Ce.copy(a).clamp(this.min, this.max).sub(a).length();
  }, getBoundingSphere: function(a) {
    void 0 === a && console.error("THREE.Box3: .getBoundingSphere() target is now required");
    this.getCenter(a.center);
    a.radius = 0.5 * this.getSize(Ce).length();
    return a;
  }, intersect: function(a) {
    this.min.max(a.min);
    this.max.min(a.max);
    this.isEmpty() && this.makeEmpty();
    return this;
  }, union: function(a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  }, applyMatrix4: function(a) {
    if (this.isEmpty()) return this;
    Ab[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
    Ab[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
    Ab[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
    Ab[3].set(
      this.min.x,
      this.max.y,
      this.max.z
    ).applyMatrix4(a);
    Ab[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
    Ab[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(a);
    Ab[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
    Ab[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
    this.setFromPoints(Ab);
    return this;
  }, translate: function(a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  }, equals: function(a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  } });
  var Xk = new Ta();
  Object.assign(qb.prototype, { set: function(a, b) {
    this.center.copy(a);
    this.radius = b;
    return this;
  }, setFromPoints: function(a, b) {
    var c = this.center;
    void 0 !== b ? c.copy(b) : Xk.setFromPoints(a).getCenter(c);
    for (var d = b = 0, e = a.length; d < e; d++) b = Math.max(b, c.distanceToSquared(a[d]));
    this.radius = Math.sqrt(b);
    return this;
  }, clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    this.center.copy(a.center);
    this.radius = a.radius;
    return this;
  }, empty: function() {
    return 0 >= this.radius;
  }, containsPoint: function(a) {
    return a.distanceToSquared(this.center) <= this.radius * this.radius;
  }, distanceToPoint: function(a) {
    return a.distanceTo(this.center) - this.radius;
  }, intersectsSphere: function(a) {
    var b = this.radius + a.radius;
    return a.center.distanceToSquared(this.center) <= b * b;
  }, intersectsBox: function(a) {
    return a.intersectsSphere(this);
  }, intersectsPlane: function(a) {
    return Math.abs(a.distanceToPoint(this.center)) <= this.radius;
  }, clampPoint: function(a, b) {
    var c = this.center.distanceToSquared(a);
    void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new n());
    b.copy(a);
    c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
    return b;
  }, getBoundingBox: function(a) {
    void 0 === a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new Ta());
    a.set(this.center, this.center);
    a.expandByScalar(this.radius);
    return a;
  }, applyMatrix4: function(a) {
    this.center.applyMatrix4(a);
    this.radius *= a.getMaxScaleOnAxis();
    return this;
  }, translate: function(a) {
    this.center.add(a);
    return this;
  }, equals: function(a) {
    return a.center.equals(this.center) && a.radius === this.radius;
  } });
  var Bb = new n(), ch = new n(), If = new n(), Qb = new n(), dh = new n(), Jf = new n(), eh = new n();
  Object.assign(Wb.prototype, {
    set: function(a, b) {
      this.origin.copy(a);
      this.direction.copy(b);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.origin.copy(a.origin);
      this.direction.copy(a.direction);
      return this;
    },
    at: function(a, b) {
      void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new n());
      return b.copy(this.direction).multiplyScalar(a).add(this.origin);
    },
    lookAt: function(a) {
      this.direction.copy(a).sub(this.origin).normalize();
      return this;
    },
    recast: function(a) {
      this.origin.copy(this.at(a, Bb));
      return this;
    },
    closestPointToPoint: function(a, b) {
      void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new n());
      b.subVectors(a, this.origin);
      a = b.dot(this.direction);
      return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin);
    },
    distanceToPoint: function(a) {
      return Math.sqrt(this.distanceSqToPoint(a));
    },
    distanceSqToPoint: function(a) {
      var b = Bb.subVectors(a, this.origin).dot(this.direction);
      if (0 > b) return this.origin.distanceToSquared(a);
      Bb.copy(this.direction).multiplyScalar(b).add(this.origin);
      return Bb.distanceToSquared(a);
    },
    distanceSqToSegment: function(a, b, c, d) {
      ch.copy(a).add(b).multiplyScalar(0.5);
      If.copy(b).sub(a).normalize();
      Qb.copy(this.origin).sub(ch);
      var e = 0.5 * a.distanceTo(b), f = -this.direction.dot(If), g = Qb.dot(this.direction), k = -Qb.dot(If), l = Qb.lengthSq(), h2 = Math.abs(1 - f * f);
      if (0 < h2) {
        a = f * k - g;
        b = f * g - k;
        var n2 = e * h2;
        0 <= a ? b >= -n2 ? b <= n2 ? (e = 1 / h2, a *= e, b *= e, f = a * (a + f * b + 2 * g) + b * (f * a + b + 2 * k) + l) : (b = e, a = Math.max(0, -(f * b + g)), f = -a * a + b * (b + 2 * k) + l) : (b = -e, a = Math.max(0, -(f * b + g)), f = -a * a + b * (b + 2 * k) + l) : b <= -n2 ? (a = Math.max(0, -(-f * e + g)), b = 0 < a ? -e : Math.min(Math.max(-e, -k), e), f = -a * a + b * (b + 2 * k) + l) : b <= n2 ? (a = 0, b = Math.min(Math.max(-e, -k), e), f = b * (b + 2 * k) + l) : (a = Math.max(0, -(f * e + g)), b = 0 < a ? e : Math.min(Math.max(-e, -k), e), f = -a * a + b * (b + 2 * k) + l);
      } else b = 0 < f ? -e : e, a = Math.max(0, -(f * b + g)), f = -a * a + b * (b + 2 * k) + l;
      c && c.copy(this.direction).multiplyScalar(a).add(this.origin);
      d && d.copy(If).multiplyScalar(b).add(ch);
      return f;
    },
    intersectSphere: function(a, b) {
      Bb.subVectors(a.center, this.origin);
      var c = Bb.dot(this.direction), d = Bb.dot(Bb) - c * c;
      a = a.radius * a.radius;
      if (d > a) return null;
      a = Math.sqrt(a - d);
      d = c - a;
      c += a;
      return 0 > d && 0 > c ? null : 0 > d ? this.at(c, b) : this.at(d, b);
    },
    intersectsSphere: function(a) {
      return this.distanceSqToPoint(a.center) <= a.radius * a.radius;
    },
    distanceToPlane: function(a) {
      var b = a.normal.dot(this.direction);
      if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
      a = -(this.origin.dot(a.normal) + a.constant) / b;
      return 0 <= a ? a : null;
    },
    intersectPlane: function(a, b) {
      a = this.distanceToPlane(a);
      return null === a ? null : this.at(a, b);
    },
    intersectsPlane: function(a) {
      var b = a.distanceToPoint(this.origin);
      return 0 === b || 0 > a.normal.dot(this.direction) * b ? true : false;
    },
    intersectBox: function(a, b) {
      var c = 1 / this.direction.x;
      var d = 1 / this.direction.y;
      var e = 1 / this.direction.z, f = this.origin;
      if (0 <= c) {
        var g = (a.min.x - f.x) * c;
        c *= a.max.x - f.x;
      } else g = (a.max.x - f.x) * c, c *= a.min.x - f.x;
      if (0 <= d) {
        var k = (a.min.y - f.y) * d;
        d *= a.max.y - f.y;
      } else k = (a.max.y - f.y) * d, d *= a.min.y - f.y;
      if (g > d || k > c) return null;
      if (k > g || g !== g) g = k;
      if (d < c || c !== c) c = d;
      0 <= e ? (k = (a.min.z - f.z) * e, a = (a.max.z - f.z) * e) : (k = (a.max.z - f.z) * e, a = (a.min.z - f.z) * e);
      if (g > a || k > c) return null;
      if (k > g || g !== g) g = k;
      if (a < c || c !== c) c = a;
      return 0 > c ? null : this.at(0 <= g ? g : c, b);
    },
    intersectsBox: function(a) {
      return null !== this.intersectBox(a, Bb);
    },
    intersectTriangle: function(a, b, c, d, e) {
      dh.subVectors(b, a);
      Jf.subVectors(c, a);
      eh.crossVectors(dh, Jf);
      b = this.direction.dot(eh);
      if (0 < b) {
        if (d) return null;
        d = 1;
      } else if (0 > b) d = -1, b = -b;
      else return null;
      Qb.subVectors(
        this.origin,
        a
      );
      a = d * this.direction.dot(Jf.crossVectors(Qb, Jf));
      if (0 > a) return null;
      c = d * this.direction.dot(dh.cross(Qb));
      if (0 > c || a + c > b) return null;
      a = -d * Qb.dot(eh);
      return 0 > a ? null : this.at(a / b, e);
    },
    applyMatrix4: function(a) {
      this.origin.applyMatrix4(a);
      this.direction.transformDirection(a);
      return this;
    },
    equals: function(a) {
      return a.origin.equals(this.origin) && a.direction.equals(this.direction);
    }
  });
  var fh = new n(), Yk = new n(), Zk = new za();
  Object.assign(Ua.prototype, {
    isPlane: true,
    set: function(a, b) {
      this.normal.copy(a);
      this.constant = b;
      return this;
    },
    setComponents: function(a, b, c, d) {
      this.normal.set(a, b, c);
      this.constant = d;
      return this;
    },
    setFromNormalAndCoplanarPoint: function(a, b) {
      this.normal.copy(a);
      this.constant = -b.dot(this.normal);
      return this;
    },
    setFromCoplanarPoints: function(a, b, c) {
      b = fh.subVectors(c, b).cross(Yk.subVectors(a, b)).normalize();
      this.setFromNormalAndCoplanarPoint(b, a);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.normal.copy(a.normal);
      this.constant = a.constant;
      return this;
    },
    normalize: function() {
      var a = 1 / this.normal.length();
      this.normal.multiplyScalar(a);
      this.constant *= a;
      return this;
    },
    negate: function() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    },
    distanceToPoint: function(a) {
      return this.normal.dot(a) + this.constant;
    },
    distanceToSphere: function(a) {
      return this.distanceToPoint(a.center) - a.radius;
    },
    projectPoint: function(a, b) {
      void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new n());
      return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a);
    },
    intersectLine: function(a, b) {
      void 0 === b && (console.warn("THREE.Plane: .intersectLine() target is now required"), b = new n());
      var c = a.delta(fh), d = this.normal.dot(c);
      if (0 === d) {
        if (0 === this.distanceToPoint(a.start)) return b.copy(a.start);
      } else if (d = -(a.start.dot(this.normal) + this.constant) / d, !(0 > d || 1 < d)) return b.copy(c).multiplyScalar(d).add(a.start);
    },
    intersectsLine: function(a) {
      var b = this.distanceToPoint(a.start);
      a = this.distanceToPoint(a.end);
      return 0 > b && 0 < a || 0 > a && 0 < b;
    },
    intersectsBox: function(a) {
      return a.intersectsPlane(this);
    },
    intersectsSphere: function(a) {
      return a.intersectsPlane(this);
    },
    coplanarPoint: function(a) {
      void 0 === a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new n());
      return a.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function(a, b) {
      b = b || Zk.getNormalMatrix(a);
      a = this.coplanarPoint(fh).applyMatrix4(a);
      b = this.normal.applyMatrix3(b).normalize();
      this.constant = -a.dot(b);
      return this;
    },
    translate: function(a) {
      this.constant -= a.dot(this.normal);
      return this;
    },
    equals: function(a) {
      return a.normal.equals(this.normal) && a.constant === this.constant;
    }
  });
  var cb = new n(), Cb = new n(), gh = new n(), Db = new n(), ud = new n(), vd = new n(), Oi = new n(), hh = new n(), ih = new n(), jh = new n();
  Object.assign(oa, { getNormal: function(a, b, c, d) {
    void 0 === d && (console.warn("THREE.Triangle: .getNormal() target is now required"), d = new n());
    d.subVectors(c, b);
    cb.subVectors(a, b);
    d.cross(cb);
    a = d.lengthSq();
    return 0 < a ? d.multiplyScalar(1 / Math.sqrt(a)) : d.set(0, 0, 0);
  }, getBarycoord: function(a, b, c, d, e) {
    cb.subVectors(d, b);
    Cb.subVectors(c, b);
    gh.subVectors(a, b);
    a = cb.dot(cb);
    b = cb.dot(Cb);
    c = cb.dot(gh);
    var f = Cb.dot(Cb);
    d = Cb.dot(gh);
    var g = a * f - b * b;
    void 0 === e && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), e = new n());
    if (0 === g) return e.set(-2, -1, -1);
    g = 1 / g;
    f = (f * c - b * d) * g;
    a = (a * d - b * c) * g;
    return e.set(1 - f - a, a, f);
  }, containsPoint: function(a, b, c, d) {
    oa.getBarycoord(a, b, c, d, Db);
    return 0 <= Db.x && 0 <= Db.y && 1 >= Db.x + Db.y;
  }, getUV: function(a, b, c, d, e, f, g, k) {
    this.getBarycoord(a, b, c, d, Db);
    k.set(0, 0);
    k.addScaledVector(e, Db.x);
    k.addScaledVector(f, Db.y);
    k.addScaledVector(g, Db.z);
    return k;
  }, isFrontFacing: function(a, b, c, d) {
    cb.subVectors(
      c,
      b
    );
    Cb.subVectors(a, b);
    return 0 > cb.cross(Cb).dot(d) ? true : false;
  } });
  Object.assign(oa.prototype, {
    set: function(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    },
    setFromPointsAndIndices: function(a, b, c, d) {
      this.a.copy(a[b]);
      this.b.copy(a[c]);
      this.c.copy(a[d]);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.a.copy(a.a);
      this.b.copy(a.b);
      this.c.copy(a.c);
      return this;
    },
    getArea: function() {
      cb.subVectors(this.c, this.b);
      Cb.subVectors(this.a, this.b);
      return 0.5 * cb.cross(Cb).length();
    },
    getMidpoint: function(a) {
      void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new n());
      return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(a) {
      return oa.getNormal(this.a, this.b, this.c, a);
    },
    getPlane: function(a) {
      void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"), a = new Ua());
      return a.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(a, b) {
      return oa.getBarycoord(a, this.a, this.b, this.c, b);
    },
    getUV: function(a, b, c, d, e) {
      return oa.getUV(a, this.a, this.b, this.c, b, c, d, e);
    },
    containsPoint: function(a) {
      return oa.containsPoint(a, this.a, this.b, this.c);
    },
    isFrontFacing: function(a) {
      return oa.isFrontFacing(this.a, this.b, this.c, a);
    },
    intersectsBox: function(a) {
      return a.intersectsTriangle(this);
    },
    closestPointToPoint: function(a, b) {
      void 0 === b && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), b = new n());
      var c = this.a, d = this.b, e = this.c;
      ud.subVectors(d, c);
      vd.subVectors(e, c);
      hh.subVectors(a, c);
      var f = ud.dot(hh), g = vd.dot(hh);
      if (0 >= f && 0 >= g) return b.copy(c);
      ih.subVectors(a, d);
      var k = ud.dot(ih), l = vd.dot(ih);
      if (0 <= k && l <= k) return b.copy(d);
      var h2 = f * l - k * g;
      if (0 >= h2 && 0 <= f && 0 >= k) return d = f / (f - k), b.copy(c).addScaledVector(ud, d);
      jh.subVectors(a, e);
      a = ud.dot(jh);
      var x = vd.dot(jh);
      if (0 <= x && a <= x) return b.copy(e);
      f = a * g - f * x;
      if (0 >= f && 0 <= g && 0 >= x) return h2 = g / (g - x), b.copy(c).addScaledVector(vd, h2);
      g = k * x - a * l;
      if (0 >= g && 0 <= l - k && 0 <= a - x) return Oi.subVectors(e, d), h2 = (l - k) / (l - k + (a - x)), b.copy(d).addScaledVector(Oi, h2);
      e = 1 / (g + f + h2);
      d = f * e;
      h2 *= e;
      return b.copy(c).addScaledVector(ud, d).addScaledVector(vd, h2);
    },
    equals: function(a) {
      return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
    }
  });
  var Pi = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }, Ca = { h: 0, s: 0, l: 0 }, Kf = { h: 0, s: 0, l: 0 };
  Object.assign(B.prototype, {
    isColor: true,
    r: 1,
    g: 1,
    b: 1,
    set: function(a) {
      a && a.isColor ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
      return this;
    },
    setScalar: function(a) {
      this.b = this.g = this.r = a;
      return this;
    },
    setHex: function(a) {
      a = Math.floor(a);
      this.r = (a >> 16 & 255) / 255;
      this.g = (a >> 8 & 255) / 255;
      this.b = (a & 255) / 255;
      return this;
    },
    setRGB: function(a, b, c) {
      this.r = a;
      this.g = b;
      this.b = c;
      return this;
    },
    setHSL: function(a, b, c) {
      a = P.euclideanModulo(a, 1);
      b = P.clamp(b, 0, 1);
      c = P.clamp(c, 0, 1);
      0 === b ? this.r = this.g = this.b = c : (b = 0.5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r = cg(c, b, a + 1 / 3), this.g = cg(c, b, a), this.b = cg(c, b, a - 1 / 3));
      return this;
    },
    setStyle: function(a) {
      function b(b2) {
        void 0 !== b2 && 1 > parseFloat(b2) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.");
      }
      var c;
      if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
        var d = c[2];
        switch (c[1]) {
          case "rgb":
          case "rgba":
            if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255, parseInt(c[3], 10)) / 255, b(c[5]), this;
            if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(
              100,
              parseInt(c[1], 10)
            ) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100, parseInt(c[3], 10)) / 100, b(c[5]), this;
            break;
          case "hsl":
          case "hsla":
            if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
              d = parseFloat(c[1]) / 360;
              var e = parseInt(c[2], 10) / 100, f = parseInt(c[3], 10) / 100;
              b(c[5]);
              return this.setHSL(d, e, f);
            }
        }
      } else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
        c = c[1];
        d = c.length;
        if (3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
        if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this;
      }
      return a && 0 < a.length ? this.setColorName(a) : this;
    },
    setColorName: function(a) {
      var b = Pi[a];
      void 0 !== b ? this.setHex(b) : console.warn("THREE.Color: Unknown color " + a);
      return this;
    },
    clone: function() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(a) {
      this.r = a.r;
      this.g = a.g;
      this.b = a.b;
      return this;
    },
    copyGammaToLinear: function(a, b) {
      void 0 === b && (b = 2);
      this.r = Math.pow(a.r, b);
      this.g = Math.pow(a.g, b);
      this.b = Math.pow(a.b, b);
      return this;
    },
    copyLinearToGamma: function(a, b) {
      void 0 === b && (b = 2);
      b = 0 < b ? 1 / b : 1;
      this.r = Math.pow(a.r, b);
      this.g = Math.pow(a.g, b);
      this.b = Math.pow(a.b, b);
      return this;
    },
    convertGammaToLinear: function(a) {
      this.copyGammaToLinear(this, a);
      return this;
    },
    convertLinearToGamma: function(a) {
      this.copyLinearToGamma(this, a);
      return this;
    },
    copySRGBToLinear: function(a) {
      this.r = dg(a.r);
      this.g = dg(a.g);
      this.b = dg(a.b);
      return this;
    },
    copyLinearToSRGB: function(a) {
      this.r = eg(a.r);
      this.g = eg(a.g);
      this.b = eg(a.b);
      return this;
    },
    convertSRGBToLinear: function() {
      this.copySRGBToLinear(this);
      return this;
    },
    convertLinearToSRGB: function() {
      this.copyLinearToSRGB(this);
      return this;
    },
    getHex: function() {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
    },
    getHexString: function() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(a) {
      void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"), a = { h: 0, s: 0, l: 0 });
      var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, k = (f + e) / 2;
      if (f === e) f = g = 0;
      else {
        var l = e - f;
        f = 0.5 >= k ? l / (e + f) : l / (2 - e - f);
        switch (e) {
          case b:
            g = (c - d) / l + (c < d ? 6 : 0);
            break;
          case c:
            g = (d - b) / l + 2;
            break;
          case d:
            g = (b - c) / l + 4;
        }
        g /= 6;
      }
      a.h = g;
      a.s = f;
      a.l = k;
      return a;
    },
    getStyle: function() {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
    },
    offsetHSL: function(a, b, c) {
      this.getHSL(Ca);
      Ca.h += a;
      Ca.s += b;
      Ca.l += c;
      this.setHSL(Ca.h, Ca.s, Ca.l);
      return this;
    },
    add: function(a) {
      this.r += a.r;
      this.g += a.g;
      this.b += a.b;
      return this;
    },
    addColors: function(a, b) {
      this.r = a.r + b.r;
      this.g = a.g + b.g;
      this.b = a.b + b.b;
      return this;
    },
    addScalar: function(a) {
      this.r += a;
      this.g += a;
      this.b += a;
      return this;
    },
    sub: function(a) {
      this.r = Math.max(0, this.r - a.r);
      this.g = Math.max(0, this.g - a.g);
      this.b = Math.max(0, this.b - a.b);
      return this;
    },
    multiply: function(a) {
      this.r *= a.r;
      this.g *= a.g;
      this.b *= a.b;
      return this;
    },
    multiplyScalar: function(a) {
      this.r *= a;
      this.g *= a;
      this.b *= a;
      return this;
    },
    lerp: function(a, b) {
      this.r += (a.r - this.r) * b;
      this.g += (a.g - this.g) * b;
      this.b += (a.b - this.b) * b;
      return this;
    },
    lerpHSL: function(a, b) {
      this.getHSL(Ca);
      a.getHSL(Kf);
      a = P.lerp(Ca.h, Kf.h, b);
      var c = P.lerp(Ca.s, Kf.s, b);
      b = P.lerp(Ca.l, Kf.l, b);
      this.setHSL(a, c, b);
      return this;
    },
    equals: function(a) {
      return a.r === this.r && a.g === this.g && a.b === this.b;
    },
    fromArray: function(a, b) {
      void 0 === b && (b = 0);
      this.r = a[b];
      this.g = a[b + 1];
      this.b = a[b + 2];
      return this;
    },
    toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      a[b] = this.r;
      a[b + 1] = this.g;
      a[b + 2] = this.b;
      return a;
    },
    toJSON: function() {
      return this.getHex();
    }
  });
  B.NAMES = Pi;
  Object.assign(Bc.prototype, { clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    this.a = a.a;
    this.b = a.b;
    this.c = a.c;
    this.normal.copy(a.normal);
    this.color.copy(a.color);
    this.materialIndex = a.materialIndex;
    for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
    b = 0;
    for (c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
    return this;
  } });
  var rj = 0;
  K.prototype = Object.assign(Object.create(Fa.prototype), {
    constructor: K,
    isMaterial: true,
    onBeforeCompile: function() {
    },
    setValues: function(a) {
      if (void 0 !== a) for (var b in a) {
        var c = a[b];
        if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
        else if ("shading" === b) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === c ? true : false;
        else {
          var d = this[b];
          void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = c;
        }
      }
    },
    toJSON: function(a) {
      function b(a2) {
        var b2 = [], c2;
        for (c2 in a2) {
          var d2 = a2[c2];
          delete d2.metadata;
          b2.push(d2);
        }
        return b2;
      }
      var c = void 0 === a || "string" === typeof a;
      c && (a = { textures: {}, images: {} });
      var d = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
      d.uuid = this.uuid;
      d.type = this.type;
      "" !== this.name && (d.name = this.name);
      this.color && this.color.isColor && (d.color = this.color.getHex());
      void 0 !== this.roughness && (d.roughness = this.roughness);
      void 0 !== this.metalness && (d.metalness = this.metalness);
      this.sheen && this.sheen.isColor && (d.sheen = this.sheen.getHex());
      this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex());
      this.emissiveIntensity && 1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity);
      this.specular && this.specular.isColor && (d.specular = this.specular.getHex());
      void 0 !== this.shininess && (d.shininess = this.shininess);
      void 0 !== this.clearcoat && (d.clearcoat = this.clearcoat);
      void 0 !== this.clearcoatRoughness && (d.clearcoatRoughness = this.clearcoatRoughness);
      this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (d.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(a).uuid, d.clearcoatNormalScale = this.clearcoatNormalScale.toArray());
      this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
      this.matcap && this.matcap.isTexture && (d.matcap = this.matcap.toJSON(a).uuid);
      this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
      this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid);
      this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid, d.aoMapIntensity = this.aoMapIntensity);
      this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
      this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalMapType = this.normalMapType, d.normalScale = this.normalScale.toArray());
      this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias);
      this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
      this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
      this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
      this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
      this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity, d.refractionRatio = this.refractionRatio, void 0 !== this.combine && (d.combine = this.combine), void 0 !== this.envMapIntensity && (d.envMapIntensity = this.envMapIntensity));
      this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid);
      void 0 !== this.size && (d.size = this.size);
      void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
      1 !== this.blending && (d.blending = this.blending);
      true === this.flatShading && (d.flatShading = this.flatShading);
      0 !== this.side && (d.side = this.side);
      0 !== this.vertexColors && (d.vertexColors = this.vertexColors);
      1 > this.opacity && (d.opacity = this.opacity);
      true === this.transparent && (d.transparent = this.transparent);
      d.depthFunc = this.depthFunc;
      d.depthTest = this.depthTest;
      d.depthWrite = this.depthWrite;
      d.stencilWrite = this.stencilWrite;
      d.stencilWriteMask = this.stencilWriteMask;
      d.stencilFunc = this.stencilFunc;
      d.stencilRef = this.stencilRef;
      d.stencilFuncMask = this.stencilFuncMask;
      d.stencilFail = this.stencilFail;
      d.stencilZFail = this.stencilZFail;
      d.stencilZPass = this.stencilZPass;
      this.rotation && 0 !== this.rotation && (d.rotation = this.rotation);
      true === this.polygonOffset && (d.polygonOffset = true);
      0 !== this.polygonOffsetFactor && (d.polygonOffsetFactor = this.polygonOffsetFactor);
      0 !== this.polygonOffsetUnits && (d.polygonOffsetUnits = this.polygonOffsetUnits);
      this.linewidth && 1 !== this.linewidth && (d.linewidth = this.linewidth);
      void 0 !== this.dashSize && (d.dashSize = this.dashSize);
      void 0 !== this.gapSize && (d.gapSize = this.gapSize);
      void 0 !== this.scale && (d.scale = this.scale);
      true === this.dithering && (d.dithering = true);
      0 < this.alphaTest && (d.alphaTest = this.alphaTest);
      true === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha);
      true === this.wireframe && (d.wireframe = this.wireframe);
      1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
      "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap);
      "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin);
      true === this.morphTargets && (d.morphTargets = true);
      true === this.morphNormals && (d.morphNormals = true);
      true === this.skinning && (d.skinning = true);
      false === this.visible && (d.visible = false);
      false === this.toneMapped && (d.toneMapped = false);
      "{}" !== JSON.stringify(this.userData) && (d.userData = this.userData);
      c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a));
      return d;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.name = a.name;
      this.fog = a.fog;
      this.blending = a.blending;
      this.side = a.side;
      this.flatShading = a.flatShading;
      this.vertexTangents = a.vertexTangents;
      this.vertexColors = a.vertexColors;
      this.opacity = a.opacity;
      this.transparent = a.transparent;
      this.blendSrc = a.blendSrc;
      this.blendDst = a.blendDst;
      this.blendEquation = a.blendEquation;
      this.blendSrcAlpha = a.blendSrcAlpha;
      this.blendDstAlpha = a.blendDstAlpha;
      this.blendEquationAlpha = a.blendEquationAlpha;
      this.depthFunc = a.depthFunc;
      this.depthTest = a.depthTest;
      this.depthWrite = a.depthWrite;
      this.stencilWriteMask = a.stencilWriteMask;
      this.stencilFunc = a.stencilFunc;
      this.stencilRef = a.stencilRef;
      this.stencilFuncMask = a.stencilFuncMask;
      this.stencilFail = a.stencilFail;
      this.stencilZFail = a.stencilZFail;
      this.stencilZPass = a.stencilZPass;
      this.stencilWrite = a.stencilWrite;
      var b = a.clippingPlanes, c = null;
      if (null !== b) {
        var d = b.length;
        c = Array(d);
        for (var e = 0; e !== d; ++e) c[e] = b[e].clone();
      }
      this.clippingPlanes = c;
      this.clipIntersection = a.clipIntersection;
      this.clipShadows = a.clipShadows;
      this.shadowSide = a.shadowSide;
      this.colorWrite = a.colorWrite;
      this.precision = a.precision;
      this.polygonOffset = a.polygonOffset;
      this.polygonOffsetFactor = a.polygonOffsetFactor;
      this.polygonOffsetUnits = a.polygonOffsetUnits;
      this.dithering = a.dithering;
      this.alphaTest = a.alphaTest;
      this.premultipliedAlpha = a.premultipliedAlpha;
      this.visible = a.visible;
      this.toneMapped = a.toneMapped;
      this.userData = JSON.parse(JSON.stringify(a.userData));
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  Object.defineProperty(K.prototype, "needsUpdate", { set: function(a) {
    true === a && this.version++;
  } });
  Pa.prototype = Object.create(K.prototype);
  Pa.prototype.constructor = Pa;
  Pa.prototype.isMeshBasicMaterial = true;
  Pa.prototype.copy = function(a) {
    K.prototype.copy.call(
      this,
      a
    );
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    return this;
  };
  var T = new n();
  Object.defineProperty(M.prototype, "needsUpdate", { set: function(a) {
    true === a && this.version++;
  } });
  Object.assign(M.prototype, { isBufferAttribute: true, onUploadCallback: function() {
  }, setUsage: function(a) {
    this.usage = a;
    return this;
  }, copy: function(a) {
    this.name = a.name;
    this.array = new a.array.constructor(a.array);
    this.itemSize = a.itemSize;
    this.count = a.count;
    this.normalized = a.normalized;
    this.usage = a.usage;
    return this;
  }, copyAt: function(a, b, c) {
    a *= this.itemSize;
    c *= b.itemSize;
    for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
    return this;
  }, copyArray: function(a) {
    this.array.set(a);
    return this;
  }, copyColorsArray: function(a) {
    for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
      var f = a[d];
      void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new B());
      b[c++] = f.r;
      b[c++] = f.g;
      b[c++] = f.b;
    }
    return this;
  }, copyVector2sArray: function(a) {
    for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
      var f = a[d];
      void 0 === f && (console.warn(
        "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
        d
      ), f = new w());
      b[c++] = f.x;
      b[c++] = f.y;
    }
    return this;
  }, copyVector3sArray: function(a) {
    for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
      var f = a[d];
      void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new n());
      b[c++] = f.x;
      b[c++] = f.y;
      b[c++] = f.z;
    }
    return this;
  }, copyVector4sArray: function(a) {
    for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
      var f = a[d];
      void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new ia());
      b[c++] = f.x;
      b[c++] = f.y;
      b[c++] = f.z;
      b[c++] = f.w;
    }
    return this;
  }, applyMatrix3: function(a) {
    for (var b = 0, c = this.count; b < c; b++) T.x = this.getX(b), T.y = this.getY(b), T.z = this.getZ(b), T.applyMatrix3(a), this.setXYZ(b, T.x, T.y, T.z);
    return this;
  }, applyMatrix4: function(a) {
    for (var b = 0, c = this.count; b < c; b++) T.x = this.getX(b), T.y = this.getY(b), T.z = this.getZ(b), T.applyMatrix4(a), this.setXYZ(b, T.x, T.y, T.z);
    return this;
  }, applyNormalMatrix: function(a) {
    for (var b = 0, c = this.count; b < c; b++) T.x = this.getX(b), T.y = this.getY(b), T.z = this.getZ(b), T.applyNormalMatrix(a), this.setXYZ(b, T.x, T.y, T.z);
    return this;
  }, transformDirection: function(a) {
    for (var b = 0, c = this.count; b < c; b++) T.x = this.getX(b), T.y = this.getY(b), T.z = this.getZ(b), T.transformDirection(a), this.setXYZ(b, T.x, T.y, T.z);
    return this;
  }, set: function(a, b) {
    void 0 === b && (b = 0);
    this.array.set(a, b);
    return this;
  }, getX: function(a) {
    return this.array[a * this.itemSize];
  }, setX: function(a, b) {
    this.array[a * this.itemSize] = b;
    return this;
  }, getY: function(a) {
    return this.array[a * this.itemSize + 1];
  }, setY: function(a, b) {
    this.array[a * this.itemSize + 1] = b;
    return this;
  }, getZ: function(a) {
    return this.array[a * this.itemSize + 2];
  }, setZ: function(a, b) {
    this.array[a * this.itemSize + 2] = b;
    return this;
  }, getW: function(a) {
    return this.array[a * this.itemSize + 3];
  }, setW: function(a, b) {
    this.array[a * this.itemSize + 3] = b;
    return this;
  }, setXY: function(a, b, c) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = c;
    return this;
  }, setXYZ: function(a, b, c, d) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = c;
    this.array[a + 2] = d;
    return this;
  }, setXYZW: function(a, b, c, d, e) {
    a *= this.itemSize;
    this.array[a + 0] = b;
    this.array[a + 1] = c;
    this.array[a + 2] = d;
    this.array[a + 3] = e;
    return this;
  }, onUpload: function(a) {
    this.onUploadCallback = a;
    return this;
  }, clone: function() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }, toJSON: function() {
    return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
  } });
  Cd.prototype = Object.create(M.prototype);
  Cd.prototype.constructor = Cd;
  Dd.prototype = Object.create(M.prototype);
  Dd.prototype.constructor = Dd;
  Ed.prototype = Object.create(M.prototype);
  Ed.prototype.constructor = Ed;
  Fd.prototype = Object.create(M.prototype);
  Fd.prototype.constructor = Fd;
  Xb.prototype = Object.create(M.prototype);
  Xb.prototype.constructor = Xb;
  Gd.prototype = Object.create(M.prototype);
  Gd.prototype.constructor = Gd;
  Yb.prototype = Object.create(M.prototype);
  Yb.prototype.constructor = Yb;
  E.prototype = Object.create(M.prototype);
  E.prototype.constructor = E;
  Hd.prototype = Object.create(M.prototype);
  Hd.prototype.constructor = Hd;
  Object.assign(
    xh.prototype,
    { computeGroups: function(a) {
      var b = [], c = void 0;
      a = a.faces;
      for (var d = 0; d < a.length; d++) {
        var e = a[d];
        if (e.materialIndex !== c) {
          c = e.materialIndex;
          void 0 !== f && (f.count = 3 * d - f.start, b.push(f));
          var f = { start: 3 * d, materialIndex: c };
        }
      }
      void 0 !== f && (f.count = 3 * d - f.start, b.push(f));
      this.groups = b;
    }, fromGeometry: function(a) {
      var b = a.faces, c = a.vertices, d = a.faceVertexUvs, e = d[0] && 0 < d[0].length, f = d[1] && 0 < d[1].length, g = a.morphTargets, k = g.length;
      if (0 < k) {
        var l = [];
        for (var h2 = 0; h2 < k; h2++) l[h2] = { name: g[h2].name, data: [] };
        this.morphTargets.position = l;
      }
      var n2 = a.morphNormals, p = n2.length;
      if (0 < p) {
        var q = [];
        for (h2 = 0; h2 < p; h2++) q[h2] = { name: n2[h2].name, data: [] };
        this.morphTargets.normal = q;
      }
      var t = a.skinIndices, r = a.skinWeights, u = t.length === c.length, y = r.length === c.length;
      0 < c.length && 0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
      for (h2 = 0; h2 < b.length; h2++) {
        var v = b[h2];
        this.vertices.push(c[v.a], c[v.b], c[v.c]);
        var C = v.vertexNormals;
        3 === C.length ? this.normals.push(C[0], C[1], C[2]) : (C = v.normal, this.normals.push(C, C, C));
        C = v.vertexColors;
        3 === C.length ? this.colors.push(C[0], C[1], C[2]) : (C = v.color, this.colors.push(C, C, C));
        true === e && (C = d[0][h2], void 0 !== C ? this.uvs.push(C[0], C[1], C[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h2), this.uvs.push(new w(), new w(), new w())));
        true === f && (C = d[1][h2], void 0 !== C ? this.uvs2.push(C[0], C[1], C[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h2), this.uvs2.push(new w(), new w(), new w())));
        for (C = 0; C < k; C++) {
          var A2 = g[C].vertices;
          l[C].data.push(A2[v.a], A2[v.b], A2[v.c]);
        }
        for (C = 0; C < p; C++) A2 = n2[C].vertexNormals[h2], q[C].data.push(A2.a, A2.b, A2.c);
        u && this.skinIndices.push(t[v.a], t[v.b], t[v.c]);
        y && this.skinWeights.push(r[v.a], r[v.b], r[v.c]);
      }
      this.computeGroups(a);
      this.verticesNeedUpdate = a.verticesNeedUpdate;
      this.normalsNeedUpdate = a.normalsNeedUpdate;
      this.colorsNeedUpdate = a.colorsNeedUpdate;
      this.uvsNeedUpdate = a.uvsNeedUpdate;
      this.groupsNeedUpdate = a.groupsNeedUpdate;
      null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
      null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
      return this;
    } }
  );
  var sj = 1, nb = new O(), kh = new D(), wd = new n(), Oa = new Ta(), Ee = new Ta(), U = new n();
  A.prototype = Object.assign(Object.create(Fa.prototype), { constructor: A, isBufferGeometry: true, getIndex: function() {
    return this.index;
  }, setIndex: function(a) {
    Array.isArray(a) ? this.index = new (65535 < yh(a) ? Yb : Xb)(a, 1) : this.index = a;
  }, getAttribute: function(a) {
    return this.attributes[a];
  }, setAttribute: function(a, b) {
    this.attributes[a] = b;
    return this;
  }, deleteAttribute: function(a) {
    delete this.attributes[a];
    return this;
  }, addGroup: function(a, b, c) {
    this.groups.push({ start: a, count: b, materialIndex: void 0 !== c ? c : 0 });
  }, clearGroups: function() {
    this.groups = [];
  }, setDrawRange: function(a, b) {
    this.drawRange.start = a;
    this.drawRange.count = b;
  }, applyMatrix4: function(a) {
    var b = this.attributes.position;
    void 0 !== b && (b.applyMatrix4(a), b.needsUpdate = true);
    b = this.attributes.normal;
    if (void 0 !== b) {
      var c = new za().getNormalMatrix(a);
      b.applyNormalMatrix(c);
      b.needsUpdate = true;
    }
    b = this.attributes.tangent;
    void 0 !== b && (b.transformDirection(a), b.needsUpdate = true);
    null !== this.boundingBox && this.computeBoundingBox();
    null !== this.boundingSphere && this.computeBoundingSphere();
    return this;
  }, rotateX: function(a) {
    nb.makeRotationX(a);
    this.applyMatrix4(nb);
    return this;
  }, rotateY: function(a) {
    nb.makeRotationY(a);
    this.applyMatrix4(nb);
    return this;
  }, rotateZ: function(a) {
    nb.makeRotationZ(a);
    this.applyMatrix4(nb);
    return this;
  }, translate: function(a, b, c) {
    nb.makeTranslation(a, b, c);
    this.applyMatrix4(nb);
    return this;
  }, scale: function(a, b, c) {
    nb.makeScale(a, b, c);
    this.applyMatrix4(nb);
    return this;
  }, lookAt: function(a) {
    kh.lookAt(a);
    kh.updateMatrix();
    this.applyMatrix4(kh.matrix);
    return this;
  }, center: function() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(wd).negate();
    this.translate(wd.x, wd.y, wd.z);
    return this;
  }, setFromObject: function(a) {
    var b = a.geometry;
    if (a.isPoints || a.isLine) {
      a = new E(3 * b.vertices.length, 3);
      var c = new E(3 * b.colors.length, 3);
      this.setAttribute("position", a.copyVector3sArray(b.vertices));
      this.setAttribute("color", c.copyColorsArray(b.colors));
      b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new E(b.lineDistances.length, 1), this.setAttribute("lineDistance", a.copyArray(b.lineDistances)));
      null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
      null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone());
    } else a.isMesh && b && b.isGeometry && this.fromGeometry(b);
    return this;
  }, setFromPoints: function(a) {
    for (var b = [], c = 0, d = a.length; c < d; c++) {
      var e = a[c];
      b.push(e.x, e.y, e.z || 0);
    }
    this.setAttribute("position", new E(b, 3));
    return this;
  }, updateFromObject: function(a) {
    var b = a.geometry;
    if (a.isMesh) {
      var c = b.__directGeometry;
      true === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = false);
      if (void 0 === c) return this.fromGeometry(b);
      c.verticesNeedUpdate = b.verticesNeedUpdate;
      c.normalsNeedUpdate = b.normalsNeedUpdate;
      c.colorsNeedUpdate = b.colorsNeedUpdate;
      c.uvsNeedUpdate = b.uvsNeedUpdate;
      c.groupsNeedUpdate = b.groupsNeedUpdate;
      b.verticesNeedUpdate = false;
      b.normalsNeedUpdate = false;
      b.colorsNeedUpdate = false;
      b.uvsNeedUpdate = false;
      b.groupsNeedUpdate = false;
      b = c;
    }
    true === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = true), b.verticesNeedUpdate = false);
    true === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = true), b.normalsNeedUpdate = false);
    true === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = true), b.colorsNeedUpdate = false);
    b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = true), b.uvsNeedUpdate = false);
    b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = true), b.lineDistancesNeedUpdate = false);
    b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = false);
    return this;
  }, fromGeometry: function(a) {
    a.__directGeometry = new xh().fromGeometry(a);
    return this.fromDirectGeometry(a.__directGeometry);
  }, fromDirectGeometry: function(a) {
    var b = new Float32Array(3 * a.vertices.length);
    this.setAttribute("position", new M(b, 3).copyVector3sArray(a.vertices));
    0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.setAttribute("normal", new M(b, 3).copyVector3sArray(a.normals)));
    0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.setAttribute("color", new M(b, 3).copyColorsArray(a.colors)));
    0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.setAttribute("uv", new M(b, 2).copyVector2sArray(a.uvs)));
    0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.setAttribute("uv2", new M(b, 2).copyVector2sArray(a.uvs2)));
    this.groups = a.groups;
    for (var c in a.morphTargets) {
      b = [];
      for (var d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
        var g = d[e], k = new E(3 * g.data.length, 3);
        k.name = g.name;
        b.push(k.copyVector3sArray(g.data));
      }
      this.morphAttributes[c] = b;
    }
    0 < a.skinIndices.length && (c = new E(4 * a.skinIndices.length, 4), this.setAttribute("skinIndex", c.copyVector4sArray(a.skinIndices)));
    0 < a.skinWeights.length && (c = new E(4 * a.skinWeights.length, 4), this.setAttribute("skinWeight", c.copyVector4sArray(a.skinWeights)));
    null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
    null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
    return this;
  }, computeBoundingBox: function() {
    null === this.boundingBox && (this.boundingBox = new Ta());
    var a = this.attributes.position, b = this.morphAttributes.position;
    if (void 0 !== a) {
      if (this.boundingBox.setFromBufferAttribute(a), b) {
        a = 0;
        for (var c = b.length; a < c; a++) Oa.setFromBufferAttribute(b[a]), this.morphTargetsRelative ? (U.addVectors(this.boundingBox.min, Oa.min), this.boundingBox.expandByPoint(U), U.addVectors(this.boundingBox.max, Oa.max), this.boundingBox.expandByPoint(U)) : (this.boundingBox.expandByPoint(Oa.min), this.boundingBox.expandByPoint(Oa.max));
      }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }, computeBoundingSphere: function() {
    null === this.boundingSphere && (this.boundingSphere = new qb());
    var a = this.attributes.position, b = this.morphAttributes.position;
    if (a) {
      var c = this.boundingSphere.center;
      Oa.setFromBufferAttribute(a);
      if (b) for (var d = 0, e = b.length; d < e; d++) {
        var f = b[d];
        Ee.setFromBufferAttribute(f);
        this.morphTargetsRelative ? (U.addVectors(Oa.min, Ee.min), Oa.expandByPoint(U), U.addVectors(Oa.max, Ee.max), Oa.expandByPoint(U)) : (Oa.expandByPoint(Ee.min), Oa.expandByPoint(Ee.max));
      }
      Oa.getCenter(c);
      var g = 0;
      d = 0;
      for (e = a.count; d < e; d++) U.fromBufferAttribute(a, d), g = Math.max(g, c.distanceToSquared(U));
      if (b) for (d = 0, e = b.length; d < e; d++) {
        f = b[d];
        for (var k = this.morphTargetsRelative, l = 0, h2 = f.count; l < h2; l++) U.fromBufferAttribute(
          f,
          l
        ), k && (wd.fromBufferAttribute(a, l), U.add(wd)), g = Math.max(g, c.distanceToSquared(U));
      }
      this.boundingSphere.radius = Math.sqrt(g);
      isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }, computeFaceNormals: function() {
  }, computeVertexNormals: function() {
    var a = this.index, b = this.attributes;
    if (b.position) {
      var c = b.position.array;
      if (void 0 === b.normal) this.setAttribute("normal", new M(
        new Float32Array(c.length),
        3
      ));
      else for (var d = b.normal.array, e = 0, f = d.length; e < f; e++) d[e] = 0;
      d = b.normal.array;
      var g = new n(), k = new n(), l = new n(), h2 = new n(), x = new n();
      if (a) {
        var p = a.array;
        e = 0;
        for (f = a.count; e < f; e += 3) {
          a = 3 * p[e + 0];
          var q = 3 * p[e + 1];
          var t = 3 * p[e + 2];
          g.fromArray(c, a);
          k.fromArray(c, q);
          l.fromArray(c, t);
          h2.subVectors(l, k);
          x.subVectors(g, k);
          h2.cross(x);
          d[a] += h2.x;
          d[a + 1] += h2.y;
          d[a + 2] += h2.z;
          d[q] += h2.x;
          d[q + 1] += h2.y;
          d[q + 2] += h2.z;
          d[t] += h2.x;
          d[t + 1] += h2.y;
          d[t + 2] += h2.z;
        }
      } else for (e = 0, f = c.length; e < f; e += 9) g.fromArray(c, e), k.fromArray(c, e + 3), l.fromArray(c, e + 6), h2.subVectors(l, k), x.subVectors(g, k), h2.cross(x), d[e] = h2.x, d[e + 1] = h2.y, d[e + 2] = h2.z, d[e + 3] = h2.x, d[e + 4] = h2.y, d[e + 5] = h2.z, d[e + 6] = h2.x, d[e + 7] = h2.y, d[e + 8] = h2.z;
      this.normalizeNormals();
      b.normal.needsUpdate = true;
    }
  }, merge: function(a, b) {
    if (a && a.isBufferGeometry) {
      void 0 === b && (b = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      var c = this.attributes, d;
      for (d in c) if (void 0 !== a.attributes[d]) {
        var e = c[d].array, f = a.attributes[d], g = f.array, k = f.itemSize * b;
        f = Math.min(g.length, e.length - k);
        for (var l = 0; l < f; l++, k++) e[k] = g[l];
      }
      return this;
    }
    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
  }, normalizeNormals: function() {
    for (var a = this.attributes.normal, b = 0, c = a.count; b < c; b++) U.x = a.getX(b), U.y = a.getY(b), U.z = a.getZ(b), U.normalize(), a.setXYZ(b, U.x, U.y, U.z);
  }, toNonIndexed: function() {
    function a(a2, b2) {
      var c2 = a2.array;
      a2 = a2.itemSize;
      for (var d2 = new c2.constructor(b2.length * a2), e2, f2 = 0, g2 = 0, k2 = b2.length; g2 < k2; g2++) {
        e2 = b2[g2] * a2;
        for (var l2 = 0; l2 < a2; l2++) d2[f2++] = c2[e2++];
      }
      return new M(d2, a2);
    }
    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
    var b = new A(), c = this.index.array, d = this.attributes, e;
    for (e in d) {
      var f = d[e];
      f = a(f, c);
      b.setAttribute(e, f);
    }
    var g = this.morphAttributes;
    for (e in g) {
      var k = [], l = g[e];
      d = 0;
      for (var h2 = l.length; d < h2; d++) f = l[d], f = a(f, c), k.push(f);
      b.morphAttributes[e] = k;
    }
    b.morphTargetsRelative = this.morphTargetsRelative;
    c = this.groups;
    d = 0;
    for (e = c.length; d < e; d++) f = c[d], b.addGroup(f.start, f.count, f.materialIndex);
    return b;
  }, toJSON: function() {
    var a = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    a.uuid = this.uuid;
    a.type = this.type;
    "" !== this.name && (a.name = this.name);
    0 < Object.keys(this.userData).length && (a.userData = this.userData);
    if (void 0 !== this.parameters) {
      var b = this.parameters;
      for (h2 in b) void 0 !== b[h2] && (a[h2] = b[h2]);
      return a;
    }
    a.data = { attributes: {} };
    b = this.index;
    null !== b && (a.data.index = {
      type: b.array.constructor.name,
      array: Array.prototype.slice.call(b.array)
    });
    var c = this.attributes;
    for (h2 in c) {
      b = c[h2];
      var d = b.toJSON();
      "" !== b.name && (d.name = b.name);
      a.data.attributes[h2] = d;
    }
    c = {};
    var e = false;
    for (h2 in this.morphAttributes) {
      for (var f = this.morphAttributes[h2], g = [], k = 0, l = f.length; k < l; k++) b = f[k], d = b.toJSON(), "" !== b.name && (d.name = b.name), g.push(d);
      0 < g.length && (c[h2] = g, e = true);
    }
    e && (a.data.morphAttributes = c, a.data.morphTargetsRelative = this.morphTargetsRelative);
    var h2 = this.groups;
    0 < h2.length && (a.data.groups = JSON.parse(JSON.stringify(h2)));
    h2 = this.boundingSphere;
    null !== h2 && (a.data.boundingSphere = { center: h2.center.toArray(), radius: h2.radius });
    return a;
  }, clone: function() {
    return new A().copy(this);
  }, copy: function(a) {
    var b;
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingSphere = this.boundingBox = null;
    this.name = a.name;
    var c = a.index;
    null !== c && this.setIndex(c.clone());
    c = a.attributes;
    for (g in c) this.setAttribute(g, c[g].clone());
    var d = a.morphAttributes;
    for (g in d) {
      var e = [], f = d[g];
      c = 0;
      for (b = f.length; c < b; c++) e.push(f[c].clone());
      this.morphAttributes[g] = e;
    }
    this.morphTargetsRelative = a.morphTargetsRelative;
    var g = a.groups;
    c = 0;
    for (b = g.length; c < b; c++) d = g[c], this.addGroup(d.start, d.count, d.materialIndex);
    g = a.boundingBox;
    null !== g && (this.boundingBox = g.clone());
    g = a.boundingSphere;
    null !== g && (this.boundingSphere = g.clone());
    this.drawRange.start = a.drawRange.start;
    this.drawRange.count = a.drawRange.count;
    this.userData = a.userData;
    return this;
  }, dispose: function() {
    this.dispatchEvent({ type: "dispose" });
  } });
  var Qi = new O(), tc = new Wb(), lh = new qb(), Zb = new n(), $b = new n(), ac = new n(), fg = new n(), gg = new n(), hg = new n(), Me = new n(), Ne = new n(), Oe = new n(), Cc = new w(), Dc = new w(), Ec = new w(), Id = new n(), Ke = new n();
  ca.prototype = Object.assign(Object.create(D.prototype), { constructor: ca, isMesh: true, copy: function(a) {
    D.prototype.copy.call(this, a);
    void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice());
    void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, a.morphTargetDictionary));
    return this;
  }, updateMorphTargets: function() {
    var a = this.geometry;
    if (a.isBufferGeometry) {
      a = a.morphAttributes;
      var b = Object.keys(a);
      if (0 < b.length) {
        var c = a[b[0]];
        if (void 0 !== c) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
          var d = c[a].name || String(a);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[d] = a;
        }
      }
    } else a = a.morphTargets, void 0 !== a && 0 < a.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }, raycast: function(a, b) {
    var c = this.geometry, d = this.material, e = this.matrixWorld;
    if (void 0 !== d && (null === c.boundingSphere && c.computeBoundingSphere(), lh.copy(c.boundingSphere), lh.applyMatrix4(e), false !== a.ray.intersectsSphere(lh) && (Qi.getInverse(e), tc.copy(a.ray).applyMatrix4(Qi), null === c.boundingBox || false !== tc.intersectsBox(c.boundingBox)))) {
      if (c.isBufferGeometry) {
        var f = c.index;
        e = c.attributes.position;
        var g = c.morphAttributes.position, k = c.morphTargetsRelative, l = c.attributes.uv, h2 = c.attributes.uv2, n2 = c.groups, p = c.drawRange, q, t;
        if (null !== f) if (Array.isArray(d)) {
          var r = 0;
          for (q = n2.length; r < q; r++) {
            var u = n2[r];
            var y = d[u.materialIndex];
            var v = Math.max(u.start, p.start);
            for (t = c = Math.min(u.start + u.count, p.start + p.count); v < t; v += 3) {
              c = f.getX(v);
              var C = f.getX(v + 1);
              var A2 = f.getX(v + 2);
              if (c = Le(this, y, a, tc, e, g, k, l, h2, c, C, A2)) c.faceIndex = Math.floor(v / 3), c.face.materialIndex = u.materialIndex, b.push(c);
            }
          }
        } else for (v = Math.max(0, p.start), c = Math.min(f.count, p.start + p.count), r = v, q = c; r < q; r += 3) {
          if (c = f.getX(r), C = f.getX(r + 1), A2 = f.getX(r + 2), c = Le(this, d, a, tc, e, g, k, l, h2, c, C, A2)) c.faceIndex = Math.floor(r / 3), b.push(c);
        }
        else if (void 0 !== e) {
          if (Array.isArray(d)) for (r = 0, q = n2.length; r < q; r++) for (u = n2[r], y = d[u.materialIndex], v = Math.max(u.start, p.start), t = c = Math.min(u.start + u.count, p.start + p.count); v < t; v += 3) {
            if (c = v, C = v + 1, A2 = v + 2, c = Le(this, y, a, tc, e, g, k, l, h2, c, C, A2)) c.faceIndex = Math.floor(v / 3), c.face.materialIndex = u.materialIndex, b.push(c);
          }
          else for (v = Math.max(0, p.start), c = Math.min(e.count, p.start + p.count), r = v, q = c; r < q; r += 3) if (c = r, C = r + 1, A2 = r + 2, c = Le(this, d, a, tc, e, g, k, l, h2, c, C, A2)) c.faceIndex = Math.floor(r / 3), b.push(c);
        }
      } else if (c.isGeometry) {
        for (e = Array.isArray(d), g = c.vertices, k = c.faces, c = c.faceVertexUvs[0], 0 < c.length && (f = c), p = 0, r = k.length; p < r; p++) if (q = k[p], c = e ? d[q.materialIndex] : d, void 0 !== c && (l = g[q.a], h2 = g[q.b], n2 = g[q.c], c = zh(this, c, a, tc, l, h2, n2, Id))) f && f[p] && (u = f[p], Cc.copy(u[0]), Dc.copy(u[1]), Ec.copy(u[2]), c.uv = oa.getUV(Id, l, h2, n2, Cc, Dc, Ec, new w())), c.face = q, c.faceIndex = p, b.push(c);
      }
    }
  }, clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  } });
  var tj = 0, ob = new O(), mh = new D(), Lf = new n();
  L.prototype = Object.assign(
    Object.create(Fa.prototype),
    {
      constructor: L,
      isGeometry: true,
      applyMatrix4: function(a) {
        for (var b = new za().getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
        c = 0;
        for (d = this.faces.length; c < d; c++) {
          a = this.faces[c];
          a.normal.applyMatrix3(b).normalize();
          for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize();
        }
        null !== this.boundingBox && this.computeBoundingBox();
        null !== this.boundingSphere && this.computeBoundingSphere();
        this.normalsNeedUpdate = this.verticesNeedUpdate = true;
        return this;
      },
      rotateX: function(a) {
        ob.makeRotationX(a);
        this.applyMatrix4(ob);
        return this;
      },
      rotateY: function(a) {
        ob.makeRotationY(a);
        this.applyMatrix4(ob);
        return this;
      },
      rotateZ: function(a) {
        ob.makeRotationZ(a);
        this.applyMatrix4(ob);
        return this;
      },
      translate: function(a, b, c) {
        ob.makeTranslation(a, b, c);
        this.applyMatrix4(ob);
        return this;
      },
      scale: function(a, b, c) {
        ob.makeScale(a, b, c);
        this.applyMatrix4(ob);
        return this;
      },
      lookAt: function(a) {
        mh.lookAt(a);
        mh.updateMatrix();
        this.applyMatrix4(mh.matrix);
        return this;
      },
      fromBufferGeometry: function(a) {
        function b(a2, b2, d2, e2) {
          var f2 = void 0 === k ? [] : [c.colors[a2].clone(), c.colors[b2].clone(), c.colors[d2].clone()], m = void 0 === g ? [] : [new n().fromArray(g, 3 * a2), new n().fromArray(g, 3 * b2), new n().fromArray(g, 3 * d2)];
          e2 = new Bc(a2, b2, d2, m, f2, e2);
          c.faces.push(e2);
          void 0 !== l && c.faceVertexUvs[0].push([new w().fromArray(l, 2 * a2), new w().fromArray(l, 2 * b2), new w().fromArray(l, 2 * d2)]);
          void 0 !== h2 && c.faceVertexUvs[1].push([new w().fromArray(h2, 2 * a2), new w().fromArray(h2, 2 * b2), new w().fromArray(h2, 2 * d2)]);
        }
        var c = this, d = null !== a.index ? a.index.array : void 0, e = a.attributes;
        if (void 0 === e.position) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
        var f = e.position.array, g = void 0 !== e.normal ? e.normal.array : void 0, k = void 0 !== e.color ? e.color.array : void 0, l = void 0 !== e.uv ? e.uv.array : void 0, h2 = void 0 !== e.uv2 ? e.uv2.array : void 0;
        void 0 !== h2 && (this.faceVertexUvs[1] = []);
        for (e = 0; e < f.length; e += 3) c.vertices.push(new n().fromArray(f, e)), void 0 !== k && c.colors.push(new B().fromArray(k, e));
        var x = a.groups;
        if (0 < x.length) for (e = 0; e < x.length; e++) {
          f = x[e];
          var p = f.start, q = p;
          for (p += f.count; q < p; q += 3) void 0 !== d ? b(d[q], d[q + 1], d[q + 2], f.materialIndex) : b(q, q + 1, q + 2, f.materialIndex);
        }
        else if (void 0 !== d) for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
        else for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
        this.computeFaceNormals();
        null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
        null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(Lf).negate();
        this.translate(
          Lf.x,
          Lf.y,
          Lf.z
        );
        return this;
      },
      normalize: function() {
        this.computeBoundingSphere();
        var a = this.boundingSphere.center, b = this.boundingSphere.radius;
        b = 0 === b ? 1 : 1 / b;
        var c = new O();
        c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
        this.applyMatrix4(c);
        return this;
      },
      computeFaceNormals: function() {
        for (var a = new n(), b = new n(), c = 0, d = this.faces.length; c < d; c++) {
          var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
          a.subVectors(this.vertices[e.c], g);
          b.subVectors(f, g);
          a.cross(b);
          a.normalize();
          e.normal.copy(a);
        }
      },
      computeVertexNormals: function(a) {
        void 0 === a && (a = true);
        var b;
        var c = Array(this.vertices.length);
        var d = 0;
        for (b = this.vertices.length; d < b; d++) c[d] = new n();
        if (a) {
          var e = new n(), f = new n();
          a = 0;
          for (d = this.faces.length; a < d; a++) {
            b = this.faces[a];
            var g = this.vertices[b.a];
            var k = this.vertices[b.b];
            var l = this.vertices[b.c];
            e.subVectors(l, k);
            f.subVectors(g, k);
            e.cross(f);
            c[b.a].add(e);
            c[b.b].add(e);
            c[b.c].add(e);
          }
        } else for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++) b = this.faces[a], c[b.a].add(b.normal), c[b.b].add(b.normal), c[b.c].add(b.normal);
        d = 0;
        for (b = this.vertices.length; d < b; d++) c[d].normalize();
        a = 0;
        for (d = this.faces.length; a < d; a++) b = this.faces[a], g = b.vertexNormals, 3 === g.length ? (g[0].copy(c[b.a]), g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[b.c].clone());
        0 < this.faces.length && (this.normalsNeedUpdate = true);
      },
      computeFlatVertexNormals: function() {
        var a;
        this.computeFaceNormals();
        var b = 0;
        for (a = this.faces.length; b < a; b++) {
          var c = this.faces[b];
          var d = c.vertexNormals;
          3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[1] = c.normal.clone(), d[2] = c.normal.clone());
        }
        0 < this.faces.length && (this.normalsNeedUpdate = true);
      },
      computeMorphNormals: function() {
        var a, b;
        var c = 0;
        for (b = this.faces.length; c < b; c++) {
          var d = this.faces[c];
          d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = d.normal.clone();
          d.__originalVertexNormals || (d.__originalVertexNormals = []);
          var e = 0;
          for (a = d.vertexNormals.length; e < a; e++) d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone();
        }
        var f = new L();
        f.faces = this.faces;
        e = 0;
        for (a = this.morphTargets.length; e < a; e++) {
          if (!this.morphNormals[e]) {
            this.morphNormals[e] = {};
            this.morphNormals[e].faceNormals = [];
            this.morphNormals[e].vertexNormals = [];
            d = this.morphNormals[e].faceNormals;
            var g = this.morphNormals[e].vertexNormals;
            c = 0;
            for (b = this.faces.length; c < b; c++) {
              var k = new n();
              var l = { a: new n(), b: new n(), c: new n() };
              d.push(k);
              g.push(l);
            }
          }
          g = this.morphNormals[e];
          f.vertices = this.morphTargets[e].vertices;
          f.computeFaceNormals();
          f.computeVertexNormals();
          c = 0;
          for (b = this.faces.length; c < b; c++) d = this.faces[c], k = g.faceNormals[c], l = g.vertexNormals[c], k.copy(d.normal), l.a.copy(d.vertexNormals[0]), l.b.copy(d.vertexNormals[1]), l.c.copy(d.vertexNormals[2]);
        }
        c = 0;
        for (b = this.faces.length; c < b; c++) d = this.faces[c], d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals;
      },
      computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new Ta());
        this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new qb());
        this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function(a, b, c) {
        if (a && a.isGeometry) {
          var d, e = this.vertices.length, f = this.vertices, g = a.vertices, k = this.faces, l = a.faces, h2 = this.colors, n2 = a.colors;
          void 0 === c && (c = 0);
          void 0 !== b && (d = new za().getNormalMatrix(b));
          for (var p = 0, q = g.length; p < q; p++) {
            var t = g[p].clone();
            void 0 !== b && t.applyMatrix4(b);
            f.push(t);
          }
          p = 0;
          for (q = n2.length; p < q; p++) h2.push(n2[p].clone());
          p = 0;
          for (q = l.length; p < q; p++) {
            g = l[p];
            var r = g.vertexNormals;
            n2 = g.vertexColors;
            h2 = new Bc(g.a + e, g.b + e, g.c + e);
            h2.normal.copy(g.normal);
            void 0 !== d && h2.normal.applyMatrix3(d).normalize();
            b = 0;
            for (f = r.length; b < f; b++) t = r[b].clone(), void 0 !== d && t.applyMatrix3(d).normalize(), h2.vertexNormals.push(t);
            h2.color.copy(g.color);
            b = 0;
            for (f = n2.length; b < f; b++) t = n2[b], h2.vertexColors.push(t.clone());
            h2.materialIndex = g.materialIndex + c;
            k.push(h2);
          }
          p = 0;
          for (q = a.faceVertexUvs.length; p < q; p++) for (c = a.faceVertexUvs[p], void 0 === this.faceVertexUvs[p] && (this.faceVertexUvs[p] = []), b = 0, f = c.length; b < f; b++) {
            d = c[b];
            e = [];
            k = 0;
            for (l = d.length; k < l; k++) e.push(d[k].clone());
            this.faceVertexUvs[p].push(e);
          }
        } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
      },
      mergeMesh: function(a) {
        a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a);
      },
      mergeVertices: function() {
        var a = {}, b = [], c = [], d = Math.pow(10, 4), e;
        var f = 0;
        for (e = this.vertices.length; f < e; f++) {
          var g = this.vertices[f];
          g = Math.round(g.x * d) + "_" + Math.round(g.y * d) + "_" + Math.round(g.z * d);
          void 0 === a[g] ? (a[g] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[g]];
        }
        a = [];
        f = 0;
        for (e = this.faces.length; f < e; f++) for (d = this.faces[f], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], g = 0; 3 > g; g++) if (d[g] === d[(g + 1) % 3]) {
          a.push(f);
          break;
        }
        for (f = a.length - 1; 0 <= f; f--) for (d = a[f], this.faces.splice(d, 1), c = 0, e = this.faceVertexUvs.length; c < e; c++) this.faceVertexUvs[c].splice(d, 1);
        f = this.vertices.length - b.length;
        this.vertices = b;
        return f;
      },
      setFromPoints: function(a) {
        this.vertices = [];
        for (var b = 0, c = a.length; b < c; b++) {
          var d = a[b];
          this.vertices.push(new n(d.x, d.y, d.z || 0));
        }
        return this;
      },
      sortFacesByMaterialIndex: function() {
        for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
        a.sort(function(a2, b2) {
          return a2.materialIndex - b2.materialIndex;
        });
        var d = this.faceVertexUvs[0], e = this.faceVertexUvs[1], f, g;
        d && d.length === b && (f = []);
        e && e.length === b && (g = []);
        for (c = 0; c < b; c++) {
          var k = a[c]._id;
          f && f.push(d[k]);
          g && g.push(e[k]);
        }
        f && (this.faceVertexUvs[0] = f);
        g && (this.faceVertexUvs[1] = g);
      },
      toJSON: function() {
        function a(a2, b2, c2) {
          return c2 ? a2 | 1 << b2 : a2 & ~(1 << b2);
        }
        function b(a2) {
          var b2 = a2.x.toString() + a2.y.toString() + a2.z.toString();
          if (void 0 !== m[b2]) return m[b2];
          m[b2] = h2.length / 3;
          h2.push(a2.x, a2.y, a2.z);
          return m[b2];
        }
        function c(a2) {
          var b2 = a2.r.toString() + a2.g.toString() + a2.b.toString();
          if (void 0 !== p[b2]) return p[b2];
          p[b2] = n2.length;
          n2.push(a2.getHex());
          return p[b2];
        }
        function d(a2) {
          var b2 = a2.x.toString() + a2.y.toString();
          if (void 0 !== t[b2]) return t[b2];
          t[b2] = q.length / 2;
          q.push(a2.x, a2.y);
          return t[b2];
        }
        var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } };
        e.uuid = this.uuid;
        e.type = this.type;
        "" !== this.name && (e.name = this.name);
        if (void 0 !== this.parameters) {
          var f = this.parameters, g;
          for (g in f) void 0 !== f[g] && (e[g] = f[g]);
          return e;
        }
        f = [];
        for (g = 0; g < this.vertices.length; g++) {
          var k = this.vertices[g];
          f.push(k.x, k.y, k.z);
        }
        k = [];
        var h2 = [], m = {}, n2 = [], p = {}, q = [], t = {};
        for (g = 0; g < this.faces.length; g++) {
          var r = this.faces[g], u = void 0 !== this.faceVertexUvs[0][g], y = 0 < r.normal.length(), v = 0 < r.vertexNormals.length, w2 = 1 !== r.color.r || 1 !== r.color.g || 1 !== r.color.b, A2 = 0 < r.vertexColors.length, B2 = 0;
          B2 = a(B2, 0, 0);
          B2 = a(B2, 1, true);
          B2 = a(B2, 2, false);
          B2 = a(B2, 3, u);
          B2 = a(B2, 4, y);
          B2 = a(B2, 5, v);
          B2 = a(B2, 6, w2);
          B2 = a(B2, 7, A2);
          k.push(B2);
          k.push(r.a, r.b, r.c);
          k.push(r.materialIndex);
          u && (u = this.faceVertexUvs[0][g], k.push(d(u[0]), d(u[1]), d(u[2])));
          y && k.push(b(r.normal));
          v && (y = r.vertexNormals, k.push(b(y[0]), b(y[1]), b(y[2])));
          w2 && k.push(c(r.color));
          A2 && (r = r.vertexColors, k.push(c(r[0]), c(r[1]), c(r[2])));
        }
        e.data = {};
        e.data.vertices = f;
        e.data.normals = h2;
        0 < n2.length && (e.data.colors = n2);
        0 < q.length && (e.data.uvs = [q]);
        e.data.faces = k;
        return e;
      },
      clone: function() {
        return new L().copy(this);
      },
      copy: function(a) {
        var b, c, d;
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingSphere = this.boundingBox = null;
        this.name = a.name;
        var e = a.vertices;
        var f = 0;
        for (b = e.length; f < b; f++) this.vertices.push(e[f].clone());
        e = a.colors;
        f = 0;
        for (b = e.length; f < b; f++) this.colors.push(e[f].clone());
        e = a.faces;
        f = 0;
        for (b = e.length; f < b; f++) this.faces.push(e[f].clone());
        f = 0;
        for (b = a.faceVertexUvs.length; f < b; f++) {
          var g = a.faceVertexUvs[f];
          void 0 === this.faceVertexUvs[f] && (this.faceVertexUvs[f] = []);
          e = 0;
          for (c = g.length; e < c; e++) {
            var k = g[e], h2 = [];
            var m = 0;
            for (d = k.length; m < d; m++) h2.push(k[m].clone());
            this.faceVertexUvs[f].push(h2);
          }
        }
        m = a.morphTargets;
        f = 0;
        for (b = m.length; f < b; f++) {
          d = {};
          d.name = m[f].name;
          if (void 0 !== m[f].vertices) for (d.vertices = [], e = 0, c = m[f].vertices.length; e < c; e++) d.vertices.push(m[f].vertices[e].clone());
          if (void 0 !== m[f].normals) for (d.normals = [], e = 0, c = m[f].normals.length; e < c; e++) d.normals.push(m[f].normals[e].clone());
          this.morphTargets.push(d);
        }
        m = a.morphNormals;
        f = 0;
        for (b = m.length; f < b; f++) {
          d = {};
          if (void 0 !== m[f].vertexNormals) for (d.vertexNormals = [], e = 0, c = m[f].vertexNormals.length; e < c; e++) g = m[f].vertexNormals[e], k = {}, k.a = g.a.clone(), k.b = g.b.clone(), k.c = g.c.clone(), d.vertexNormals.push(k);
          if (void 0 !== m[f].faceNormals) for (d.faceNormals = [], e = 0, c = m[f].faceNormals.length; e < c; e++) d.faceNormals.push(m[f].faceNormals[e].clone());
          this.morphNormals.push(d);
        }
        e = a.skinWeights;
        f = 0;
        for (b = e.length; f < b; f++) this.skinWeights.push(e[f].clone());
        e = a.skinIndices;
        f = 0;
        for (b = e.length; f < b; f++) this.skinIndices.push(e[f].clone());
        e = a.lineDistances;
        f = 0;
        for (b = e.length; f < b; f++) this.lineDistances.push(e[f]);
        f = a.boundingBox;
        null !== f && (this.boundingBox = f.clone());
        f = a.boundingSphere;
        null !== f && (this.boundingSphere = f.clone());
        this.elementsNeedUpdate = a.elementsNeedUpdate;
        this.verticesNeedUpdate = a.verticesNeedUpdate;
        this.uvsNeedUpdate = a.uvsNeedUpdate;
        this.normalsNeedUpdate = a.normalsNeedUpdate;
        this.colorsNeedUpdate = a.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = a.groupsNeedUpdate;
        return this;
      },
      dispose: function() {
        this.dispatchEvent({ type: "dispose" });
      }
    }
  );
  var nh = function(a) {
    function b(b2, d, e, f, g, k) {
      a.call(this);
      this.type = "BoxGeometry";
      this.parameters = { width: b2, height: d, depth: e, widthSegments: f, heightSegments: g, depthSegments: k };
      this.fromBufferGeometry(new Kd(b2, d, e, f, g, k));
      this.mergeVertices();
    }
    a && (b.__proto__ = a);
    b.prototype = Object.create(a && a.prototype);
    return b.prototype.constructor = b;
  }(L), Kd = function(a) {
    function b(b2, d, e, f, g, k) {
      function c(a2, b3, c2, d2, e2, f2, g2, k2, l, m, w2) {
        var v = f2 / l, y = g2 / m, z = f2 / 2, A2 = g2 / 2, C = k2 / 2;
        g2 = l + 1;
        var B2 = m + 1, E2 = f2 = 0, D2, F2, G = new n();
        for (F2 = 0; F2 < B2; F2++) {
          var I2 = F2 * y - A2;
          for (D2 = 0; D2 < g2; D2++) G[a2] = (D2 * v - z) * d2, G[b3] = I2 * e2, G[c2] = C, p.push(G.x, G.y, G.z), G[a2] = 0, G[b3] = 0, G[c2] = 0 < k2 ? 1 : -1, q.push(G.x, G.y, G.z), t.push(D2 / l), t.push(1 - F2 / m), f2 += 1;
        }
        for (F2 = 0; F2 < m; F2++) for (D2 = 0; D2 < l; D2++) a2 = r + D2 + g2 * (F2 + 1), b3 = r + (D2 + 1) + g2 * (F2 + 1), c2 = r + (D2 + 1) + g2 * F2, x.push(r + D2 + g2 * F2, a2, c2), x.push(a2, b3, c2), E2 += 6;
        h2.addGroup(u, E2, w2);
        u += E2;
        r += f2;
      }
      a.call(this);
      this.type = "BoxBufferGeometry";
      this.parameters = {
        width: b2,
        height: d,
        depth: e,
        widthSegments: f,
        heightSegments: g,
        depthSegments: k
      };
      var h2 = this;
      b2 = b2 || 1;
      d = d || 1;
      e = e || 1;
      f = Math.floor(f) || 1;
      g = Math.floor(g) || 1;
      k = Math.floor(k) || 1;
      var x = [], p = [], q = [], t = [], r = 0, u = 0;
      c("z", "y", "x", -1, -1, e, d, b2, k, g, 0);
      c("z", "y", "x", 1, -1, e, d, -b2, k, g, 1);
      c("x", "z", "y", 1, 1, b2, e, d, f, k, 2);
      c("x", "z", "y", 1, -1, b2, e, -d, f, k, 3);
      c("x", "y", "z", 1, -1, b2, d, e, f, g, 4);
      c("x", "y", "z", -1, -1, b2, d, -e, f, g, 5);
      this.setIndex(x);
      this.setAttribute("position", new E(p, 3));
      this.setAttribute("normal", new E(q, 3));
      this.setAttribute(
        "uv",
        new E(t, 2)
      );
    }
    a && (b.__proto__ = a);
    b.prototype = Object.create(a && a.prototype);
    return b.prototype.constructor = b;
  }(A), Th = { clone: Fc, merge: pa };
  qa.prototype = Object.create(K.prototype);
  qa.prototype.constructor = qa;
  qa.prototype.isShaderMaterial = true;
  qa.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.fragmentShader = a.fragmentShader;
    this.vertexShader = a.vertexShader;
    this.uniforms = Fc(a.uniforms);
    this.defines = Object.assign({}, a.defines);
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.lights = a.lights;
    this.clipping = a.clipping;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    this.extensions = a.extensions;
    return this;
  };
  qa.prototype.toJSON = function(a) {
    var b = K.prototype.toJSON.call(this, a);
    b.uniforms = {};
    for (var c in this.uniforms) {
      var d = this.uniforms[c].value;
      b.uniforms[c] = d && d.isTexture ? { type: "t", value: d.toJSON(a).uuid } : d && d.isColor ? { type: "c", value: d.getHex() } : d && d.isVector2 ? { type: "v2", value: d.toArray() } : d && d.isVector3 ? { type: "v3", value: d.toArray() } : d && d.isVector4 ? { type: "v4", value: d.toArray() } : d && d.isMatrix3 ? { type: "m3", value: d.toArray() } : d && d.isMatrix4 ? { type: "m4", value: d.toArray() } : { value: d };
    }
    0 < Object.keys(this.defines).length && (b.defines = this.defines);
    b.vertexShader = this.vertexShader;
    b.fragmentShader = this.fragmentShader;
    a = {};
    for (var e in this.extensions) true === this.extensions[e] && (a[e] = true);
    0 < Object.keys(a).length && (b.extensions = a);
    return b;
  };
  eb.prototype = Object.assign(Object.create(D.prototype), {
    constructor: eb,
    isCamera: true,
    copy: function(a, b) {
      D.prototype.copy.call(
        this,
        a,
        b
      );
      this.matrixWorldInverse.copy(a.matrixWorldInverse);
      this.projectionMatrix.copy(a.projectionMatrix);
      this.projectionMatrixInverse.copy(a.projectionMatrixInverse);
      return this;
    },
    getWorldDirection: function(a) {
      void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), a = new n());
      this.updateMatrixWorld(true);
      var b = this.matrixWorld.elements;
      return a.set(-b[8], -b[9], -b[10]).normalize();
    },
    updateMatrixWorld: function(a) {
      D.prototype.updateMatrixWorld.call(this, a);
      this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    updateWorldMatrix: function(a, b) {
      D.prototype.updateWorldMatrix.call(this, a, b);
      this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  });
  da.prototype = Object.assign(Object.create(eb.prototype), { constructor: da, isPerspectiveCamera: true, copy: function(a, b) {
    eb.prototype.copy.call(this, a, b);
    this.fov = a.fov;
    this.zoom = a.zoom;
    this.near = a.near;
    this.far = a.far;
    this.focus = a.focus;
    this.aspect = a.aspect;
    this.view = null === a.view ? null : Object.assign({}, a.view);
    this.filmGauge = a.filmGauge;
    this.filmOffset = a.filmOffset;
    return this;
  }, setFocalLength: function(a) {
    a = 0.5 * this.getFilmHeight() / a;
    this.fov = 2 * P.RAD2DEG * Math.atan(a);
    this.updateProjectionMatrix();
  }, getFocalLength: function() {
    var a = Math.tan(0.5 * P.DEG2RAD * this.fov);
    return 0.5 * this.getFilmHeight() / a;
  }, getEffectiveFOV: function() {
    return 2 * P.RAD2DEG * Math.atan(Math.tan(0.5 * P.DEG2RAD * this.fov) / this.zoom);
  }, getFilmWidth: function() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }, getFilmHeight: function() {
    return this.filmGauge / Math.max(
      this.aspect,
      1
    );
  }, setViewOffset: function(a, b, c, d, e, f) {
    this.aspect = a / b;
    null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 });
    this.view.enabled = true;
    this.view.fullWidth = a;
    this.view.fullHeight = b;
    this.view.offsetX = c;
    this.view.offsetY = d;
    this.view.width = e;
    this.view.height = f;
    this.updateProjectionMatrix();
  }, clearViewOffset: function() {
    null !== this.view && (this.view.enabled = false);
    this.updateProjectionMatrix();
  }, updateProjectionMatrix: function() {
    var a = this.near, b = a * Math.tan(0.5 * P.DEG2RAD * this.fov) / this.zoom, c = 2 * b, d = this.aspect * c, e = -0.5 * d, f = this.view;
    if (null !== this.view && this.view.enabled) {
      var g = f.fullWidth, k = f.fullHeight;
      e += f.offsetX * d / g;
      b -= f.offsetY * c / k;
      d *= f.width / g;
      c *= f.height / k;
    }
    f = this.filmOffset;
    0 !== f && (e += a * f / this.getFilmWidth());
    this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  }, toJSON: function(a) {
    a = D.prototype.toJSON.call(this, a);
    a.object.fov = this.fov;
    a.object.zoom = this.zoom;
    a.object.near = this.near;
    a.object.far = this.far;
    a.object.focus = this.focus;
    a.object.aspect = this.aspect;
    null !== this.view && (a.object.view = Object.assign({}, this.view));
    a.object.filmGauge = this.filmGauge;
    a.object.filmOffset = this.filmOffset;
    return a;
  } });
  Gc.prototype = Object.create(D.prototype);
  Gc.prototype.constructor = Gc;
  Eb.prototype = Object.create(wa.prototype);
  Eb.prototype.constructor = Eb;
  Eb.prototype.isWebGLCubeRenderTarget = true;
  Eb.prototype.fromEquirectangularTexture = function(a, b) {
    this.texture.type = b.type;
    this.texture.format = b.format;
    this.texture.encoding = b.encoding;
    var c = new pb(), d = new qa({
      type: "CubemapFromEquirect",
      uniforms: Fc({ tEquirect: { value: null } }),
      vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
      fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n}",
      side: 1,
      blending: 0
    });
    d.uniforms.tEquirect.value = b;
    b = new ca(new Kd(5, 5, 5), d);
    c.add(b);
    d = new Gc(1, 10, 1);
    d.renderTarget = this;
    d.renderTarget.texture.name = "CubeCameraTexture";
    d.update(a, c);
    b.geometry.dispose();
    b.material.dispose();
    return this;
  };
  bc.prototype = Object.create(Z.prototype);
  bc.prototype.constructor = bc;
  bc.prototype.isDataTexture = true;
  var xd = new qb(), Mf = new n();
  Object.assign(Hc.prototype, { set: function(a, b, c, d, e, f) {
    var g = this.planes;
    g[0].copy(a);
    g[1].copy(b);
    g[2].copy(c);
    g[3].copy(d);
    g[4].copy(e);
    g[5].copy(f);
    return this;
  }, clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
    return this;
  }, setFromProjectionMatrix: function(a) {
    var b = this.planes, c = a.elements;
    a = c[0];
    var d = c[1], e = c[2], f = c[3], g = c[4], k = c[5], h2 = c[6], m = c[7], n2 = c[8], p = c[9], q = c[10], t = c[11], r = c[12], u = c[13], y = c[14];
    c = c[15];
    b[0].setComponents(f - a, m - g, t - n2, c - r).normalize();
    b[1].setComponents(f + a, m + g, t + n2, c + r).normalize();
    b[2].setComponents(f + d, m + k, t + p, c + u).normalize();
    b[3].setComponents(f - d, m - k, t - p, c - u).normalize();
    b[4].setComponents(f - e, m - h2, t - q, c - y).normalize();
    b[5].setComponents(f + e, m + h2, t + q, c + y).normalize();
    return this;
  }, intersectsObject: function(a) {
    var b = a.geometry;
    null === b.boundingSphere && b.computeBoundingSphere();
    xd.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
    return this.intersectsSphere(xd);
  }, intersectsSprite: function(a) {
    xd.center.set(0, 0, 0);
    xd.radius = 0.7071067811865476;
    xd.applyMatrix4(a.matrixWorld);
    return this.intersectsSphere(xd);
  }, intersectsSphere: function(a) {
    var b = this.planes, c = a.center;
    a = -a.radius;
    for (var d = 0; 6 > d; d++) if (b[d].distanceToPoint(c) < a) return false;
    return true;
  }, intersectsBox: function(a) {
    for (var b = this.planes, c = 0; 6 > c; c++) {
      var d = b[c];
      Mf.x = 0 < d.normal.x ? a.max.x : a.min.x;
      Mf.y = 0 < d.normal.y ? a.max.y : a.min.y;
      Mf.z = 0 < d.normal.z ? a.max.z : a.min.z;
      if (0 > d.distanceToPoint(Mf)) return false;
    }
    return true;
  }, containsPoint: function(a) {
    for (var b = this.planes, c = 0; 6 > c; c++) if (0 > b[c].distanceToPoint(a)) return false;
    return true;
  } });
  var F = { common: {
    diffuse: { value: new B(15658734) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: new za() },
    uv2Transform: { value: new za() },
    alphaMap: { value: null }
  }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new w(
    1,
    1
  ) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new B(16777215) } }, lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
    rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }
  }, points: { diffuse: { value: new B(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new za() } }, sprite: { diffuse: { value: new B(15658734) }, opacity: { value: 1 }, center: { value: new w(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new za() } } };
  Jd.prototype = Object.create(L.prototype);
  Jd.prototype.constructor = Jd;
  cc.prototype = Object.create(A.prototype);
  cc.prototype.constructor = cc;
  var N = {
    alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
    alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
    aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif",
    aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
    begin_vertex: "vec3 transformed = vec3( position );",
    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha  = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	#endif\n#endif",
    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n	varying vec3 vViewPosition;\n#endif",
    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n	vViewPosition = - mvPosition.xyz;\n#endif",
    color_fragment: "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif",
    color_pars_vertex: "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif",
    color_vertex: "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif",
    common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",
    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	transformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}",
    envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		}  else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		reflectVec = normalize( reflectVec );\n		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		reflectVec = normalize( reflectVec );\n		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
    envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n		  vec3 reflectVec = reflect( -viewDir, normal );\n		  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n		  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif",
    envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) { \n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n	fogDepth = -mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n	varying float fogDepth;\n#endif",
    fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif",
    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n		float shadowCameraNear;\n		float shadowCameraFar;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif",
    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",
    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",
    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = saturate( clearcoat );	material.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif",
    lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif",
    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",
    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",
    map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n	transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n	transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n	transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif",
    normal_fragment_begin: "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",
    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		float scale = sign( st1.t * st0.s - st0.t * st1.s );\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n		mat3 tsn = mat3( S, T, N );\n		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		return normalize( tsn * mapN );\n	}\n#endif",
    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",
    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n	#endif\n#endif",
    clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",
    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",
    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif",
    shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}",
    skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
    tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",
    uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",
    uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",
    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
    depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}",
    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}",
    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n	uniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSPARENCY\n		diffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
    shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}"
  }, fb = { basic: { uniforms: pa([F.common, F.specularmap, F.envmap, F.aomap, F.lightmap, F.fog]), vertexShader: N.meshbasic_vert, fragmentShader: N.meshbasic_frag }, lambert: { uniforms: pa([F.common, F.specularmap, F.envmap, F.aomap, F.lightmap, F.emissivemap, F.fog, F.lights, { emissive: { value: new B(0) } }]), vertexShader: N.meshlambert_vert, fragmentShader: N.meshlambert_frag }, phong: { uniforms: pa([F.common, F.specularmap, F.envmap, F.aomap, F.lightmap, F.emissivemap, F.bumpmap, F.normalmap, F.displacementmap, F.fog, F.lights, {
    emissive: { value: new B(0) },
    specular: { value: new B(1118481) },
    shininess: { value: 30 }
  }]), vertexShader: N.meshphong_vert, fragmentShader: N.meshphong_frag }, standard: { uniforms: pa([F.common, F.envmap, F.aomap, F.lightmap, F.emissivemap, F.bumpmap, F.normalmap, F.displacementmap, F.roughnessmap, F.metalnessmap, F.fog, F.lights, { emissive: { value: new B(0) }, roughness: { value: 0.5 }, metalness: { value: 0.5 }, envMapIntensity: { value: 1 } }]), vertexShader: N.meshphysical_vert, fragmentShader: N.meshphysical_frag }, toon: { uniforms: pa([
    F.common,
    F.specularmap,
    F.aomap,
    F.lightmap,
    F.emissivemap,
    F.bumpmap,
    F.normalmap,
    F.displacementmap,
    F.gradientmap,
    F.fog,
    F.lights,
    { emissive: { value: new B(0) }, specular: { value: new B(1118481) }, shininess: { value: 30 } }
  ]), vertexShader: N.meshtoon_vert, fragmentShader: N.meshtoon_frag }, matcap: { uniforms: pa([F.common, F.bumpmap, F.normalmap, F.displacementmap, F.fog, { matcap: { value: null } }]), vertexShader: N.meshmatcap_vert, fragmentShader: N.meshmatcap_frag }, points: { uniforms: pa([F.points, F.fog]), vertexShader: N.points_vert, fragmentShader: N.points_frag }, dashed: { uniforms: pa([
    F.common,
    F.fog,
    { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }
  ]), vertexShader: N.linedashed_vert, fragmentShader: N.linedashed_frag }, depth: { uniforms: pa([F.common, F.displacementmap]), vertexShader: N.depth_vert, fragmentShader: N.depth_frag }, normal: { uniforms: pa([F.common, F.bumpmap, F.normalmap, F.displacementmap, { opacity: { value: 1 } }]), vertexShader: N.normal_vert, fragmentShader: N.normal_frag }, sprite: { uniforms: pa([F.sprite, F.fog]), vertexShader: N.sprite_vert, fragmentShader: N.sprite_frag }, background: { uniforms: {
    uvTransform: { value: new za() },
    t2D: { value: null }
  }, vertexShader: N.background_vert, fragmentShader: N.background_frag }, cube: { uniforms: pa([F.envmap, { opacity: { value: 1 } }]), vertexShader: N.cube_vert, fragmentShader: N.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: N.equirect_vert, fragmentShader: N.equirect_frag }, distanceRGBA: { uniforms: pa([F.common, F.displacementmap, { referencePosition: { value: new n() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: N.distanceRGBA_vert, fragmentShader: N.distanceRGBA_frag }, shadow: { uniforms: pa([
    F.lights,
    F.fog,
    { color: { value: new B(0) }, opacity: { value: 1 } }
  ]), vertexShader: N.shadow_vert, fragmentShader: N.shadow_frag } };
  fb.physical = { uniforms: pa([fb.standard.uniforms, { transparency: { value: 0 }, clearcoat: { value: 0 }, clearcoatRoughness: { value: 0 }, sheen: { value: new B(0) }, clearcoatNormalScale: { value: new w(1, 1) }, clearcoatNormalMap: { value: null } }]), vertexShader: N.meshphysical_vert, fragmentShader: N.meshphysical_frag };
  rb.prototype = Object.create(Z.prototype);
  rb.prototype.constructor = rb;
  rb.prototype.isCubeTexture = true;
  Object.defineProperty(
    rb.prototype,
    "images",
    { get: function() {
      return this.image;
    }, set: function(a) {
      this.image = a;
    } }
  );
  Ic.prototype = Object.create(Z.prototype);
  Ic.prototype.constructor = Ic;
  Ic.prototype.isDataTexture2DArray = true;
  Jc.prototype = Object.create(Z.prototype);
  Jc.prototype.constructor = Jc;
  Jc.prototype.isDataTexture3D = true;
  var Hh = new Z(), Pj = new Ic(), Rj = new Jc(), Ih = new rb(), Bh = [], Dh = [], Gh = new Float32Array(16), Fh = new Float32Array(9), Eh = new Float32Array(4);
  Jh.prototype.updateCache = function(a) {
    var b = this.cache;
    a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length));
    Ka(b, a);
  };
  Kh.prototype.setValue = function(a, b, c) {
    for (var d = this.seq, e = 0, f = d.length; e !== f; ++e) {
      var g = d[e];
      g.setValue(a, b[g.id], c);
    }
  };
  var ig = /([\w\d_]+)(\])?(\[|\.)?/g;
  Fb.prototype.setValue = function(a, b, c, d) {
    b = this.map[b];
    void 0 !== b && b.setValue(a, c, d);
  };
  Fb.prototype.setOptional = function(a, b, c) {
    b = b[c];
    void 0 !== b && this.setValue(a, c, b);
  };
  Fb.upload = function(a, b, c, d) {
    for (var e = 0, f = b.length; e !== f; ++e) {
      var g = b[e], k = c[g.id];
      false !== k.needsUpdate && g.setValue(a, k.value, d);
    }
  };
  Fb.seqWithValue = function(a, b) {
    for (var c = [], d = 0, e = a.length; d !== e; ++d) {
      var f = a[d];
      f.id in b && c.push(f);
    }
    return c;
  };
  var wk = 0, kg = /^[ \t]*#include +<([\w\d./]+)>/gm, Sh = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Fk = 0;
  Gb.prototype = Object.create(K.prototype);
  Gb.prototype.constructor = Gb;
  Gb.prototype.isMeshDepthMaterial = true;
  Gb.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.depthPacking = a.depthPacking;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    return this;
  };
  Hb.prototype = Object.create(K.prototype);
  Hb.prototype.constructor = Hb;
  Hb.prototype.isMeshDistanceMaterial = true;
  Hb.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.referencePosition.copy(a.referencePosition);
    this.nearDistance = a.nearDistance;
    this.farDistance = a.farDistance;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    return this;
  };
  pg.prototype = Object.assign(Object.create(wa.prototype), { constructor: pg, isWebGLMultiviewRenderTarget: true, copy: function(a) {
    wa.prototype.copy.call(this, a);
    this.numViews = a.numViews;
    return this;
  }, setNumViews: function(a) {
    this.numViews !== a && (this.numViews = a, this.dispose());
    return this;
  } });
  Qe.prototype = Object.assign(Object.create(da.prototype), { constructor: Qe, isArrayCamera: true });
  Mc.prototype = Object.assign(Object.create(D.prototype), { constructor: Mc, isGroup: true });
  Object.assign(Zh.prototype, Fa.prototype);
  Object.assign(Re.prototype, { isFogExp2: true, clone: function() {
    return new Re(this.color, this.density);
  }, toJSON: function() {
    return { type: "FogExp2", color: this.color.getHex(), density: this.density };
  } });
  Object.assign(Se.prototype, { isFog: true, clone: function() {
    return new Se(
      this.color,
      this.near,
      this.far
    );
  }, toJSON: function() {
    return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
  } });
  Object.defineProperty(sb.prototype, "needsUpdate", { set: function(a) {
    true === a && this.version++;
  } });
  Object.assign(sb.prototype, { isInterleavedBuffer: true, onUploadCallback: function() {
  }, setUsage: function(a) {
    this.usage = a;
    return this;
  }, copy: function(a) {
    this.array = new a.array.constructor(a.array);
    this.count = a.count;
    this.stride = a.stride;
    this.usage = a.usage;
    return this;
  }, copyAt: function(a, b, c) {
    a *= this.stride;
    c *= b.stride;
    for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
    return this;
  }, set: function(a, b) {
    void 0 === b && (b = 0);
    this.array.set(a, b);
    return this;
  }, clone: function() {
    return new this.constructor().copy(this);
  }, onUpload: function(a) {
    this.onUploadCallback = a;
    return this;
  } });
  var uc = new n();
  Object.defineProperties(Qd.prototype, { count: { get: function() {
    return this.data.count;
  } }, array: { get: function() {
    return this.data.array;
  } } });
  Object.assign(Qd.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function(a) {
      for (var b = 0, c = this.data.count; b < c; b++) uc.x = this.getX(b), uc.y = this.getY(b), uc.z = this.getZ(b), uc.applyMatrix4(a), this.setXYZ(b, uc.x, uc.y, uc.z);
      return this;
    },
    setX: function(a, b) {
      this.data.array[a * this.data.stride + this.offset] = b;
      return this;
    },
    setY: function(a, b) {
      this.data.array[a * this.data.stride + this.offset + 1] = b;
      return this;
    },
    setZ: function(a, b) {
      this.data.array[a * this.data.stride + this.offset + 2] = b;
      return this;
    },
    setW: function(a, b) {
      this.data.array[a * this.data.stride + this.offset + 3] = b;
      return this;
    },
    getX: function(a) {
      return this.data.array[a * this.data.stride + this.offset];
    },
    getY: function(a) {
      return this.data.array[a * this.data.stride + this.offset + 1];
    },
    getZ: function(a) {
      return this.data.array[a * this.data.stride + this.offset + 2];
    },
    getW: function(a) {
      return this.data.array[a * this.data.stride + this.offset + 3];
    },
    setXY: function(a, b, c) {
      a = a * this.data.stride + this.offset;
      this.data.array[a + 0] = b;
      this.data.array[a + 1] = c;
      return this;
    },
    setXYZ: function(a, b, c, d) {
      a = a * this.data.stride + this.offset;
      this.data.array[a + 0] = b;
      this.data.array[a + 1] = c;
      this.data.array[a + 2] = d;
      return this;
    },
    setXYZW: function(a, b, c, d, e) {
      a = a * this.data.stride + this.offset;
      this.data.array[a + 0] = b;
      this.data.array[a + 1] = c;
      this.data.array[a + 2] = d;
      this.data.array[a + 3] = e;
      return this;
    }
  });
  Jb.prototype = Object.create(K.prototype);
  Jb.prototype.constructor = Jb;
  Jb.prototype.isSpriteMaterial = true;
  Jb.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.rotation = a.rotation;
    this.sizeAttenuation = a.sizeAttenuation;
    return this;
  };
  var Nc, Fe = new n(), yd = new n(), zd = new n(), Oc = new w(), Sd = new w(), ai = new O(), Nf = new n(), Ge = new n(), Of = new n(), Ri = new w(), oh = new w(), Si = new w();
  Rd.prototype = Object.assign(Object.create(D.prototype), { constructor: Rd, isSprite: true, raycast: function(a, b) {
    null === a.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    yd.setFromMatrixScale(this.matrixWorld);
    ai.copy(a.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(a.camera.matrixWorldInverse, this.matrixWorld);
    zd.setFromMatrixPosition(this.modelViewMatrix);
    a.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && yd.multiplyScalar(-zd.z);
    var c = this.material.rotation;
    if (0 !== c) {
      var d = Math.cos(c);
      var e = Math.sin(c);
    }
    c = this.center;
    Te(Nf.set(-0.5, -0.5, 0), zd, c, yd, e, d);
    Te(Ge.set(0.5, -0.5, 0), zd, c, yd, e, d);
    Te(Of.set(0.5, 0.5, 0), zd, c, yd, e, d);
    Ri.set(0, 0);
    oh.set(1, 0);
    Si.set(1, 1);
    var f = a.ray.intersectTriangle(Nf, Ge, Of, false, Fe);
    if (null === f && (Te(Ge.set(-0.5, 0.5, 0), zd, c, yd, e, d), oh.set(0, 1), f = a.ray.intersectTriangle(Nf, Of, Ge, false, Fe), null === f)) return;
    e = a.ray.origin.distanceTo(Fe);
    e < a.near || e > a.far || b.push({ distance: e, point: Fe.clone(), uv: oa.getUV(Fe, Nf, Ge, Of, Ri, oh, Si, new w()), face: null, object: this });
  }, clone: function() {
    return new this.constructor(this.material).copy(this);
  }, copy: function(a) {
    D.prototype.copy.call(this, a);
    void 0 !== a.center && this.center.copy(a.center);
    return this;
  } });
  var Pf = new n(), Ti = new n();
  Td.prototype = Object.assign(Object.create(D.prototype), { constructor: Td, isLOD: true, copy: function(a) {
    D.prototype.copy.call(this, a, false);
    for (var b = a.levels, c = 0, d = b.length; c < d; c++) {
      var e = b[c];
      this.addLevel(e.object.clone(), e.distance);
    }
    this.autoUpdate = a.autoUpdate;
    return this;
  }, addLevel: function(a, b) {
    void 0 === b && (b = 0);
    b = Math.abs(b);
    for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++) ;
    c.splice(d, 0, { distance: b, object: a });
    this.add(a);
    return this;
  }, getObjectForDistance: function(a) {
    var b = this.levels;
    if (0 < b.length) {
      for (var c = 1, d = b.length; c < d && !(a < b[c].distance); c++) ;
      return b[c - 1].object;
    }
    return null;
  }, raycast: function(a, b) {
    if (0 < this.levels.length) {
      Pf.setFromMatrixPosition(this.matrixWorld);
      var c = a.ray.origin.distanceTo(Pf);
      this.getObjectForDistance(c).raycast(a, b);
    }
  }, update: function(a) {
    var b = this.levels;
    if (1 < b.length) {
      Pf.setFromMatrixPosition(a.matrixWorld);
      Ti.setFromMatrixPosition(this.matrixWorld);
      a = Pf.distanceTo(Ti);
      b[0].object.visible = true;
      for (var c = 1, d = b.length; c < d; c++) if (a >= b[c].distance) b[c - 1].object.visible = false, b[c].object.visible = true;
      else break;
      for (; c < d; c++) b[c].object.visible = false;
    }
  }, toJSON: function(a) {
    a = D.prototype.toJSON.call(this, a);
    false === this.autoUpdate && (a.object.autoUpdate = false);
    a.object.levels = [];
    for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
      var e = b[c];
      a.object.levels.push({ object: e.object.uuid, distance: e.distance });
    }
    return a;
  } });
  Ud.prototype = Object.assign(Object.create(ca.prototype), { constructor: Ud, isSkinnedMesh: true, bind: function(a, b) {
    this.skeleton = a;
    void 0 === b && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), b = this.matrixWorld);
    this.bindMatrix.copy(b);
    this.bindMatrixInverse.getInverse(b);
  }, pose: function() {
    this.skeleton.pose();
  }, normalizeSkinWeights: function() {
    for (var a = new ia(), b = this.geometry.attributes.skinWeight, c = 0, d = b.count; c < d; c++) {
      a.x = b.getX(c);
      a.y = b.getY(c);
      a.z = b.getZ(c);
      a.w = b.getW(c);
      var e = 1 / a.manhattanLength();
      Infinity !== e ? a.multiplyScalar(e) : a.set(1, 0, 0, 0);
      b.setXYZW(c, a.x, a.y, a.z, a.w);
    }
  }, updateMatrixWorld: function(a) {
    ca.prototype.updateMatrixWorld.call(this, a);
    "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }, clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  } });
  var Ui = new O(), $k = new O();
  Object.assign(Ue.prototype, { calculateInverses: function() {
    this.boneInverses = [];
    for (var a = 0, b = this.bones.length; a < b; a++) {
      var c = new O();
      this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
      this.boneInverses.push(c);
    }
  }, pose: function() {
    var a, b;
    var c = 0;
    for (b = this.bones.length; c < b; c++) (a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
    c = 0;
    for (b = this.bones.length; c < b; c++) if (a = this.bones[c]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale);
  }, update: function() {
    for (var a = this.bones, b = this.boneInverses, c = this.boneMatrices, d = this.boneTexture, e = 0, f = a.length; e < f; e++) Ui.multiplyMatrices(a[e] ? a[e].matrixWorld : $k, b[e]), Ui.toArray(c, 16 * e);
    void 0 !== d && (d.needsUpdate = true);
  }, clone: function() {
    return new Ue(this.bones, this.boneInverses);
  }, getBoneByName: function(a) {
    for (var b = 0, c = this.bones.length; b < c; b++) {
      var d = this.bones[b];
      if (d.name === a) return d;
    }
  } });
  rg.prototype = Object.assign(Object.create(D.prototype), { constructor: rg, isBone: true });
  var Vi = new O(), Wi = new O(), Ad = [], He = new ca();
  Ve.prototype = Object.assign(Object.create(ca.prototype), { constructor: Ve, isInstancedMesh: true, getMatrixAt: function(a, b) {
    b.fromArray(this.instanceMatrix.array, 16 * a);
  }, raycast: function(a, b) {
    var c = this.matrixWorld, d = this.count;
    He.geometry = this.geometry;
    He.material = this.material;
    if (void 0 !== He.material) for (var e = 0; e < d; e++) this.getMatrixAt(e, Vi), Wi.multiplyMatrices(c, Vi), He.matrixWorld = Wi, He.raycast(a, Ad), 0 < Ad.length && (Ad[0].instanceId = e, Ad[0].object = this, b.push(Ad[0]), Ad.length = 0);
  }, setMatrixAt: function(a, b) {
    b.toArray(this.instanceMatrix.array, 16 * a);
  }, updateMorphTargets: function() {
  } });
  ka.prototype = Object.create(K.prototype);
  ka.prototype.constructor = ka;
  ka.prototype.isLineBasicMaterial = true;
  ka.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.linewidth = a.linewidth;
    this.linecap = a.linecap;
    this.linejoin = a.linejoin;
    return this;
  };
  var Xi = new n(), Yi = new n(), Zi = new O(), Qf = new Wb(), Ie = new qb();
  La.prototype = Object.assign(Object.create(D.prototype), { constructor: La, isLine: true, computeLineDistances: function() {
    var a = this.geometry;
    if (a.isBufferGeometry) if (null === a.index) {
      for (var b = a.attributes.position, c = [0], d = 1, e = b.count; d < e; d++) Xi.fromBufferAttribute(b, d - 1), Yi.fromBufferAttribute(b, d), c[d] = c[d - 1], c[d] += Xi.distanceTo(Yi);
      a.setAttribute("lineDistance", new E(c, 1));
    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (a.isGeometry) for (b = a.vertices, c = a.lineDistances, c[0] = 0, d = 1, e = b.length; d < e; d++) c[d] = c[d - 1], c[d] += b[d - 1].distanceTo(b[d]);
    return this;
  }, raycast: function(a, b) {
    var c = a.linePrecision, d = this.geometry, e = this.matrixWorld;
    null === d.boundingSphere && d.computeBoundingSphere();
    Ie.copy(d.boundingSphere);
    Ie.applyMatrix4(e);
    Ie.radius += c;
    if (false !== a.ray.intersectsSphere(Ie)) {
      Zi.getInverse(e);
      Qf.copy(a.ray).applyMatrix4(Zi);
      c /= (this.scale.x + this.scale.y + this.scale.z) / 3;
      c *= c;
      var f = new n(), g = new n();
      e = new n();
      var k = new n(), h2 = this && this.isLineSegments ? 2 : 1;
      if (d.isBufferGeometry) {
        var m = d.index, x = d.attributes.position.array;
        if (null !== m) {
          m = m.array;
          d = 0;
          for (var p = m.length - 1; d < p; d += h2) {
            var q = m[d + 1];
            f.fromArray(x, 3 * m[d]);
            g.fromArray(x, 3 * q);
            q = Qf.distanceSqToSegment(f, g, k, e);
            q > c || (k.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(k), q < a.near || q > a.far || b.push({ distance: q, point: e.clone().applyMatrix4(this.matrixWorld), index: d, face: null, faceIndex: null, object: this }));
          }
        } else for (d = 0, p = x.length / 3 - 1; d < p; d += h2) f.fromArray(x, 3 * d), g.fromArray(x, 3 * d + 3), q = Qf.distanceSqToSegment(f, g, k, e), q > c || (k.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(k), q < a.near || q > a.far || b.push({ distance: q, point: e.clone().applyMatrix4(this.matrixWorld), index: d, face: null, faceIndex: null, object: this }));
      } else if (d.isGeometry) for (f = d.vertices, g = f.length, d = 0; d < g - 1; d += h2) q = Qf.distanceSqToSegment(f[d], f[d + 1], k, e), q > c || (k.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(k), q < a.near || q > a.far || b.push({
        distance: q,
        point: e.clone().applyMatrix4(this.matrixWorld),
        index: d,
        face: null,
        faceIndex: null,
        object: this
      }));
    }
  }, clone: function() {
    return new this.constructor(this.geometry, this.material).copy(this);
  } });
  var Rf = new n(), Sf = new n();
  ma.prototype = Object.assign(Object.create(La.prototype), { constructor: ma, isLineSegments: true, computeLineDistances: function() {
    var a = this.geometry;
    if (a.isBufferGeometry) if (null === a.index) {
      for (var b = a.attributes.position, c = [], d = 0, e = b.count; d < e; d += 2) Rf.fromBufferAttribute(b, d), Sf.fromBufferAttribute(b, d + 1), c[d] = 0 === d ? 0 : c[d - 1], c[d + 1] = c[d] + Rf.distanceTo(Sf);
      a.setAttribute("lineDistance", new E(c, 1));
    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    else if (a.isGeometry) for (b = a.vertices, c = a.lineDistances, d = 0, e = b.length; d < e; d += 2) Rf.copy(b[d]), Sf.copy(b[d + 1]), c[d] = 0 === d ? 0 : c[d - 1], c[d + 1] = c[d] + Rf.distanceTo(Sf);
    return this;
  } });
  We.prototype = Object.assign(Object.create(La.prototype), { constructor: We, isLineLoop: true });
  Wa.prototype = Object.create(K.prototype);
  Wa.prototype.constructor = Wa;
  Wa.prototype.isPointsMaterial = true;
  Wa.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.alphaMap = a.alphaMap;
    this.size = a.size;
    this.sizeAttenuation = a.sizeAttenuation;
    this.morphTargets = a.morphTargets;
    return this;
  };
  var $i = new O(), tg = new Wb(), Je = new qb(), Tf = new n();
  Pc.prototype = Object.assign(Object.create(D.prototype), { constructor: Pc, isPoints: true, raycast: function(a, b) {
    var c = this.geometry, d = this.matrixWorld, e = a.params.Points.threshold;
    null === c.boundingSphere && c.computeBoundingSphere();
    Je.copy(c.boundingSphere);
    Je.applyMatrix4(d);
    Je.radius += e;
    if (false !== a.ray.intersectsSphere(Je)) if ($i.getInverse(d), tg.copy(a.ray).applyMatrix4($i), e /= (this.scale.x + this.scale.y + this.scale.z) / 3, e *= e, c.isBufferGeometry) {
      var f = c.index;
      c = c.attributes.position.array;
      if (null !== f) {
        var g = f.array;
        f = 0;
        for (var k = g.length; f < k; f++) {
          var h2 = g[f];
          Tf.fromArray(c, 3 * h2);
          sg(Tf, h2, e, d, a, b, this);
        }
      } else for (f = 0, g = c.length / 3; f < g; f++) Tf.fromArray(c, 3 * f), sg(Tf, f, e, d, a, b, this);
    } else for (c = c.vertices, f = 0, g = c.length; f < g; f++) sg(c[f], f, e, d, a, b, this);
  }, updateMorphTargets: function() {
    var a = this.geometry;
    if (a.isBufferGeometry) {
      a = a.morphAttributes;
      var b = Object.keys(a);
      if (0 < b.length) {
        var c = a[b[0]];
        if (void 0 !== c) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
          var d = c[a].name || String(a);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[d] = a;
        }
      }
    } else a = a.morphTargets, void 0 !== a && 0 < a.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
  }, clone: function() {
    return new this.constructor(
      this.geometry,
      this.material
    ).copy(this);
  } });
  ug.prototype = Object.assign(Object.create(Z.prototype), { constructor: ug, isVideoTexture: true, update: function() {
    var a = this.image;
    a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = true);
  } });
  Qc.prototype = Object.create(Z.prototype);
  Qc.prototype.constructor = Qc;
  Qc.prototype.isCompressedTexture = true;
  Vd.prototype = Object.create(Z.prototype);
  Vd.prototype.constructor = Vd;
  Vd.prototype.isCanvasTexture = true;
  Wd.prototype = Object.create(Z.prototype);
  Wd.prototype.constructor = Wd;
  Wd.prototype.isDepthTexture = true;
  Rc.prototype = Object.create(A.prototype);
  Rc.prototype.constructor = Rc;
  Xd.prototype = Object.create(L.prototype);
  Xd.prototype.constructor = Xd;
  Sc.prototype = Object.create(A.prototype);
  Sc.prototype.constructor = Sc;
  Yd.prototype = Object.create(L.prototype);
  Yd.prototype.constructor = Yd;
  Ja.prototype = Object.create(A.prototype);
  Ja.prototype.constructor = Ja;
  Zd.prototype = Object.create(L.prototype);
  Zd.prototype.constructor = Zd;
  Tc.prototype = Object.create(Ja.prototype);
  Tc.prototype.constructor = Tc;
  $d.prototype = Object.create(L.prototype);
  $d.prototype.constructor = $d;
  dc.prototype = Object.create(Ja.prototype);
  dc.prototype.constructor = dc;
  ae.prototype = Object.create(L.prototype);
  ae.prototype.constructor = ae;
  Uc.prototype = Object.create(Ja.prototype);
  Uc.prototype.constructor = Uc;
  be.prototype = Object.create(L.prototype);
  be.prototype.constructor = be;
  Vc.prototype = Object.create(Ja.prototype);
  Vc.prototype.constructor = Vc;
  ce.prototype = Object.create(L.prototype);
  ce.prototype.constructor = ce;
  ec.prototype = Object.create(A.prototype);
  ec.prototype.constructor = ec;
  ec.prototype.toJSON = function() {
    var a = A.prototype.toJSON.call(this);
    a.path = this.parameters.path.toJSON();
    return a;
  };
  de.prototype = Object.create(L.prototype);
  de.prototype.constructor = de;
  Wc.prototype = Object.create(A.prototype);
  Wc.prototype.constructor = Wc;
  ee.prototype = Object.create(L.prototype);
  ee.prototype.constructor = ee;
  Xc.prototype = Object.create(A.prototype);
  Xc.prototype.constructor = Xc;
  var al = { triangulate: function(a, b, c) {
    c = c || 2;
    var d = b && b.length, e = d ? b[0] * c : a.length, f = bi(a, 0, e, c, true), g = [];
    if (!f || f.next === f.prev) return g;
    var k;
    if (d) {
      var h2 = c;
      d = [];
      var m;
      var n2 = 0;
      for (m = b.length; n2 < m; n2++) {
        var p = b[n2] * h2;
        var q = n2 < m - 1 ? b[n2 + 1] * h2 : a.length;
        p = bi(a, p, q, h2, false);
        p === p.next && (p.steiner = true);
        d.push(Nk(p));
      }
      d.sort(Lk);
      for (n2 = 0; n2 < d.length; n2++) {
        b = d[n2];
        h2 = f;
        if (h2 = Mk(b, h2)) b = ei(h2, b), ge(b, b.next);
        f = ge(f, f.next);
      }
    }
    if (a.length > 80 * c) {
      var t = k = a[0];
      var r = d = a[1];
      for (h2 = c; h2 < e; h2 += c) n2 = a[h2], b = a[h2 + 1], n2 < t && (t = n2), b < r && (r = b), n2 > k && (k = n2), b > d && (d = b);
      k = Math.max(k - t, d - r);
      k = 0 !== k ? 1 / k : 0;
    }
    he(f, g, c, t, r, k);
    return g;
  } }, tb = { area: function(a) {
    for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
    return 0.5 * c;
  }, isClockWise: function(a) {
    return 0 > tb.area(a);
  }, triangulateShape: function(a, b) {
    var c = [], d = [], e = [];
    fi(a);
    gi(c, a);
    var f = a.length;
    b.forEach(fi);
    for (a = 0; a < b.length; a++) d.push(f), f += b[a].length, gi(c, b[a]);
    b = al.triangulate(c, d);
    for (a = 0; a < b.length; a += 3) e.push(b.slice(a, a + 3));
    return e;
  } };
  gc.prototype = Object.create(L.prototype);
  gc.prototype.constructor = gc;
  gc.prototype.toJSON = function() {
    var a = L.prototype.toJSON.call(this);
    return hi(
      this.parameters.shapes,
      this.parameters.options,
      a
    );
  };
  gb.prototype = Object.create(A.prototype);
  gb.prototype.constructor = gb;
  gb.prototype.toJSON = function() {
    var a = A.prototype.toJSON.call(this);
    return hi(this.parameters.shapes, this.parameters.options, a);
  };
  var Ok = { generateTopUV: function(a, b, c, d, e) {
    a = b[3 * d];
    d = b[3 * d + 1];
    var f = b[3 * e];
    e = b[3 * e + 1];
    return [new w(b[3 * c], b[3 * c + 1]), new w(a, d), new w(f, e)];
  }, generateSideWallUV: function(a, b, c, d, e, f) {
    a = b[3 * c];
    var g = b[3 * c + 1];
    c = b[3 * c + 2];
    var k = b[3 * d], h2 = b[3 * d + 1];
    d = b[3 * d + 2];
    var m = b[3 * e], n2 = b[3 * e + 1];
    e = b[3 * e + 2];
    var p = b[3 * f], q = b[3 * f + 1];
    b = b[3 * f + 2];
    return 0.01 > Math.abs(g - h2) ? [new w(a, 1 - c), new w(k, 1 - d), new w(m, 1 - e), new w(p, 1 - b)] : [new w(g, 1 - c), new w(h2, 1 - d), new w(n2, 1 - e), new w(q, 1 - b)];
  } };
  je.prototype = Object.create(L.prototype);
  je.prototype.constructor = je;
  Zc.prototype = Object.create(gb.prototype);
  Zc.prototype.constructor = Zc;
  ke.prototype = Object.create(L.prototype);
  ke.prototype.constructor = ke;
  hc.prototype = Object.create(A.prototype);
  hc.prototype.constructor = hc;
  le.prototype = Object.create(L.prototype);
  le.prototype.constructor = le;
  $c.prototype = Object.create(A.prototype);
  $c.prototype.constructor = $c;
  me.prototype = Object.create(L.prototype);
  me.prototype.constructor = me;
  ad.prototype = Object.create(A.prototype);
  ad.prototype.constructor = ad;
  ic.prototype = Object.create(L.prototype);
  ic.prototype.constructor = ic;
  ic.prototype.toJSON = function() {
    var a = L.prototype.toJSON.call(this);
    return ii(this.parameters.shapes, a);
  };
  jc.prototype = Object.create(A.prototype);
  jc.prototype.constructor = jc;
  jc.prototype.toJSON = function() {
    var a = A.prototype.toJSON.call(this);
    return ii(this.parameters.shapes, a);
  };
  bd.prototype = Object.create(A.prototype);
  bd.prototype.constructor = bd;
  kc.prototype = Object.create(L.prototype);
  kc.prototype.constructor = kc;
  ub.prototype = Object.create(A.prototype);
  ub.prototype.constructor = ub;
  ne.prototype = Object.create(kc.prototype);
  ne.prototype.constructor = ne;
  oe.prototype = Object.create(ub.prototype);
  oe.prototype.constructor = oe;
  pe.prototype = Object.create(L.prototype);
  pe.prototype.constructor = pe;
  cd.prototype = Object.create(A.prototype);
  cd.prototype.constructor = cd;
  var va = Object.freeze({
    __proto__: null,
    WireframeGeometry: Rc,
    ParametricGeometry: Xd,
    ParametricBufferGeometry: Sc,
    TetrahedronGeometry: Zd,
    TetrahedronBufferGeometry: Tc,
    OctahedronGeometry: $d,
    OctahedronBufferGeometry: dc,
    IcosahedronGeometry: ae,
    IcosahedronBufferGeometry: Uc,
    DodecahedronGeometry: be,
    DodecahedronBufferGeometry: Vc,
    PolyhedronGeometry: Yd,
    PolyhedronBufferGeometry: Ja,
    TubeGeometry: ce,
    TubeBufferGeometry: ec,
    TorusKnotGeometry: de,
    TorusKnotBufferGeometry: Wc,
    TorusGeometry: ee,
    TorusBufferGeometry: Xc,
    TextGeometry: je,
    TextBufferGeometry: Zc,
    SphereGeometry: ke,
    SphereBufferGeometry: hc,
    RingGeometry: le,
    RingBufferGeometry: $c,
    PlaneGeometry: Jd,
    PlaneBufferGeometry: cc,
    LatheGeometry: me,
    LatheBufferGeometry: ad,
    ShapeGeometry: ic,
    ShapeBufferGeometry: jc,
    ExtrudeGeometry: gc,
    ExtrudeBufferGeometry: gb,
    EdgesGeometry: bd,
    ConeGeometry: ne,
    ConeBufferGeometry: oe,
    CylinderGeometry: kc,
    CylinderBufferGeometry: ub,
    CircleGeometry: pe,
    CircleBufferGeometry: cd,
    BoxGeometry: nh,
    BoxBufferGeometry: Kd
  });
  lc.prototype = Object.create(K.prototype);
  lc.prototype.constructor = lc;
  lc.prototype.isShadowMaterial = true;
  lc.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.color.copy(a.color);
    return this;
  };
  vb.prototype = Object.create(qa.prototype);
  vb.prototype.constructor = vb;
  vb.prototype.isRawShaderMaterial = true;
  hb.prototype = Object.create(K.prototype);
  hb.prototype.constructor = hb;
  hb.prototype.isMeshStandardMaterial = true;
  hb.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.defines = { STANDARD: "" };
    this.color.copy(a.color);
    this.roughness = a.roughness;
    this.metalness = a.metalness;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.roughnessMap = a.roughnessMap;
    this.metalnessMap = a.metalnessMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.envMapIntensity = a.envMapIntensity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  mc.prototype = Object.create(hb.prototype);
  mc.prototype.constructor = mc;
  mc.prototype.isMeshPhysicalMaterial = true;
  mc.prototype.copy = function(a) {
    hb.prototype.copy.call(this, a);
    this.defines = { STANDARD: "", PHYSICAL: "" };
    this.reflectivity = a.reflectivity;
    this.clearcoat = a.clearcoat;
    this.clearcoatRoughness = a.clearcoatRoughness;
    this.sheen = a.sheen ? (this.sheen || new B()).copy(a.sheen) : null;
    this.clearcoatNormalMap = a.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(a.clearcoatNormalScale);
    this.transparency = a.transparency;
    return this;
  };
  Kb.prototype = Object.create(K.prototype);
  Kb.prototype.constructor = Kb;
  Kb.prototype.isMeshPhongMaterial = true;
  Kb.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.specular.copy(a.specular);
    this.shininess = a.shininess;
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  nc.prototype = Object.create(K.prototype);
  nc.prototype.constructor = nc;
  nc.prototype.isMeshToonMaterial = true;
  nc.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.specular.copy(a.specular);
    this.shininess = a.shininess;
    this.map = a.map;
    this.gradientMap = a.gradientMap;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  oc.prototype = Object.create(K.prototype);
  oc.prototype.constructor = oc;
  oc.prototype.isMeshNormalMaterial = true;
  oc.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  pc.prototype = Object.create(K.prototype);
  pc.prototype.constructor = pc;
  pc.prototype.isMeshLambertMaterial = true;
  pc.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.map = a.map;
    this.lightMap = a.lightMap;
    this.lightMapIntensity = a.lightMapIntensity;
    this.aoMap = a.aoMap;
    this.aoMapIntensity = a.aoMapIntensity;
    this.emissive.copy(a.emissive);
    this.emissiveMap = a.emissiveMap;
    this.emissiveIntensity = a.emissiveIntensity;
    this.specularMap = a.specularMap;
    this.alphaMap = a.alphaMap;
    this.envMap = a.envMap;
    this.combine = a.combine;
    this.reflectivity = a.reflectivity;
    this.refractionRatio = a.refractionRatio;
    this.wireframe = a.wireframe;
    this.wireframeLinewidth = a.wireframeLinewidth;
    this.wireframeLinecap = a.wireframeLinecap;
    this.wireframeLinejoin = a.wireframeLinejoin;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  qc.prototype = Object.create(K.prototype);
  qc.prototype.constructor = qc;
  qc.prototype.isMeshMatcapMaterial = true;
  qc.prototype.copy = function(a) {
    K.prototype.copy.call(this, a);
    this.defines = { MATCAP: "" };
    this.color.copy(a.color);
    this.matcap = a.matcap;
    this.map = a.map;
    this.bumpMap = a.bumpMap;
    this.bumpScale = a.bumpScale;
    this.normalMap = a.normalMap;
    this.normalMapType = a.normalMapType;
    this.normalScale.copy(a.normalScale);
    this.displacementMap = a.displacementMap;
    this.displacementScale = a.displacementScale;
    this.displacementBias = a.displacementBias;
    this.alphaMap = a.alphaMap;
    this.skinning = a.skinning;
    this.morphTargets = a.morphTargets;
    this.morphNormals = a.morphNormals;
    return this;
  };
  rc.prototype = Object.create(ka.prototype);
  rc.prototype.constructor = rc;
  rc.prototype.isLineDashedMaterial = true;
  rc.prototype.copy = function(a) {
    ka.prototype.copy.call(this, a);
    this.scale = a.scale;
    this.dashSize = a.dashSize;
    this.gapSize = a.gapSize;
    return this;
  };
  var bl = Object.freeze({ __proto__: null, ShadowMaterial: lc, SpriteMaterial: Jb, RawShaderMaterial: vb, ShaderMaterial: qa, PointsMaterial: Wa, MeshPhysicalMaterial: mc, MeshStandardMaterial: hb, MeshPhongMaterial: Kb, MeshToonMaterial: nc, MeshNormalMaterial: oc, MeshLambertMaterial: pc, MeshDepthMaterial: Gb, MeshDistanceMaterial: Hb, MeshBasicMaterial: Pa, MeshMatcapMaterial: qc, LineDashedMaterial: rc, LineBasicMaterial: ka, Material: K }), ea = { arraySlice: function(a, b, c) {
    return ea.isTypedArray(a) ? new a.constructor(a.subarray(
      b,
      void 0 !== c ? c : a.length
    )) : a.slice(b, c);
  }, convertArray: function(a, b, c) {
    return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a);
  }, isTypedArray: function(a) {
    return ArrayBuffer.isView(a) && !(a instanceof DataView);
  }, getKeyframeOrder: function(a) {
    for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
    c.sort(function(b2, c2) {
      return a[b2] - a[c2];
    });
    return c;
  }, sortedArray: function(a, b, c) {
    for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f) for (var k = c[f] * b, h2 = 0; h2 !== b; ++h2) e[g++] = a[k + h2];
    return e;
  }, flattenJSON: function(a, b, c, d) {
    for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d]; ) f = a[e++];
    if (void 0 !== f) {
      var g = f[d];
      if (void 0 !== g) if (Array.isArray(g)) {
        do
          g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++];
        while (void 0 !== f);
      } else if (void 0 !== g.toArray) {
        do
          g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++];
        while (void 0 !== f);
      } else {
        do
          g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++];
        while (void 0 !== f);
      }
    }
  }, subclip: function(a, b, c, d, e) {
    e = e || 30;
    a = a.clone();
    a.name = b;
    var f = [];
    for (b = 0; b < a.tracks.length; ++b) {
      for (var g = a.tracks[b], k = g.getValueSize(), h2 = [], m = [], n2 = 0; n2 < g.times.length; ++n2) {
        var p = g.times[n2] * e;
        if (!(p < c || p >= d)) for (h2.push(g.times[n2]), p = 0; p < k; ++p) m.push(g.values[n2 * k + p]);
      }
      0 !== h2.length && (g.times = ea.convertArray(h2, g.times.constructor), g.values = ea.convertArray(m, g.values.constructor), f.push(g));
    }
    a.tracks = f;
    c = Infinity;
    for (b = 0; b < a.tracks.length; ++b) c > a.tracks[b].times[0] && (c = a.tracks[b].times[0]);
    for (b = 0; b < a.tracks.length; ++b) a.tracks[b].shift(-1 * c);
    a.resetDuration();
    return a;
  } };
  Object.assign(Ma.prototype, { evaluate: function(a) {
    var b = this.parameterPositions, c = this._cachedIndex, d = b[c], e = b[c - 1];
    a: {
      b: {
        c: {
          d: if (!(a < d)) {
            for (var f = c + 2; ; ) {
              if (void 0 === d) {
                if (a < e) break d;
                this._cachedIndex = c = b.length;
                return this.afterEnd_(c - 1, a, e);
              }
              if (c === f) break;
              e = d;
              d = b[++c];
              if (a < d) break b;
            }
            d = b.length;
            break c;
          }
          if (a >= e) break a;
          else {
            f = b[1];
            a < f && (c = 2, e = f);
            for (f = c - 2; ; ) {
              if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
              if (c === f) break;
              d = e;
              e = b[--c - 1];
              if (a >= e) break b;
            }
            d = c;
            c = 0;
          }
        }
        for (; c < d; ) e = c + d >>> 1, a < b[e] ? d = e : c = e + 1;
        d = b[c];
        e = b[c - 1];
        if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
        if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a);
      }
      this._cachedIndex = c;
      this.intervalChanged_(c, e, d);
    }
    return this.interpolate_(c, e, a, d);
  }, settings: null, DefaultSettings_: {}, getSettings_: function() {
    return this.settings || this.DefaultSettings_;
  }, copySampleValue_: function(a) {
    var b = this.resultBuffer, c = this.sampleValues, d = this.valueSize;
    a *= d;
    for (var e = 0; e !== d; ++e) b[e] = c[a + e];
    return b;
  }, interpolate_: function() {
    throw Error("call to abstract method");
  }, intervalChanged_: function() {
  } });
  Object.assign(Ma.prototype, { beforeStart_: Ma.prototype.copySampleValue_, afterEnd_: Ma.prototype.copySampleValue_ });
  Xe.prototype = Object.assign(Object.create(Ma.prototype), { constructor: Xe, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function(a, b, c) {
    var d = this.parameterPositions, e = a - 2, f = a + 1, g = d[e], k = d[f];
    if (void 0 === g) switch (this.getSettings_().endingStart) {
      case 2401:
        e = a;
        g = 2 * b - c;
        break;
      case 2402:
        e = d.length - 2;
        g = b + d[e] - d[e + 1];
        break;
      default:
        e = a, g = c;
    }
    if (void 0 === k) switch (this.getSettings_().endingEnd) {
      case 2401:
        f = a;
        k = 2 * c - b;
        break;
      case 2402:
        f = 1;
        k = c + d[1] - d[0];
        break;
      default:
        f = a - 1, k = b;
    }
    a = 0.5 * (c - b);
    d = this.valueSize;
    this._weightPrev = a / (b - g);
    this._weightNext = a / (k - c);
    this._offsetPrev = e * d;
    this._offsetNext = f * d;
  }, interpolate_: function(a, b, c, d) {
    var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
    a *= g;
    var k = a - g, h2 = this._offsetPrev, m = this._offsetNext, n2 = this._weightPrev, p = this._weightNext, q = (c - b) / (d - b);
    c = q * q;
    d = c * q;
    b = -n2 * d + 2 * n2 * c - n2 * q;
    n2 = (1 + n2) * d + (-1.5 - 2 * n2) * c + (-0.5 + n2) * q + 1;
    q = (-1 - p) * d + (1.5 + p) * c + 0.5 * q;
    p = p * d - p * c;
    for (c = 0; c !== g; ++c) e[c] = b * f[h2 + c] + n2 * f[k + c] + q * f[a + c] + p * f[m + c];
    return e;
  } });
  qe.prototype = Object.assign(Object.create(Ma.prototype), { constructor: qe, interpolate_: function(a, b, c, d) {
    var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
    a *= g;
    var k = a - g;
    b = (c - b) / (d - b);
    c = 1 - b;
    for (d = 0; d !== g; ++d) e[d] = f[k + d] * c + f[a + d] * b;
    return e;
  } });
  Ye.prototype = Object.assign(Object.create(Ma.prototype), {
    constructor: Ye,
    interpolate_: function(a) {
      return this.copySampleValue_(a - 1);
    }
  });
  Object.assign(ua, { toJSON: function(a) {
    var b = a.constructor;
    if (void 0 !== b.toJSON) b = b.toJSON(a);
    else {
      b = { name: a.name, times: ea.convertArray(a.times, Array), values: ea.convertArray(a.values, Array) };
      var c = a.getInterpolation();
      c !== a.DefaultInterpolation && (b.interpolation = c);
    }
    b.type = a.ValueTypeName;
    return b;
  } });
  Object.assign(ua.prototype, { constructor: ua, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function(a) {
    return new Ye(
      this.times,
      this.values,
      this.getValueSize(),
      a
    );
  }, InterpolantFactoryMethodLinear: function(a) {
    return new qe(this.times, this.values, this.getValueSize(), a);
  }, InterpolantFactoryMethodSmooth: function(a) {
    return new Xe(this.times, this.values, this.getValueSize(), a);
  }, setInterpolation: function(a) {
    switch (a) {
      case 2300:
        var b = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        b = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        b = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === b) {
      b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
      else throw Error(b);
      console.warn("THREE.KeyframeTrack:", b);
      return this;
    }
    this.createInterpolant = b;
    return this;
  }, getInterpolation: function() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }, getValueSize: function() {
    return this.values.length / this.times.length;
  }, shift: function(a) {
    if (0 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
    return this;
  }, scale: function(a) {
    if (1 !== a) for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
    return this;
  }, trim: function(a, b) {
    for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a; ) ++e;
    for (; -1 !== f && c[f] > b; ) --f;
    ++f;
    if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), a = this.getValueSize(), this.times = ea.arraySlice(c, e, f), this.values = ea.arraySlice(this.values, e * a, f * a);
    return this;
  }, validate: function() {
    var a = true, b = this.getValueSize();
    0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = false);
    var c = this.times;
    b = this.values;
    var d = c.length;
    0 === d && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = false);
    for (var e = null, f = 0; f !== d; f++) {
      var g = c[f];
      if ("number" === typeof g && isNaN(g)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, g);
        a = false;
        break;
      }
      if (null !== e && e > g) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, f, g, e);
        a = false;
        break;
      }
      e = g;
    }
    if (void 0 !== b && ea.isTypedArray(b)) {
      for (f = 0, c = b.length; f !== c; ++f) if (d = b[f], isNaN(d)) {
        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, d);
        a = false;
        break;
      }
    }
    return a;
  }, optimize: function() {
    for (var a = ea.arraySlice(this.times), b = ea.arraySlice(this.values), c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, f = a.length - 1, g = 1; g < f; ++g) {
      var k = false, h2 = a[g];
      if (h2 !== a[g + 1] && (1 !== g || h2 !== h2[0])) if (d) k = true;
      else {
        var m = g * c, n2 = m - c, p = m + c;
        for (h2 = 0; h2 !== c; ++h2) {
          var q = b[m + h2];
          if (q !== b[n2 + h2] || q !== b[p + h2]) {
            k = true;
            break;
          }
        }
      }
      if (k) {
        if (g !== e) for (a[e] = a[g], k = g * c, m = e * c, h2 = 0; h2 !== c; ++h2) b[m + h2] = b[k + h2];
        ++e;
      }
    }
    if (0 < f) {
      a[e] = a[f];
      k = f * c;
      m = e * c;
      for (h2 = 0; h2 !== c; ++h2) b[m + h2] = b[k + h2];
      ++e;
    }
    e !== a.length ? (this.times = ea.arraySlice(a, 0, e), this.values = ea.arraySlice(b, 0, e * c)) : (this.times = a, this.values = b);
    return this;
  }, clone: function() {
    var a = ea.arraySlice(this.times, 0), b = ea.arraySlice(this.values, 0);
    a = new this.constructor(this.name, a, b);
    a.createInterpolant = this.createInterpolant;
    return a;
  } });
  Ze.prototype = Object.assign(
    Object.create(ua.prototype),
    { constructor: Ze, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }
  );
  $e.prototype = Object.assign(Object.create(ua.prototype), { constructor: $e, ValueTypeName: "color" });
  dd.prototype = Object.assign(Object.create(ua.prototype), { constructor: dd, ValueTypeName: "number" });
  af.prototype = Object.assign(Object.create(Ma.prototype), { constructor: af, interpolate_: function(a, b, c, d) {
    var e = this.resultBuffer, f = this.sampleValues, g = this.valueSize;
    a *= g;
    b = (c - b) / (d - b);
    for (c = a + g; a !== c; a += 4) Da.slerpFlat(e, 0, f, a - g, f, a, b);
    return e;
  } });
  re.prototype = Object.assign(Object.create(ua.prototype), { constructor: re, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function(a) {
    return new af(this.times, this.values, this.getValueSize(), a);
  }, InterpolantFactoryMethodSmooth: void 0 });
  bf.prototype = Object.assign(Object.create(ua.prototype), {
    constructor: bf,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: 2300,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  });
  ed.prototype = Object.assign(Object.create(ua.prototype), { constructor: ed, ValueTypeName: "vector" });
  Object.assign(Ra, { parse: function(a) {
    for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(Qk(c[e]).scale(d));
    return new Ra(a.name, a.duration, b);
  }, toJSON: function(a) {
    var b = [], c = a.tracks;
    a = { name: a.name, duration: a.duration, tracks: b, uuid: a.uuid };
    for (var d = 0, e = c.length; d !== e; ++d) b.push(ua.toJSON(c[d]));
    return a;
  }, CreateFromMorphTargetSequence: function(a, b, c, d) {
    for (var e = b.length, f = [], g = 0; g < e; g++) {
      var k = [], h2 = [];
      k.push((g + e - 1) % e, g, (g + 1) % e);
      h2.push(0, 1, 0);
      var m = ea.getKeyframeOrder(k);
      k = ea.sortedArray(k, 1, m);
      h2 = ea.sortedArray(h2, 1, m);
      d || 0 !== k[0] || (k.push(e), h2.push(h2[0]));
      f.push(new dd(".morphTargetInfluences[" + b[g].name + "]", k, h2).scale(1 / c));
    }
    return new Ra(a, -1, f);
  }, findByName: function(a, b) {
    var c = a;
    Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
    for (a = 0; a < c.length; a++) if (c[a].name === b) return c[a];
    return null;
  }, CreateClipsFromMorphTargetSequences: function(a, b, c) {
    for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
      var k = a[f], h2 = k.name.match(e);
      if (h2 && 1 < h2.length) {
        var m = h2[1];
        (h2 = d[m]) || (d[m] = h2 = []);
        h2.push(k);
      }
    }
    a = [];
    for (m in d) a.push(Ra.CreateFromMorphTargetSequence(m, d[m], b, c));
    return a;
  }, parseAnimation: function(a, b) {
    if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    var c = function(a2, b2, c2, d2, e2) {
      if (0 !== c2.length) {
        var f2 = [], g2 = [];
        ea.flattenJSON(c2, f2, g2, d2);
        0 !== f2.length && e2.push(new a2(b2, f2, g2));
      }
    }, d = [], e = a.name || "default", f = a.length || -1, g = a.fps || 30;
    a = a.hierarchy || [];
    for (var k = 0; k < a.length; k++) {
      var h2 = a[k].keys;
      if (h2 && 0 !== h2.length) if (h2[0].morphTargets) {
        f = {};
        for (var m = 0; m < h2.length; m++) if (h2[m].morphTargets) for (var n2 = 0; n2 < h2[m].morphTargets.length; n2++) f[h2[m].morphTargets[n2]] = -1;
        for (var p in f) {
          var q = [], t = [];
          for (n2 = 0; n2 !== h2[m].morphTargets.length; ++n2) {
            var r = h2[m];
            q.push(r.time);
            t.push(r.morphTarget === p ? 1 : 0);
          }
          d.push(new dd(".morphTargetInfluence[" + p + "]", q, t));
        }
        f = f.length * (g || 1);
      } else m = ".bones[" + b[k].name + "]", c(ed, m + ".position", h2, "pos", d), c(
        re,
        m + ".quaternion",
        h2,
        "rot",
        d
      ), c(ed, m + ".scale", h2, "scl", d);
    }
    return 0 === d.length ? null : new Ra(e, f, d);
  } });
  Object.assign(Ra.prototype, { resetDuration: function() {
    for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
      var d = this.tracks[b];
      a = Math.max(a, d.times[d.times.length - 1]);
    }
    this.duration = a;
    return this;
  }, trim: function() {
    for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
    return this;
  }, validate: function() {
    for (var a = true, b = 0; b < this.tracks.length; b++) a = a && this.tracks[b].validate();
    return a;
  }, optimize: function() {
    for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
    return this;
  }, clone: function() {
    for (var a = [], b = 0; b < this.tracks.length; b++) a.push(this.tracks[b].clone());
    return new Ra(this.name, this.duration, a);
  } });
  var vc = { enabled: false, files: {}, add: function(a, b) {
    false !== this.enabled && (this.files[a] = b);
  }, get: function(a) {
    if (false !== this.enabled) return this.files[a];
  }, remove: function(a) {
    delete this.files[a];
  }, clear: function() {
    this.files = {};
  } }, ji = new xg();
  Object.assign(V.prototype, { load: function() {
  }, parse: function() {
  }, setCrossOrigin: function(a) {
    this.crossOrigin = a;
    return this;
  }, setPath: function(a) {
    this.path = a;
    return this;
  }, setResourcePath: function(a) {
    this.resourcePath = a;
    return this;
  } });
  var db = {};
  Sa.prototype = Object.assign(Object.create(V.prototype), { constructor: Sa, load: function(a, b, c, d) {
    void 0 === a && (a = "");
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var e = this, f = vc.get(a);
    if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
      b && b(f);
      e.manager.itemEnd(a);
    }, 0), f;
    if (void 0 !== db[a]) db[a].push({ onLoad: b, onProgress: c, onError: d });
    else {
      var g = a.match(/^data:(.*?)(;base64)?,(.*)$/);
      if (g) {
        c = g[1];
        var k = !!g[2];
        g = g[3];
        g = decodeURIComponent(g);
        k && (g = atob(g));
        try {
          var h2 = (this.responseType || "").toLowerCase();
          switch (h2) {
            case "arraybuffer":
            case "blob":
              var m = new Uint8Array(g.length);
              for (k = 0; k < g.length; k++) m[k] = g.charCodeAt(k);
              var n2 = "blob" === h2 ? new Blob([m.buffer], { type: c }) : m.buffer;
              break;
            case "document":
              n2 = new DOMParser().parseFromString(g, c);
              break;
            case "json":
              n2 = JSON.parse(g);
              break;
            default:
              n2 = g;
          }
          setTimeout(function() {
            b && b(n2);
            e.manager.itemEnd(a);
          }, 0);
        } catch (q) {
          setTimeout(function() {
            d && d(q);
            e.manager.itemError(a);
            e.manager.itemEnd(a);
          }, 0);
        }
      } else {
        db[a] = [];
        db[a].push({ onLoad: b, onProgress: c, onError: d });
        var p = new XMLHttpRequest();
        p.open("GET", a, true);
        p.addEventListener(
          "load",
          function(b2) {
            var c2 = this.response, d2 = db[a];
            delete db[a];
            if (200 === this.status || 0 === this.status) {
              0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
              vc.add(a, c2);
              for (var f2 = 0, g2 = d2.length; f2 < g2; f2++) {
                var k2 = d2[f2];
                if (k2.onLoad) k2.onLoad(c2);
              }
            } else {
              f2 = 0;
              for (g2 = d2.length; f2 < g2; f2++) if (k2 = d2[f2], k2.onError) k2.onError(b2);
              e.manager.itemError(a);
            }
            e.manager.itemEnd(a);
          },
          false
        );
        p.addEventListener("progress", function(b2) {
          for (var c2 = db[a], d2 = 0, e2 = c2.length; d2 < e2; d2++) {
            var f2 = c2[d2];
            if (f2.onProgress) f2.onProgress(b2);
          }
        }, false);
        p.addEventListener("error", function(b2) {
          var c2 = db[a];
          delete db[a];
          for (var d2 = 0, f2 = c2.length; d2 < f2; d2++) {
            var g2 = c2[d2];
            if (g2.onError) g2.onError(b2);
          }
          e.manager.itemError(a);
          e.manager.itemEnd(a);
        }, false);
        p.addEventListener("abort", function(b2) {
          var c2 = db[a];
          delete db[a];
          for (var d2 = 0, f2 = c2.length; d2 < f2; d2++) {
            var g2 = c2[d2];
            if (g2.onError) g2.onError(b2);
          }
          e.manager.itemError(a);
          e.manager.itemEnd(a);
        }, false);
        void 0 !== this.responseType && (p.responseType = this.responseType);
        void 0 !== this.withCredentials && (p.withCredentials = this.withCredentials);
        p.overrideMimeType && p.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
        for (k in this.requestHeader) p.setRequestHeader(k, this.requestHeader[k]);
        p.send(null);
      }
      e.manager.itemStart(a);
      return p;
    }
  }, setResponseType: function(a) {
    this.responseType = a;
    return this;
  }, setWithCredentials: function(a) {
    this.withCredentials = a;
    return this;
  }, setMimeType: function(a) {
    this.mimeType = a;
    return this;
  }, setRequestHeader: function(a) {
    this.requestHeader = a;
    return this;
  } });
  yg.prototype = Object.assign(Object.create(V.prototype), { constructor: yg, load: function(a, b, c, d) {
    var e = this, f = new Sa(e.manager);
    f.setPath(e.path);
    f.load(a, function(a2) {
      b(e.parse(JSON.parse(a2)));
    }, c, d);
  }, parse: function(a) {
    for (var b = [], c = 0; c < a.length; c++) {
      var d = Ra.parse(a[c]);
      b.push(d);
    }
    return b;
  } });
  zg.prototype = Object.assign(Object.create(V.prototype), { constructor: zg, load: function(a, b, c, d) {
    function e(e2) {
      h2.load(a[e2], function(a2) {
        a2 = f.parse(a2, true);
        g[e2] = { width: a2.width, height: a2.height, format: a2.format, mipmaps: a2.mipmaps };
        m += 1;
        6 === m && (1 === a2.mipmapCount && (k.minFilter = 1006), k.format = a2.format, k.needsUpdate = true, b && b(k));
      }, c, d);
    }
    var f = this, g = [], k = new Qc();
    k.image = g;
    var h2 = new Sa(this.manager);
    h2.setPath(this.path);
    h2.setResponseType("arraybuffer");
    if (Array.isArray(a)) for (var m = 0, n2 = 0, p = a.length; n2 < p; ++n2) e(n2);
    else h2.load(a, function(a2) {
      a2 = f.parse(a2, true);
      if (a2.isCubemap) for (var c2 = a2.mipmaps.length / a2.mipmapCount, d2 = 0; d2 < c2; d2++) {
        g[d2] = { mipmaps: [] };
        for (var e2 = 0; e2 < a2.mipmapCount; e2++) g[d2].mipmaps.push(a2.mipmaps[d2 * a2.mipmapCount + e2]), g[d2].format = a2.format, g[d2].width = a2.width, g[d2].height = a2.height;
      }
      else k.image.width = a2.width, k.image.height = a2.height, k.mipmaps = a2.mipmaps;
      1 === a2.mipmapCount && (k.minFilter = 1006);
      k.format = a2.format;
      k.needsUpdate = true;
      b && b(k);
    }, c, d);
    return k;
  } });
  cf.prototype = Object.assign(Object.create(V.prototype), { constructor: cf, load: function(a, b, c, d) {
    var e = this, f = new bc(), g = new Sa(this.manager);
    g.setResponseType("arraybuffer");
    g.setPath(this.path);
    g.load(a, function(a2) {
      if (a2 = e.parse(a2)) void 0 !== a2.image ? f.image = a2.image : void 0 !== a2.data && (f.image.width = a2.width, f.image.height = a2.height, f.image.data = a2.data), f.wrapS = void 0 !== a2.wrapS ? a2.wrapS : 1001, f.wrapT = void 0 !== a2.wrapT ? a2.wrapT : 1001, f.magFilter = void 0 !== a2.magFilter ? a2.magFilter : 1006, f.minFilter = void 0 !== a2.minFilter ? a2.minFilter : 1006, f.anisotropy = void 0 !== a2.anisotropy ? a2.anisotropy : 1, void 0 !== a2.format && (f.format = a2.format), void 0 !== a2.type && (f.type = a2.type), void 0 !== a2.mipmaps && (f.mipmaps = a2.mipmaps, f.minFilter = 1008), 1 === a2.mipmapCount && (f.minFilter = 1006), f.needsUpdate = true, b && b(f, a2);
    }, c, d);
    return f;
  } });
  fd.prototype = Object.assign(Object.create(V.prototype), { constructor: fd, load: function(a, b, c, d) {
    function e() {
      h2.removeEventListener("load", e, false);
      h2.removeEventListener("error", f, false);
      vc.add(a, this);
      b && b(this);
      g.manager.itemEnd(a);
    }
    function f(b2) {
      h2.removeEventListener("load", e, false);
      h2.removeEventListener("error", f, false);
      d && d(b2);
      g.manager.itemError(a);
      g.manager.itemEnd(a);
    }
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var g = this, k = vc.get(a);
    if (void 0 !== k) return g.manager.itemStart(a), setTimeout(function() {
      b && b(k);
      g.manager.itemEnd(a);
    }, 0), k;
    var h2 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    h2.addEventListener("load", e, false);
    h2.addEventListener("error", f, false);
    "data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (h2.crossOrigin = this.crossOrigin);
    g.manager.itemStart(a);
    h2.src = a;
    return h2;
  } });
  df.prototype = Object.assign(Object.create(V.prototype), { constructor: df, load: function(a, b, c, d) {
    function e(c2) {
      g.load(a[c2], function(a2) {
        f.images[c2] = a2;
        k++;
        6 === k && (f.needsUpdate = true, b && b(f));
      }, void 0, d);
    }
    var f = new rb(), g = new fd(this.manager);
    g.setCrossOrigin(this.crossOrigin);
    g.setPath(this.path);
    var k = 0;
    for (c = 0; c < a.length; ++c) e(c);
    return f;
  } });
  ef.prototype = Object.assign(Object.create(V.prototype), { constructor: ef, load: function(a, b, c, d) {
    var e = new Z(), f = new fd(this.manager);
    f.setCrossOrigin(this.crossOrigin);
    f.setPath(this.path);
    f.load(a, function(c2) {
      e.image = c2;
      c2 = 0 < a.search(/\.jpe?g($|\?)/i) || 0 === a.search(/^data:image\/jpeg/);
      e.format = c2 ? 1022 : 1023;
      e.needsUpdate = true;
      void 0 !== b && b(e);
    }, c, d);
    return e;
  } });
  Object.assign(I.prototype, { getPoint: function() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }, getPointAt: function(a, b) {
    a = this.getUtoTmapping(a);
    return this.getPoint(a, b);
  }, getPoints: function(a) {
    void 0 === a && (a = 5);
    for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
    return b;
  }, getSpacedPoints: function(a) {
    void 0 === a && (a = 5);
    for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
    return b;
  }, getLength: function() {
    var a = this.getLengths();
    return a[a.length - 1];
  }, getLengths: function(a) {
    void 0 === a && (a = this.arcLengthDivisions);
    if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = false;
    var b = [], c = this.getPoint(0), d, e = 0;
    b.push(0);
    for (d = 1; d <= a; d++) {
      var f = this.getPoint(d / a);
      e += f.distanceTo(c);
      b.push(e);
      c = f;
    }
    return this.cacheArcLengths = b;
  }, updateArcLengths: function() {
    this.needsUpdate = true;
    this.getLengths();
  }, getUtoTmapping: function(a, b) {
    var c = this.getLengths(), d = c.length;
    b = b ? b : a * c[d - 1];
    for (var e = 0, f = d - 1, g; e <= f; ) if (a = Math.floor(e + (f - e) / 2), g = c[a] - b, 0 > g) e = a + 1;
    else if (0 < g) f = a - 1;
    else {
      f = a;
      break;
    }
    a = f;
    if (c[a] === b) return a / (d - 1);
    e = c[a];
    return (a + (b - e) / (c[a + 1] - e)) / (d - 1);
  }, getTangent: function(a) {
    var b = a - 1e-4;
    a += 1e-4;
    0 > b && (b = 0);
    1 < a && (a = 1);
    b = this.getPoint(b);
    return this.getPoint(a).clone().sub(b).normalize();
  }, getTangentAt: function(a) {
    a = this.getUtoTmapping(a);
    return this.getTangent(a);
  }, computeFrenetFrames: function(a, b) {
    var c = new n(), d = [], e = [], f = [], g = new n(), k = new O(), h2;
    for (h2 = 0; h2 <= a; h2++) {
      var m = h2 / a;
      d[h2] = this.getTangentAt(m);
      d[h2].normalize();
    }
    e[0] = new n();
    f[0] = new n();
    h2 = Number.MAX_VALUE;
    m = Math.abs(d[0].x);
    var x = Math.abs(d[0].y), p = Math.abs(d[0].z);
    m <= h2 && (h2 = m, c.set(1, 0, 0));
    x <= h2 && (h2 = x, c.set(0, 1, 0));
    p <= h2 && c.set(0, 0, 1);
    g.crossVectors(d[0], c).normalize();
    e[0].crossVectors(d[0], g);
    f[0].crossVectors(d[0], e[0]);
    for (h2 = 1; h2 <= a; h2++) e[h2] = e[h2 - 1].clone(), f[h2] = f[h2 - 1].clone(), g.crossVectors(d[h2 - 1], d[h2]), g.length() > Number.EPSILON && (g.normalize(), c = Math.acos(P.clamp(d[h2 - 1].dot(d[h2]), -1, 1)), e[h2].applyMatrix4(k.makeRotationAxis(g, c))), f[h2].crossVectors(
      d[h2],
      e[h2]
    );
    if (true === b) for (c = Math.acos(P.clamp(e[0].dot(e[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(e[0], e[a])) && (c = -c), h2 = 1; h2 <= a; h2++) e[h2].applyMatrix4(k.makeRotationAxis(d[h2], c * h2)), f[h2].crossVectors(d[h2], e[h2]);
    return { tangents: d, normals: e, binormals: f };
  }, clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    this.arcLengthDivisions = a.arcLengthDivisions;
    return this;
  }, toJSON: function() {
    var a = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
    a.arcLengthDivisions = this.arcLengthDivisions;
    a.type = this.type;
    return a;
  }, fromJSON: function(a) {
    this.arcLengthDivisions = a.arcLengthDivisions;
    return this;
  } });
  Na.prototype = Object.create(I.prototype);
  Na.prototype.constructor = Na;
  Na.prototype.isEllipseCurve = true;
  Na.prototype.getPoint = function(a, b) {
    b = b || new w();
    for (var c = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d; ) d += c;
    for (; d > c; ) d -= c;
    d < Number.EPSILON && (d = e ? 0 : c);
    true !== this.aClockwise || e || (d = d === c ? -c : d - c);
    c = this.aStartAngle + a * d;
    a = this.aX + this.xRadius * Math.cos(c);
    var f = this.aY + this.yRadius * Math.sin(c);
    0 !== this.aRotation && (c = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX, f -= this.aY, a = e * c - f * d + this.aX, f = e * d + f * c + this.aY);
    return b.set(a, f);
  };
  Na.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this;
  };
  Na.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.aX = this.aX;
    a.aY = this.aY;
    a.xRadius = this.xRadius;
    a.yRadius = this.yRadius;
    a.aStartAngle = this.aStartAngle;
    a.aEndAngle = this.aEndAngle;
    a.aClockwise = this.aClockwise;
    a.aRotation = this.aRotation;
    return a;
  };
  Na.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.aX = a.aX;
    this.aY = a.aY;
    this.xRadius = a.xRadius;
    this.yRadius = a.yRadius;
    this.aStartAngle = a.aStartAngle;
    this.aEndAngle = a.aEndAngle;
    this.aClockwise = a.aClockwise;
    this.aRotation = a.aRotation;
    return this;
  };
  gd.prototype = Object.create(Na.prototype);
  gd.prototype.constructor = gd;
  gd.prototype.isArcCurve = true;
  var Uf = new n(), ph = new Ag(), qh = new Ag(), rh = new Ag();
  Aa.prototype = Object.create(I.prototype);
  Aa.prototype.constructor = Aa;
  Aa.prototype.isCatmullRomCurve3 = true;
  Aa.prototype.getPoint = function(a, b) {
    b = b || new n();
    var c = this.points, d = c.length;
    a *= d - (this.closed ? 0 : 1);
    var e = Math.floor(a);
    a -= e;
    this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / d) + 1) * d : 0 === a && e === d - 1 && (e = d - 2, a = 1);
    if (this.closed || 0 < e) var f = c[(e - 1) % d];
    else Uf.subVectors(c[0], c[1]).add(c[0]), f = Uf;
    var g = c[e % d];
    var h2 = c[(e + 1) % d];
    this.closed || e + 2 < d ? c = c[(e + 2) % d] : (Uf.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), c = Uf);
    if ("centripetal" === this.curveType || "chordal" === this.curveType) {
      var l = "chordal" === this.curveType ? 0.5 : 0.25;
      d = Math.pow(f.distanceToSquared(g), l);
      e = Math.pow(g.distanceToSquared(h2), l);
      l = Math.pow(h2.distanceToSquared(c), l);
      1e-4 > e && (e = 1);
      1e-4 > d && (d = e);
      1e-4 > l && (l = e);
      ph.initNonuniformCatmullRom(f.x, g.x, h2.x, c.x, d, e, l);
      qh.initNonuniformCatmullRom(f.y, g.y, h2.y, c.y, d, e, l);
      rh.initNonuniformCatmullRom(
        f.z,
        g.z,
        h2.z,
        c.z,
        d,
        e,
        l
      );
    } else "catmullrom" === this.curveType && (ph.initCatmullRom(f.x, g.x, h2.x, c.x, this.tension), qh.initCatmullRom(f.y, g.y, h2.y, c.y, this.tension), rh.initCatmullRom(f.z, g.z, h2.z, c.z, this.tension));
    b.set(ph.calc(a), qh.calc(a), rh.calc(a));
    return b;
  };
  Aa.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this;
  };
  Aa.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
    a.closed = this.closed;
    a.curveType = this.curveType;
    a.tension = this.tension;
    return a;
  };
  Aa.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
      var d = a.points[b];
      this.points.push(new n().fromArray(d));
    }
    this.closed = a.closed;
    this.curveType = a.curveType;
    this.tension = a.tension;
    return this;
  };
  Xa.prototype = Object.create(I.prototype);
  Xa.prototype.constructor = Xa;
  Xa.prototype.isCubicBezierCurve = true;
  Xa.prototype.getPoint = function(a, b) {
    b = b || new w();
    var c = this.v0, d = this.v1, e = this.v2, f = this.v3;
    b.set(te(a, c.x, d.x, e.x, f.x), te(a, c.y, d.y, e.y, f.y));
    return b;
  };
  Xa.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this;
  };
  Xa.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a;
  };
  Xa.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this;
  };
  ib.prototype = Object.create(I.prototype);
  ib.prototype.constructor = ib;
  ib.prototype.isCubicBezierCurve3 = true;
  ib.prototype.getPoint = function(a, b) {
    b = b || new n();
    var c = this.v0, d = this.v1, e = this.v2, f = this.v3;
    b.set(te(a, c.x, d.x, e.x, f.x), te(a, c.y, d.y, e.y, f.y), te(a, c.z, d.z, e.z, f.z));
    return b;
  };
  ib.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    this.v3.copy(a.v3);
    return this;
  };
  ib.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    a.v3 = this.v3.toArray();
    return a;
  };
  ib.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    this.v3.fromArray(a.v3);
    return this;
  };
  Ea.prototype = Object.create(I.prototype);
  Ea.prototype.constructor = Ea;
  Ea.prototype.isLineCurve = true;
  Ea.prototype.getPoint = function(a, b) {
    b = b || new w();
    1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b;
  };
  Ea.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b);
  };
  Ea.prototype.getTangent = function() {
    return this.v2.clone().sub(this.v1).normalize();
  };
  Ea.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Ea.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Ea.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  Ya.prototype = Object.create(I.prototype);
  Ya.prototype.constructor = Ya;
  Ya.prototype.isLineCurve3 = true;
  Ya.prototype.getPoint = function(a, b) {
    b = b || new n();
    1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
    return b;
  };
  Ya.prototype.getPointAt = function(a, b) {
    return this.getPoint(a, b);
  };
  Ya.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Ya.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Ya.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  Za.prototype = Object.create(I.prototype);
  Za.prototype.constructor = Za;
  Za.prototype.isQuadraticBezierCurve = true;
  Za.prototype.getPoint = function(a, b) {
    b = b || new w();
    var c = this.v0, d = this.v1, e = this.v2;
    b.set(se(a, c.x, d.x, e.x), se(a, c.y, d.y, e.y));
    return b;
  };
  Za.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  Za.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  Za.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  jb.prototype = Object.create(I.prototype);
  jb.prototype.constructor = jb;
  jb.prototype.isQuadraticBezierCurve3 = true;
  jb.prototype.getPoint = function(a, b) {
    b = b || new n();
    var c = this.v0, d = this.v1, e = this.v2;
    b.set(se(a, c.x, d.x, e.x), se(a, c.y, d.y, e.y), se(a, c.z, d.z, e.z));
    return b;
  };
  jb.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.v0.copy(a.v0);
    this.v1.copy(a.v1);
    this.v2.copy(a.v2);
    return this;
  };
  jb.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.v0 = this.v0.toArray();
    a.v1 = this.v1.toArray();
    a.v2 = this.v2.toArray();
    return a;
  };
  jb.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.v0.fromArray(a.v0);
    this.v1.fromArray(a.v1);
    this.v2.fromArray(a.v2);
    return this;
  };
  $a.prototype = Object.create(I.prototype);
  $a.prototype.constructor = $a;
  $a.prototype.isSplineCurve = true;
  $a.prototype.getPoint = function(a, b) {
    b = b || new w();
    var c = this.points, d = (c.length - 1) * a;
    a = Math.floor(d);
    d -= a;
    var e = c[0 === a ? a : a - 1], f = c[a], g = c[a > c.length - 2 ? c.length - 1 : a + 1];
    c = c[a > c.length - 3 ? c.length - 1 : a + 2];
    b.set(ki(
      d,
      e.x,
      f.x,
      g.x,
      c.x
    ), ki(d, e.y, f.y, g.y, c.y));
    return b;
  };
  $a.prototype.copy = function(a) {
    I.prototype.copy.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
    return this;
  };
  $a.prototype.toJSON = function() {
    var a = I.prototype.toJSON.call(this);
    a.points = [];
    for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
    return a;
  };
  $a.prototype.fromJSON = function(a) {
    I.prototype.fromJSON.call(this, a);
    this.points = [];
    for (var b = 0, c = a.points.length; b < c; b++) {
      var d = a.points[b];
      this.points.push(new w().fromArray(d));
    }
    return this;
  };
  var sh = Object.freeze({ __proto__: null, ArcCurve: gd, CatmullRomCurve3: Aa, CubicBezierCurve: Xa, CubicBezierCurve3: ib, EllipseCurve: Na, LineCurve: Ea, LineCurve3: Ya, QuadraticBezierCurve: Za, QuadraticBezierCurve3: jb, SplineCurve: $a });
  wb.prototype = Object.assign(Object.create(I.prototype), { constructor: wb, add: function(a) {
    this.curves.push(a);
  }, closePath: function() {
    var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
    a.equals(b) || this.curves.push(new Ea(
      b,
      a
    ));
  }, getPoint: function(a) {
    var b = a * this.getLength(), c = this.getCurveLengths();
    for (a = 0; a < c.length; ) {
      if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
      a++;
    }
    return null;
  }, getLength: function() {
    var a = this.getCurveLengths();
    return a[a.length - 1];
  }, updateArcLengths: function() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }, getCurveLengths: function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
    return this.cacheLengths = a;
  }, getSpacedPoints: function(a) {
    void 0 === a && (a = 40);
    for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
    this.autoClose && b.push(b[0]);
    return b;
  }, getPoints: function(a) {
    a = a || 12;
    for (var b = [], c, d = 0, e = this.curves; d < e.length; d++) {
      var f = e[d];
      f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && (f.isLineCurve || f.isLineCurve3) ? 1 : f && f.isSplineCurve ? a * f.points.length : a);
      for (var g = 0; g < f.length; g++) {
        var h2 = f[g];
        c && c.equals(h2) || (b.push(h2), c = h2);
      }
    }
    this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]);
    return b;
  }, copy: function(a) {
    I.prototype.copy.call(this, a);
    this.curves = [];
    for (var b = 0, c = a.curves.length; b < c; b++) this.curves.push(a.curves[b].clone());
    this.autoClose = a.autoClose;
    return this;
  }, toJSON: function() {
    var a = I.prototype.toJSON.call(this);
    a.autoClose = this.autoClose;
    a.curves = [];
    for (var b = 0, c = this.curves.length; b < c; b++) a.curves.push(this.curves[b].toJSON());
    return a;
  }, fromJSON: function(a) {
    I.prototype.fromJSON.call(
      this,
      a
    );
    this.autoClose = a.autoClose;
    this.curves = [];
    for (var b = 0, c = a.curves.length; b < c; b++) {
      var d = a.curves[b];
      this.curves.push(new sh[d.type]().fromJSON(d));
    }
    return this;
  } });
  ab.prototype = Object.assign(Object.create(wb.prototype), {
    constructor: ab,
    setFromPoints: function(a) {
      this.moveTo(a[0].x, a[0].y);
      for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y);
      return this;
    },
    moveTo: function(a, b) {
      this.currentPoint.set(a, b);
      return this;
    },
    lineTo: function(a, b) {
      var c = new Ea(this.currentPoint.clone(), new w(a, b));
      this.curves.push(c);
      this.currentPoint.set(a, b);
      return this;
    },
    quadraticCurveTo: function(a, b, c, d) {
      a = new Za(this.currentPoint.clone(), new w(a, b), new w(c, d));
      this.curves.push(a);
      this.currentPoint.set(c, d);
      return this;
    },
    bezierCurveTo: function(a, b, c, d, e, f) {
      a = new Xa(this.currentPoint.clone(), new w(a, b), new w(c, d), new w(e, f));
      this.curves.push(a);
      this.currentPoint.set(e, f);
      return this;
    },
    splineThru: function(a) {
      var b = [this.currentPoint.clone()].concat(a);
      b = new $a(b);
      this.curves.push(b);
      this.currentPoint.copy(a[a.length - 1]);
      return this;
    },
    arc: function(a, b, c, d, e, f) {
      this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f);
      return this;
    },
    absarc: function(a, b, c, d, e, f) {
      this.absellipse(a, b, c, c, d, e, f);
      return this;
    },
    ellipse: function(a, b, c, d, e, f, g, h2) {
      this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h2);
      return this;
    },
    absellipse: function(a, b, c, d, e, f, g, h2) {
      a = new Na(a, b, c, d, e, f, g, h2);
      0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
      this.curves.push(a);
      a = a.getPoint(1);
      this.currentPoint.copy(a);
      return this;
    },
    copy: function(a) {
      wb.prototype.copy.call(this, a);
      this.currentPoint.copy(a.currentPoint);
      return this;
    },
    toJSON: function() {
      var a = wb.prototype.toJSON.call(this);
      a.currentPoint = this.currentPoint.toArray();
      return a;
    },
    fromJSON: function(a) {
      wb.prototype.fromJSON.call(this, a);
      this.currentPoint.fromArray(a.currentPoint);
      return this;
    }
  });
  Lb.prototype = Object.assign(Object.create(ab.prototype), { constructor: Lb, getPointsHoles: function(a) {
    for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
    return b;
  }, extractPoints: function(a) {
    return { shape: this.getPoints(a), holes: this.getPointsHoles(a) };
  }, copy: function(a) {
    ab.prototype.copy.call(this, a);
    this.holes = [];
    for (var b = 0, c = a.holes.length; b < c; b++) this.holes.push(a.holes[b].clone());
    return this;
  }, toJSON: function() {
    var a = ab.prototype.toJSON.call(this);
    a.uuid = this.uuid;
    a.holes = [];
    for (var b = 0, c = this.holes.length; b < c; b++) a.holes.push(this.holes[b].toJSON());
    return a;
  }, fromJSON: function(a) {
    ab.prototype.fromJSON.call(this, a);
    this.uuid = a.uuid;
    this.holes = [];
    for (var b = 0, c = a.holes.length; b < c; b++) {
      var d = a.holes[b];
      this.holes.push(new ab().fromJSON(d));
    }
    return this;
  } });
  ba.prototype = Object.assign(Object.create(D.prototype), { constructor: ba, isLight: true, copy: function(a) {
    D.prototype.copy.call(this, a);
    this.color.copy(a.color);
    this.intensity = a.intensity;
    return this;
  }, toJSON: function(a) {
    a = D.prototype.toJSON.call(this, a);
    a.object.color = this.color.getHex();
    a.object.intensity = this.intensity;
    void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
    void 0 !== this.distance && (a.object.distance = this.distance);
    void 0 !== this.angle && (a.object.angle = this.angle);
    void 0 !== this.decay && (a.object.decay = this.decay);
    void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
    void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
    return a;
  } });
  ff.prototype = Object.assign(Object.create(ba.prototype), { constructor: ff, isHemisphereLight: true, copy: function(a) {
    ba.prototype.copy.call(this, a);
    this.groundColor.copy(a.groundColor);
    return this;
  } });
  Object.assign(kb.prototype, {
    _projScreenMatrix: new O(),
    _lightPositionWorld: new n(),
    _lookTarget: new n(),
    getViewportCount: function() {
      return this._viewportCount;
    },
    getFrustum: function() {
      return this._frustum;
    },
    updateMatrices: function(a) {
      var b = this.camera, c = this.matrix, d = this._projScreenMatrix, e = this._lookTarget, f = this._lightPositionWorld;
      f.setFromMatrixPosition(a.matrixWorld);
      b.position.copy(f);
      e.setFromMatrixPosition(a.target.matrixWorld);
      b.lookAt(e);
      b.updateMatrixWorld();
      d.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(d);
      c.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      c.multiply(b.projectionMatrix);
      c.multiply(b.matrixWorldInverse);
    },
    getViewport: function(a) {
      return this._viewports[a];
    },
    getFrameExtents: function() {
      return this._frameExtents;
    },
    copy: function(a) {
      this.camera = a.camera.clone();
      this.bias = a.bias;
      this.radius = a.radius;
      this.mapSize.copy(a.mapSize);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      var a = {};
      0 !== this.bias && (a.bias = this.bias);
      1 !== this.radius && (a.radius = this.radius);
      if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray();
      a.camera = this.camera.toJSON(false).object;
      delete a.camera.matrix;
      return a;
    }
  });
  gf.prototype = Object.assign(Object.create(kb.prototype), { constructor: gf, isSpotLightShadow: true, updateMatrices: function(a) {
    var b = this.camera, c = 2 * P.RAD2DEG * a.angle, d = this.mapSize.width / this.mapSize.height, e = a.distance || b.far;
    if (c !== b.fov || d !== b.aspect || e !== b.far) b.fov = c, b.aspect = d, b.far = e, b.updateProjectionMatrix();
    kb.prototype.updateMatrices.call(this, a);
  } });
  hf.prototype = Object.assign(Object.create(ba.prototype), { constructor: hf, isSpotLight: true, copy: function(a) {
    ba.prototype.copy.call(this, a);
    this.distance = a.distance;
    this.angle = a.angle;
    this.penumbra = a.penumbra;
    this.decay = a.decay;
    this.target = a.target.clone();
    this.shadow = a.shadow.clone();
    return this;
  } });
  Bg.prototype = Object.assign(Object.create(kb.prototype), { constructor: Bg, isPointLightShadow: true, updateMatrices: function(a, b) {
    void 0 === b && (b = 0);
    var c = this.camera, d = this.matrix, e = this._lightPositionWorld, f = this._lookTarget, g = this._projScreenMatrix;
    e.setFromMatrixPosition(a.matrixWorld);
    c.position.copy(e);
    f.copy(c.position);
    f.add(this._cubeDirections[b]);
    c.up.copy(this._cubeUps[b]);
    c.lookAt(f);
    c.updateMatrixWorld();
    d.makeTranslation(-e.x, -e.y, -e.z);
    g.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(g);
  } });
  jf.prototype = Object.assign(Object.create(ba.prototype), { constructor: jf, isPointLight: true, copy: function(a) {
    ba.prototype.copy.call(this, a);
    this.distance = a.distance;
    this.decay = a.decay;
    this.shadow = a.shadow.clone();
    return this;
  } });
  hd.prototype = Object.assign(Object.create(eb.prototype), { constructor: hd, isOrthographicCamera: true, copy: function(a, b) {
    eb.prototype.copy.call(this, a, b);
    this.left = a.left;
    this.right = a.right;
    this.top = a.top;
    this.bottom = a.bottom;
    this.near = a.near;
    this.far = a.far;
    this.zoom = a.zoom;
    this.view = null === a.view ? null : Object.assign({}, a.view);
    return this;
  }, setViewOffset: function(a, b, c, d, e, f) {
    null === this.view && (this.view = {
      enabled: true,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    });
    this.view.enabled = true;
    this.view.fullWidth = a;
    this.view.fullHeight = b;
    this.view.offsetX = c;
    this.view.offsetY = d;
    this.view.width = e;
    this.view.height = f;
    this.updateProjectionMatrix();
  }, clearViewOffset: function() {
    null !== this.view && (this.view.enabled = false);
    this.updateProjectionMatrix();
  }, updateProjectionMatrix: function() {
    var a = (this.right - this.left) / (2 * this.zoom), b = (this.top - this.bottom) / (2 * this.zoom), c = (this.right + this.left) / 2, d = (this.top + this.bottom) / 2, e = c - a;
    c += a;
    a = d + b;
    b = d - b;
    null !== this.view && this.view.enabled && (d = (this.right - this.left) / this.view.fullWidth / this.zoom, b = (this.top - this.bottom) / this.view.fullHeight / this.zoom, e += d * this.view.offsetX, c = e + d * this.view.width, a -= b * this.view.offsetY, b = a - b * this.view.height);
    this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  }, toJSON: function(a) {
    a = D.prototype.toJSON.call(this, a);
    a.object.zoom = this.zoom;
    a.object.left = this.left;
    a.object.right = this.right;
    a.object.top = this.top;
    a.object.bottom = this.bottom;
    a.object.near = this.near;
    a.object.far = this.far;
    null !== this.view && (a.object.view = Object.assign({}, this.view));
    return a;
  } });
  kf.prototype = Object.assign(Object.create(kb.prototype), { constructor: kf, isDirectionalLightShadow: true, updateMatrices: function(a) {
    kb.prototype.updateMatrices.call(this, a);
  } });
  lf.prototype = Object.assign(Object.create(ba.prototype), { constructor: lf, isDirectionalLight: true, copy: function(a) {
    ba.prototype.copy.call(this, a);
    this.target = a.target.clone();
    this.shadow = a.shadow.clone();
    return this;
  } });
  mf.prototype = Object.assign(Object.create(ba.prototype), { constructor: mf, isAmbientLight: true });
  nf.prototype = Object.assign(Object.create(ba.prototype), { constructor: nf, isRectAreaLight: true, copy: function(a) {
    ba.prototype.copy.call(this, a);
    this.width = a.width;
    this.height = a.height;
    return this;
  }, toJSON: function(a) {
    a = ba.prototype.toJSON.call(this, a);
    a.object.width = this.width;
    a.object.height = this.height;
    return a;
  } });
  of.prototype = Object.assign(Object.create(V.prototype), { constructor: of, load: function(a, b, c, d) {
    var e = this, f = new Sa(e.manager);
    f.setPath(e.path);
    f.load(a, function(a2) {
      b(e.parse(JSON.parse(a2)));
    }, c, d);
  }, parse: function(a) {
    function b(a2) {
      void 0 === c[a2] && console.warn("THREE.MaterialLoader: Undefined texture", a2);
      return c[a2];
    }
    var c = this.textures, d = new bl[a.type]();
    void 0 !== a.uuid && (d.uuid = a.uuid);
    void 0 !== a.name && (d.name = a.name);
    void 0 !== a.color && d.color.setHex(a.color);
    void 0 !== a.roughness && (d.roughness = a.roughness);
    void 0 !== a.metalness && (d.metalness = a.metalness);
    void 0 !== a.sheen && (d.sheen = new B().setHex(a.sheen));
    void 0 !== a.emissive && d.emissive.setHex(a.emissive);
    void 0 !== a.specular && d.specular.setHex(a.specular);
    void 0 !== a.shininess && (d.shininess = a.shininess);
    void 0 !== a.clearcoat && (d.clearcoat = a.clearcoat);
    void 0 !== a.clearcoatRoughness && (d.clearcoatRoughness = a.clearcoatRoughness);
    void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors);
    void 0 !== a.fog && (d.fog = a.fog);
    void 0 !== a.flatShading && (d.flatShading = a.flatShading);
    void 0 !== a.blending && (d.blending = a.blending);
    void 0 !== a.combine && (d.combine = a.combine);
    void 0 !== a.side && (d.side = a.side);
    void 0 !== a.opacity && (d.opacity = a.opacity);
    void 0 !== a.transparent && (d.transparent = a.transparent);
    void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest);
    void 0 !== a.depthTest && (d.depthTest = a.depthTest);
    void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite);
    void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite);
    void 0 !== a.stencilWrite && (d.stencilWrite = a.stencilWrite);
    void 0 !== a.stencilWriteMask && (d.stencilWriteMask = a.stencilWriteMask);
    void 0 !== a.stencilFunc && (d.stencilFunc = a.stencilFunc);
    void 0 !== a.stencilRef && (d.stencilRef = a.stencilRef);
    void 0 !== a.stencilFuncMask && (d.stencilFuncMask = a.stencilFuncMask);
    void 0 !== a.stencilFail && (d.stencilFail = a.stencilFail);
    void 0 !== a.stencilZFail && (d.stencilZFail = a.stencilZFail);
    void 0 !== a.stencilZPass && (d.stencilZPass = a.stencilZPass);
    void 0 !== a.wireframe && (d.wireframe = a.wireframe);
    void 0 !== a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth);
    void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap);
    void 0 !== a.wireframeLinejoin && (d.wireframeLinejoin = a.wireframeLinejoin);
    void 0 !== a.rotation && (d.rotation = a.rotation);
    1 !== a.linewidth && (d.linewidth = a.linewidth);
    void 0 !== a.dashSize && (d.dashSize = a.dashSize);
    void 0 !== a.gapSize && (d.gapSize = a.gapSize);
    void 0 !== a.scale && (d.scale = a.scale);
    void 0 !== a.polygonOffset && (d.polygonOffset = a.polygonOffset);
    void 0 !== a.polygonOffsetFactor && (d.polygonOffsetFactor = a.polygonOffsetFactor);
    void 0 !== a.polygonOffsetUnits && (d.polygonOffsetUnits = a.polygonOffsetUnits);
    void 0 !== a.skinning && (d.skinning = a.skinning);
    void 0 !== a.morphTargets && (d.morphTargets = a.morphTargets);
    void 0 !== a.morphNormals && (d.morphNormals = a.morphNormals);
    void 0 !== a.dithering && (d.dithering = a.dithering);
    void 0 !== a.visible && (d.visible = a.visible);
    void 0 !== a.toneMapped && (d.toneMapped = a.toneMapped);
    void 0 !== a.userData && (d.userData = a.userData);
    if (void 0 !== a.uniforms) for (var e in a.uniforms) {
      var f = a.uniforms[e];
      d.uniforms[e] = {};
      switch (f.type) {
        case "t":
          d.uniforms[e].value = b(f.value);
          break;
        case "c":
          d.uniforms[e].value = new B().setHex(f.value);
          break;
        case "v2":
          d.uniforms[e].value = new w().fromArray(f.value);
          break;
        case "v3":
          d.uniforms[e].value = new n().fromArray(f.value);
          break;
        case "v4":
          d.uniforms[e].value = new ia().fromArray(f.value);
          break;
        case "m3":
          d.uniforms[e].value = new za().fromArray(f.value);
        case "m4":
          d.uniforms[e].value = new O().fromArray(f.value);
          break;
        default:
          d.uniforms[e].value = f.value;
      }
    }
    void 0 !== a.defines && (d.defines = a.defines);
    void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader);
    void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader);
    if (void 0 !== a.extensions) for (var g in a.extensions) d.extensions[g] = a.extensions[g];
    void 0 !== a.shading && (d.flatShading = 1 === a.shading);
    void 0 !== a.size && (d.size = a.size);
    void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation);
    void 0 !== a.map && (d.map = b(a.map));
    void 0 !== a.matcap && (d.matcap = b(a.matcap));
    void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = true);
    void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap));
    void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale);
    void 0 !== a.normalMap && (d.normalMap = b(a.normalMap));
    void 0 !== a.normalMapType && (d.normalMapType = a.normalMapType);
    void 0 !== a.normalScale && (e = a.normalScale, false === Array.isArray(e) && (e = [e, e]), d.normalScale = new w().fromArray(e));
    void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap));
    void 0 !== a.displacementScale && (d.displacementScale = a.displacementScale);
    void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias);
    void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap));
    void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap));
    void 0 !== a.emissiveMap && (d.emissiveMap = b(a.emissiveMap));
    void 0 !== a.emissiveIntensity && (d.emissiveIntensity = a.emissiveIntensity);
    void 0 !== a.specularMap && (d.specularMap = b(a.specularMap));
    void 0 !== a.envMap && (d.envMap = b(a.envMap));
    void 0 !== a.envMapIntensity && (d.envMapIntensity = a.envMapIntensity);
    void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity);
    void 0 !== a.refractionRatio && (d.refractionRatio = a.refractionRatio);
    void 0 !== a.lightMap && (d.lightMap = b(a.lightMap));
    void 0 !== a.lightMapIntensity && (d.lightMapIntensity = a.lightMapIntensity);
    void 0 !== a.aoMap && (d.aoMap = b(a.aoMap));
    void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity);
    void 0 !== a.gradientMap && (d.gradientMap = b(a.gradientMap));
    void 0 !== a.clearcoatNormalMap && (d.clearcoatNormalMap = b(a.clearcoatNormalMap));
    void 0 !== a.clearcoatNormalScale && (d.clearcoatNormalScale = new w().fromArray(a.clearcoatNormalScale));
    return d;
  }, setTextures: function(a) {
    this.textures = a;
    return this;
  } });
  var th = { decodeText: function(a) {
    if ("undefined" !== typeof TextDecoder) return new TextDecoder().decode(a);
    for (var b = "", c = 0, d = a.length; c < d; c++) b += String.fromCharCode(a[c]);
    try {
      return decodeURIComponent(escape(b));
    } catch (e) {
      return b;
    }
  }, extractUrlBase: function(a) {
    var b = a.lastIndexOf("/");
    return -1 === b ? "./" : a.substr(0, b + 1);
  } };
  pf.prototype = Object.assign(Object.create(A.prototype), { constructor: pf, isInstancedBufferGeometry: true, copy: function(a) {
    A.prototype.copy.call(this, a);
    this.maxInstancedCount = a.maxInstancedCount;
    return this;
  }, clone: function() {
    return new this.constructor().copy(this);
  }, toJSON: function() {
    var a = A.prototype.toJSON.call(this);
    a.maxInstancedCount = this.maxInstancedCount;
    a.isInstancedBufferGeometry = true;
    return a;
  } });
  qf.prototype = Object.assign(Object.create(M.prototype), { constructor: qf, isInstancedBufferAttribute: true, copy: function(a) {
    M.prototype.copy.call(this, a);
    this.meshPerAttribute = a.meshPerAttribute;
    return this;
  }, toJSON: function() {
    var a = M.prototype.toJSON.call(this);
    a.meshPerAttribute = this.meshPerAttribute;
    a.isInstancedBufferAttribute = true;
    return a;
  } });
  rf.prototype = Object.assign(Object.create(V.prototype), { constructor: rf, load: function(a, b, c, d) {
    var e = this, f = new Sa(e.manager);
    f.setPath(e.path);
    f.load(a, function(a2) {
      b(e.parse(JSON.parse(a2)));
    }, c, d);
  }, parse: function(a) {
    var b = a.isInstancedBufferGeometry ? new pf() : new A(), c = a.data.index;
    if (void 0 !== c) {
      var d = new uh[c.type](c.array);
      b.setIndex(new M(d, 1));
    }
    c = a.data.attributes;
    for (var e in c) {
      var f = c[e];
      d = new uh[f.type](f.array);
      d = new (f.isInstancedBufferAttribute ? qf : M)(d, f.itemSize, f.normalized);
      void 0 !== f.name && (d.name = f.name);
      b.setAttribute(e, d);
    }
    var g = a.data.morphAttributes;
    if (g) for (e in g) {
      var h2 = g[e], l = [];
      c = 0;
      for (var m = h2.length; c < m; c++) f = h2[c], d = new uh[f.type](f.array), d = new M(d, f.itemSize, f.normalized), void 0 !== f.name && (d.name = f.name), l.push(d);
      b.morphAttributes[e] = l;
    }
    a.data.morphTargetsRelative && (b.morphTargetsRelative = true);
    e = a.data.groups || a.data.drawcalls || a.data.offsets;
    if (void 0 !== e) for (c = 0, f = e.length; c !== f; ++c) d = e[c], b.addGroup(d.start, d.count, d.materialIndex);
    c = a.data.boundingSphere;
    void 0 !== c && (e = new n(), void 0 !== c.center && e.fromArray(c.center), b.boundingSphere = new qb(e, c.radius));
    a.name && (b.name = a.name);
    a.userData && (b.userData = a.userData);
    return b;
  } });
  var uh = { Int8Array, Uint8Array, Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
  sf.prototype = Object.assign(Object.create(V.prototype), { constructor: sf, load: function(a, b, c, d) {
    var e = this, f = "" === this.path ? th.extractUrlBase(a) : this.path;
    this.resourcePath = this.resourcePath || f;
    f = new Sa(e.manager);
    f.setPath(this.path);
    f.load(a, function(c2) {
      var f2 = null;
      try {
        f2 = JSON.parse(c2);
      } catch (l) {
        void 0 !== d && d(l);
        console.error("THREE:ObjectLoader: Can't parse " + a + ".", l.message);
        return;
      }
      c2 = f2.metadata;
      void 0 === c2 || void 0 === c2.type || "geometry" === c2.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + a) : e.parse(f2, b);
    }, c, d);
  }, parse: function(a, b) {
    var c = this.parseShape(a.shapes);
    c = this.parseGeometries(a.geometries, c);
    var d = this.parseImages(a.images, function() {
      void 0 !== b && b(e);
    });
    d = this.parseTextures(a.textures, d);
    d = this.parseMaterials(a.materials, d);
    var e = this.parseObject(a.object, c, d);
    a.animations && (e.animations = this.parseAnimations(a.animations));
    void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
    return e;
  }, parseShape: function(a) {
    var b = {};
    if (void 0 !== a) for (var c = 0, d = a.length; c < d; c++) {
      var e = new Lb().fromJSON(a[c]);
      b[e.uuid] = e;
    }
    return b;
  }, parseGeometries: function(a, b) {
    var c = {};
    if (void 0 !== a) for (var d = new rf(), e = 0, f = a.length; e < f; e++) {
      var g = a[e];
      switch (g.type) {
        case "PlaneGeometry":
        case "PlaneBufferGeometry":
          var h2 = new va[g.type](g.width, g.height, g.widthSegments, g.heightSegments);
          break;
        case "BoxGeometry":
        case "BoxBufferGeometry":
        case "CubeGeometry":
          h2 = new va[g.type](g.width, g.height, g.depth, g.widthSegments, g.heightSegments, g.depthSegments);
          break;
        case "CircleGeometry":
        case "CircleBufferGeometry":
          h2 = new va[g.type](g.radius, g.segments, g.thetaStart, g.thetaLength);
          break;
        case "CylinderGeometry":
        case "CylinderBufferGeometry":
          h2 = new va[g.type](
            g.radiusTop,
            g.radiusBottom,
            g.height,
            g.radialSegments,
            g.heightSegments,
            g.openEnded,
            g.thetaStart,
            g.thetaLength
          );
          break;
        case "ConeGeometry":
        case "ConeBufferGeometry":
          h2 = new va[g.type](g.radius, g.height, g.radialSegments, g.heightSegments, g.openEnded, g.thetaStart, g.thetaLength);
          break;
        case "SphereGeometry":
        case "SphereBufferGeometry":
          h2 = new va[g.type](g.radius, g.widthSegments, g.heightSegments, g.phiStart, g.phiLength, g.thetaStart, g.thetaLength);
          break;
        case "DodecahedronGeometry":
        case "DodecahedronBufferGeometry":
        case "IcosahedronGeometry":
        case "IcosahedronBufferGeometry":
        case "OctahedronGeometry":
        case "OctahedronBufferGeometry":
        case "TetrahedronGeometry":
        case "TetrahedronBufferGeometry":
          h2 = new va[g.type](g.radius, g.detail);
          break;
        case "RingGeometry":
        case "RingBufferGeometry":
          h2 = new va[g.type](g.innerRadius, g.outerRadius, g.thetaSegments, g.phiSegments, g.thetaStart, g.thetaLength);
          break;
        case "TorusGeometry":
        case "TorusBufferGeometry":
          h2 = new va[g.type](g.radius, g.tube, g.radialSegments, g.tubularSegments, g.arc);
          break;
        case "TorusKnotGeometry":
        case "TorusKnotBufferGeometry":
          h2 = new va[g.type](g.radius, g.tube, g.tubularSegments, g.radialSegments, g.p, g.q);
          break;
        case "TubeGeometry":
        case "TubeBufferGeometry":
          h2 = new va[g.type](new sh[g.path.type]().fromJSON(g.path), g.tubularSegments, g.radius, g.radialSegments, g.closed);
          break;
        case "LatheGeometry":
        case "LatheBufferGeometry":
          h2 = new va[g.type](g.points, g.segments, g.phiStart, g.phiLength);
          break;
        case "PolyhedronGeometry":
        case "PolyhedronBufferGeometry":
          h2 = new va[g.type](g.vertices, g.indices, g.radius, g.details);
          break;
        case "ShapeGeometry":
        case "ShapeBufferGeometry":
          h2 = [];
          for (var l = 0, m = g.shapes.length; l < m; l++) {
            var n2 = b[g.shapes[l]];
            h2.push(n2);
          }
          h2 = new va[g.type](h2, g.curveSegments);
          break;
        case "ExtrudeGeometry":
        case "ExtrudeBufferGeometry":
          h2 = [];
          l = 0;
          for (m = g.shapes.length; l < m; l++) n2 = b[g.shapes[l]], h2.push(n2);
          l = g.options.extrudePath;
          void 0 !== l && (g.options.extrudePath = new sh[l.type]().fromJSON(l));
          h2 = new va[g.type](h2, g.options);
          break;
        case "BufferGeometry":
        case "InstancedBufferGeometry":
          h2 = d.parse(g);
          break;
        case "Geometry":
          "THREE" in window && "LegacyJSONLoader" in THREE ? h2 = new THREE.LegacyJSONLoader().parse(g, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
          break;
        default:
          console.warn('THREE.ObjectLoader: Unsupported geometry type "' + g.type + '"');
          continue;
      }
      h2.uuid = g.uuid;
      void 0 !== g.name && (h2.name = g.name);
      true === h2.isBufferGeometry && void 0 !== g.userData && (h2.userData = g.userData);
      c[g.uuid] = h2;
    }
    return c;
  }, parseMaterials: function(a, b) {
    var c = {}, d = {};
    if (void 0 !== a) {
      var e = new of();
      e.setTextures(b);
      b = 0;
      for (var f = a.length; b < f; b++) {
        var g = a[b];
        if ("MultiMaterial" === g.type) {
          for (var h2 = [], l = 0; l < g.materials.length; l++) {
            var m = g.materials[l];
            void 0 === c[m.uuid] && (c[m.uuid] = e.parse(m));
            h2.push(c[m.uuid]);
          }
          d[g.uuid] = h2;
        } else void 0 === c[g.uuid] && (c[g.uuid] = e.parse(g)), d[g.uuid] = c[g.uuid];
      }
    }
    return d;
  }, parseAnimations: function(a) {
    for (var b = [], c = 0; c < a.length; c++) {
      var d = a[c], e = Ra.parse(d);
      void 0 !== d.uuid && (e.uuid = d.uuid);
      b.push(e);
    }
    return b;
  }, parseImages: function(a, b) {
    function c(a2) {
      d.manager.itemStart(a2);
      return f.load(a2, function() {
        d.manager.itemEnd(a2);
      }, void 0, function() {
        d.manager.itemError(a2);
        d.manager.itemEnd(a2);
      });
    }
    var d = this, e = {};
    if (void 0 !== a && 0 < a.length) {
      b = new xg(b);
      var f = new fd(b);
      f.setCrossOrigin(this.crossOrigin);
      b = 0;
      for (var g = a.length; b < g; b++) {
        var h2 = a[b], l = h2.url;
        if (Array.isArray(l)) {
          e[h2.uuid] = [];
          for (var m = 0, n2 = l.length; m < n2; m++) {
            var p = l[m];
            p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : d.resourcePath + p;
            e[h2.uuid].push(c(p));
          }
        } else p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h2.url) ? h2.url : d.resourcePath + h2.url, e[h2.uuid] = c(p);
      }
    }
    return e;
  }, parseTextures: function(a, b) {
    function c(a2, b2) {
      if ("number" === typeof a2) return a2;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a2);
      return b2[a2];
    }
    var d = {};
    if (void 0 !== a) for (var e = 0, f = a.length; e < f; e++) {
      var g = a[e];
      void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid);
      void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
      var h2 = Array.isArray(b[g.image]) ? new rb(b[g.image]) : new Z(b[g.image]);
      h2.needsUpdate = true;
      h2.uuid = g.uuid;
      void 0 !== g.name && (h2.name = g.name);
      void 0 !== g.mapping && (h2.mapping = c(g.mapping, cl));
      void 0 !== g.offset && h2.offset.fromArray(g.offset);
      void 0 !== g.repeat && h2.repeat.fromArray(g.repeat);
      void 0 !== g.center && h2.center.fromArray(g.center);
      void 0 !== g.rotation && (h2.rotation = g.rotation);
      void 0 !== g.wrap && (h2.wrapS = c(g.wrap[0], aj), h2.wrapT = c(g.wrap[1], aj));
      void 0 !== g.format && (h2.format = g.format);
      void 0 !== g.type && (h2.type = g.type);
      void 0 !== g.encoding && (h2.encoding = g.encoding);
      void 0 !== g.minFilter && (h2.minFilter = c(g.minFilter, bj));
      void 0 !== g.magFilter && (h2.magFilter = c(g.magFilter, bj));
      void 0 !== g.anisotropy && (h2.anisotropy = g.anisotropy);
      void 0 !== g.flipY && (h2.flipY = g.flipY);
      void 0 !== g.premultiplyAlpha && (h2.premultiplyAlpha = g.premultiplyAlpha);
      void 0 !== g.unpackAlignment && (h2.unpackAlignment = g.unpackAlignment);
      d[g.uuid] = h2;
    }
    return d;
  }, parseObject: function(a, b, c) {
    function d(a2) {
      void 0 === b[a2] && console.warn("THREE.ObjectLoader: Undefined geometry", a2);
      return b[a2];
    }
    function e(a2) {
      if (void 0 !== a2) {
        if (Array.isArray(a2)) {
          for (var b2 = [], d2 = 0, e2 = a2.length; d2 < e2; d2++) {
            var f2 = a2[d2];
            void 0 === c[f2] && console.warn("THREE.ObjectLoader: Undefined material", f2);
            b2.push(c[f2]);
          }
          return b2;
        }
        void 0 === c[a2] && console.warn("THREE.ObjectLoader: Undefined material", a2);
        return c[a2];
      }
    }
    switch (a.type) {
      case "Scene":
        var f = new pb();
        void 0 !== a.background && Number.isInteger(a.background) && (f.background = new B(a.background));
        void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new Se(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" === a.fog.type && (f.fog = new Re(a.fog.color, a.fog.density)));
        break;
      case "PerspectiveCamera":
        f = new da(a.fov, a.aspect, a.near, a.far);
        void 0 !== a.focus && (f.focus = a.focus);
        void 0 !== a.zoom && (f.zoom = a.zoom);
        void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge);
        void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset);
        void 0 !== a.view && (f.view = Object.assign({}, a.view));
        break;
      case "OrthographicCamera":
        f = new hd(a.left, a.right, a.top, a.bottom, a.near, a.far);
        void 0 !== a.zoom && (f.zoom = a.zoom);
        void 0 !== a.view && (f.view = Object.assign({}, a.view));
        break;
      case "AmbientLight":
        f = new mf(a.color, a.intensity);
        break;
      case "DirectionalLight":
        f = new lf(a.color, a.intensity);
        break;
      case "PointLight":
        f = new jf(a.color, a.intensity, a.distance, a.decay);
        break;
      case "RectAreaLight":
        f = new nf(a.color, a.intensity, a.width, a.height);
        break;
      case "SpotLight":
        f = new hf(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
        break;
      case "HemisphereLight":
        f = new ff(a.color, a.groundColor, a.intensity);
        break;
      case "SkinnedMesh":
        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
      case "Mesh":
        f = d(a.geometry);
        var g = e(a.material);
        f = f.bones && 0 < f.bones.length ? new Ud(f, g) : new ca(f, g);
        break;
      case "InstancedMesh":
        f = d(a.geometry);
        g = e(a.material);
        var h2 = a.instanceMatrix;
        f = new Ve(f, g, a.count);
        f.instanceMatrix = new M(
          new Float32Array(h2.array),
          16
        );
        break;
      case "LOD":
        f = new Td();
        break;
      case "Line":
        f = new La(d(a.geometry), e(a.material), a.mode);
        break;
      case "LineLoop":
        f = new We(d(a.geometry), e(a.material));
        break;
      case "LineSegments":
        f = new ma(d(a.geometry), e(a.material));
        break;
      case "PointCloud":
      case "Points":
        f = new Pc(d(a.geometry), e(a.material));
        break;
      case "Sprite":
        f = new Rd(e(a.material));
        break;
      case "Group":
        f = new Mc();
        break;
      default:
        f = new D();
    }
    f.uuid = a.uuid;
    void 0 !== a.name && (f.name = a.name);
    void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (f.matrixAutoUpdate = a.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !== a.position && f.position.fromArray(a.position), void 0 !== a.rotation && f.rotation.fromArray(a.rotation), void 0 !== a.quaternion && f.quaternion.fromArray(a.quaternion), void 0 !== a.scale && f.scale.fromArray(a.scale));
    void 0 !== a.castShadow && (f.castShadow = a.castShadow);
    void 0 !== a.receiveShadow && (f.receiveShadow = a.receiveShadow);
    a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (f.shadow.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera)));
    void 0 !== a.visible && (f.visible = a.visible);
    void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled);
    void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder);
    void 0 !== a.userData && (f.userData = a.userData);
    void 0 !== a.layers && (f.layers.mask = a.layers);
    if (void 0 !== a.children) for (h2 = a.children, g = 0; g < h2.length; g++) f.add(this.parseObject(h2[g], b, c));
    if ("LOD" === a.type) for (void 0 !== a.autoUpdate && (f.autoUpdate = a.autoUpdate), a = a.levels, h2 = 0; h2 < a.length; h2++) {
      g = a[h2];
      var l = f.getObjectByProperty("uuid", g.object);
      void 0 !== l && f.addLevel(l, g.distance);
    }
    return f;
  } });
  var cl = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305, CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307 }, aj = {
    RepeatWrapping: 1e3,
    ClampToEdgeWrapping: 1001,
    MirroredRepeatWrapping: 1002
  }, bj = { NearestFilter: 1003, NearestMipmapNearestFilter: 1004, NearestMipmapLinearFilter: 1005, LinearFilter: 1006, LinearMipmapNearestFilter: 1007, LinearMipmapLinearFilter: 1008 };
  Cg.prototype = Object.assign(Object.create(V.prototype), { constructor: Cg, setOptions: function(a) {
    this.options = a;
    return this;
  }, load: function(a, b, c, d) {
    void 0 === a && (a = "");
    void 0 !== this.path && (a = this.path + a);
    a = this.manager.resolveURL(a);
    var e = this, f = vc.get(a);
    if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
      b && b(f);
      e.manager.itemEnd(a);
    }, 0), f;
    fetch(a).then(function(a2) {
      return a2.blob();
    }).then(function(a2) {
      return void 0 === e.options ? createImageBitmap(a2) : createImageBitmap(a2, e.options);
    }).then(function(c2) {
      vc.add(a, c2);
      b && b(c2);
      e.manager.itemEnd(a);
    }).catch(function(b2) {
      d && d(b2);
      e.manager.itemError(a);
      e.manager.itemEnd(a);
    });
    e.manager.itemStart(a);
  } });
  Object.assign(Dg.prototype, {
    moveTo: function(a, b) {
      this.currentPath = new ab();
      this.subPaths.push(this.currentPath);
      this.currentPath.moveTo(a, b);
      return this;
    },
    lineTo: function(a, b) {
      this.currentPath.lineTo(a, b);
      return this;
    },
    quadraticCurveTo: function(a, b, c, d) {
      this.currentPath.quadraticCurveTo(a, b, c, d);
      return this;
    },
    bezierCurveTo: function(a, b, c, d, e, f) {
      this.currentPath.bezierCurveTo(a, b, c, d, e, f);
      return this;
    },
    splineThru: function(a) {
      this.currentPath.splineThru(a);
      return this;
    },
    toShapes: function(a, b) {
      function c(a2) {
        for (var b2 = [], c2 = 0, d2 = a2.length; c2 < d2; c2++) {
          var e2 = a2[c2], f2 = new Lb();
          f2.curves = e2.curves;
          b2.push(f2);
        }
        return b2;
      }
      function d(a2, b2) {
        for (var c2 = b2.length, d2 = false, e2 = c2 - 1, f2 = 0; f2 < c2; e2 = f2++) {
          var g2 = b2[e2], h3 = b2[f2], k = h3.x - g2.x, l2 = h3.y - g2.y;
          if (Math.abs(l2) > Number.EPSILON) {
            if (0 > l2 && (g2 = b2[f2], k = -k, h3 = b2[e2], l2 = -l2), !(a2.y < g2.y || a2.y > h3.y)) if (a2.y === g2.y) {
              if (a2.x === g2.x) return true;
            } else {
              e2 = l2 * (a2.x - g2.x) - k * (a2.y - g2.y);
              if (0 === e2) return true;
              0 > e2 || (d2 = !d2);
            }
          } else if (a2.y === g2.y && (h3.x <= a2.x && a2.x <= g2.x || g2.x <= a2.x && a2.x <= h3.x)) return true;
        }
        return d2;
      }
      var e = tb.isClockWise, f = this.subPaths;
      if (0 === f.length) return [];
      if (true === b) return c(f);
      b = [];
      if (1 === f.length) {
        var g = f[0];
        var h2 = new Lb();
        h2.curves = g.curves;
        b.push(h2);
        return b;
      }
      var l = !e(f[0].getPoints());
      l = a ? !l : l;
      h2 = [];
      var m = [], n2 = [], p = 0;
      m[p] = void 0;
      n2[p] = [];
      for (var q = 0, t = f.length; q < t; q++) {
        g = f[q];
        var r = g.getPoints();
        var u = e(r);
        (u = a ? !u : u) ? (!l && m[p] && p++, m[p] = { s: new Lb(), p: r }, m[p].s.curves = g.curves, l && p++, n2[p] = []) : n2[p].push({ h: g, p: r[0] });
      }
      if (!m[0]) return c(f);
      if (1 < m.length) {
        q = false;
        a = [];
        e = 0;
        for (f = m.length; e < f; e++) h2[e] = [];
        e = 0;
        for (f = m.length; e < f; e++) for (g = n2[e], u = 0; u < g.length; u++) {
          l = g[u];
          p = true;
          for (r = 0; r < m.length; r++) d(l.p, m[r].p) && (e !== r && a.push({ froms: e, tos: r, hole: u }), p ? (p = false, h2[r].push(l)) : q = true);
          p && h2[e].push(l);
        }
        0 < a.length && (q || (n2 = h2));
      }
      q = 0;
      for (e = m.length; q < e; q++) for (h2 = m[q].s, b.push(h2), a = n2[q], f = 0, g = a.length; f < g; f++) h2.holes.push(a[f].h);
      return b;
    }
  });
  Object.assign(Eg.prototype, { isFont: true, generateShapes: function(a, b) {
    void 0 === b && (b = 100);
    var c = [], d = b;
    b = this.data;
    var e = Array.from ? Array.from(a) : String(a).split("");
    d /= b.resolution;
    var f = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * d;
    a = [];
    for (var g = 0, h2 = 0, l = 0; l < e.length; l++) {
      var m = e[l];
      if ("\n" === m) g = 0, h2 -= f;
      else {
        var n2 = m;
        m = d;
        var p = g, q = h2, t = b, r = t.glyphs[n2] || t.glyphs["?"];
        if (r) {
          n2 = new Dg();
          if (r.o) {
            t = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
            for (var u = 0, w2 = t.length; u < w2; ) switch (t[u++]) {
              case "m":
                var v = t[u++] * m + p;
                var A2 = t[u++] * m + q;
                n2.moveTo(v, A2);
                break;
              case "l":
                v = t[u++] * m + p;
                A2 = t[u++] * m + q;
                n2.lineTo(v, A2);
                break;
              case "q":
                var B2 = t[u++] * m + p;
                var D2 = t[u++] * m + q;
                var z = t[u++] * m + p;
                var E2 = t[u++] * m + q;
                n2.quadraticCurveTo(z, E2, B2, D2);
                break;
              case "b":
                B2 = t[u++] * m + p, D2 = t[u++] * m + q, z = t[u++] * m + p, E2 = t[u++] * m + q, v = t[u++] * m + p, A2 = t[u++] * m + q, n2.bezierCurveTo(z, E2, v, A2, B2, D2);
            }
          }
          m = { offsetX: r.ha * m, path: n2 };
        } else console.error('THREE.Font: character "' + n2 + '" does not exists in font family ' + t.familyName + "."), m = void 0;
        g += m.offsetX;
        a.push(m.path);
      }
    }
    b = 0;
    for (e = a.length; b < e; b++) Array.prototype.push.apply(c, a[b].toShapes());
    return c;
  } });
  Fg.prototype = Object.assign(Object.create(V.prototype), { constructor: Fg, load: function(a, b, c, d) {
    var e = this, f = new Sa(this.manager);
    f.setPath(this.path);
    f.load(a, function(a2) {
      try {
        var c2 = JSON.parse(a2);
      } catch (l) {
        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c2 = JSON.parse(a2.substring(
          65,
          a2.length - 2
        ));
      }
      a2 = e.parse(c2);
      b && b(a2);
    }, c, d);
  }, parse: function(a) {
    return new Eg(a);
  } });
  var Vf, Kg = { getContext: function() {
    void 0 === Vf && (Vf = new (window.AudioContext || window.webkitAudioContext)());
    return Vf;
  }, setContext: function(a) {
    Vf = a;
  } };
  tf.prototype = Object.assign(Object.create(V.prototype), { constructor: tf, load: function(a, b, c, d) {
    var e = new Sa(this.manager);
    e.setResponseType("arraybuffer");
    e.setPath(this.path);
    e.load(a, function(a2) {
      a2 = a2.slice(0);
      Kg.getContext().decodeAudioData(a2, function(a3) {
        b(a3);
      });
    }, c, d);
  } });
  Object.assign(
    uf.prototype,
    { isSphericalHarmonics3: true, set: function(a) {
      for (var b = 0; 9 > b; b++) this.coefficients[b].copy(a[b]);
      return this;
    }, zero: function() {
      for (var a = 0; 9 > a; a++) this.coefficients[a].set(0, 0, 0);
      return this;
    }, getAt: function(a, b) {
      var c = a.x, d = a.y;
      a = a.z;
      var e = this.coefficients;
      b.copy(e[0]).multiplyScalar(0.282095);
      b.addScale(e[1], 0.488603 * d);
      b.addScale(e[2], 0.488603 * a);
      b.addScale(e[3], 0.488603 * c);
      b.addScale(e[4], 1.092548 * c * d);
      b.addScale(e[5], 1.092548 * d * a);
      b.addScale(e[6], 0.315392 * (3 * a * a - 1));
      b.addScale(e[7], 1.092548 * c * a);
      b.addScale(
        e[8],
        0.546274 * (c * c - d * d)
      );
      return b;
    }, getIrradianceAt: function(a, b) {
      var c = a.x, d = a.y;
      a = a.z;
      var e = this.coefficients;
      b.copy(e[0]).multiplyScalar(0.886227);
      b.addScale(e[1], 1.023328 * d);
      b.addScale(e[2], 1.023328 * a);
      b.addScale(e[3], 1.023328 * c);
      b.addScale(e[4], 0.858086 * c * d);
      b.addScale(e[5], 0.858086 * d * a);
      b.addScale(e[6], 0.743125 * a * a - 0.247708);
      b.addScale(e[7], 0.858086 * c * a);
      b.addScale(e[8], 0.429043 * (c * c - d * d));
      return b;
    }, add: function(a) {
      for (var b = 0; 9 > b; b++) this.coefficients[b].add(a.coefficients[b]);
      return this;
    }, scale: function(a) {
      for (var b = 0; 9 > b; b++) this.coefficients[b].multiplyScalar(a);
      return this;
    }, lerp: function(a, b) {
      for (var c = 0; 9 > c; c++) this.coefficients[c].lerp(a.coefficients[c], b);
      return this;
    }, equals: function(a) {
      for (var b = 0; 9 > b; b++) if (!this.coefficients[b].equals(a.coefficients[b])) return false;
      return true;
    }, copy: function(a) {
      return this.set(a.coefficients);
    }, clone: function() {
      return new this.constructor().copy(this);
    }, fromArray: function(a, b) {
      void 0 === b && (b = 0);
      for (var c = this.coefficients, d = 0; 9 > d; d++) c[d].fromArray(a, b + 3 * d);
      return this;
    }, toArray: function(a, b) {
      void 0 === a && (a = []);
      void 0 === b && (b = 0);
      for (var c = this.coefficients, d = 0; 9 > d; d++) c[d].toArray(a, b + 3 * d);
      return a;
    } }
  );
  Object.assign(uf, { getBasisAt: function(a, b) {
    var c = a.x, d = a.y;
    a = a.z;
    b[0] = 0.282095;
    b[1] = 0.488603 * d;
    b[2] = 0.488603 * a;
    b[3] = 0.488603 * c;
    b[4] = 1.092548 * c * d;
    b[5] = 1.092548 * d * a;
    b[6] = 0.315392 * (3 * a * a - 1);
    b[7] = 1.092548 * c * a;
    b[8] = 0.546274 * (c * c - d * d);
  } });
  bb.prototype = Object.assign(Object.create(ba.prototype), { constructor: bb, isLightProbe: true, copy: function(a) {
    ba.prototype.copy.call(this, a);
    this.sh.copy(a.sh);
    this.intensity = a.intensity;
    return this;
  }, toJSON: function(a) {
    return ba.prototype.toJSON.call(this, a);
  } });
  Gg.prototype = Object.assign(Object.create(bb.prototype), { constructor: Gg, isHemisphereLightProbe: true, copy: function(a) {
    bb.prototype.copy.call(this, a);
    return this;
  }, toJSON: function(a) {
    return bb.prototype.toJSON.call(this, a);
  } });
  Hg.prototype = Object.assign(Object.create(bb.prototype), { constructor: Hg, isAmbientLightProbe: true, copy: function(a) {
    bb.prototype.copy.call(this, a);
    return this;
  }, toJSON: function(a) {
    return bb.prototype.toJSON.call(
      this,
      a
    );
  } });
  var cj = new O(), dj = new O();
  Object.assign(li.prototype, { update: function(a) {
    var b = this._cache;
    if (b.focus !== a.focus || b.fov !== a.fov || b.aspect !== a.aspect * this.aspect || b.near !== a.near || b.far !== a.far || b.zoom !== a.zoom || b.eyeSep !== this.eyeSep) {
      b.focus = a.focus;
      b.fov = a.fov;
      b.aspect = a.aspect * this.aspect;
      b.near = a.near;
      b.far = a.far;
      b.zoom = a.zoom;
      b.eyeSep = this.eyeSep;
      var c = a.projectionMatrix.clone(), d = b.eyeSep / 2, e = d * b.near / b.focus, f = b.near * Math.tan(P.DEG2RAD * b.fov * 0.5) / b.zoom;
      dj.elements[12] = -d;
      cj.elements[12] = d;
      d = -f * b.aspect + e;
      var g = f * b.aspect + e;
      c.elements[0] = 2 * b.near / (g - d);
      c.elements[8] = (g + d) / (g - d);
      this.cameraL.projectionMatrix.copy(c);
      d = -f * b.aspect - e;
      g = f * b.aspect - e;
      c.elements[0] = 2 * b.near / (g - d);
      c.elements[8] = (g + d) / (g - d);
      this.cameraR.projectionMatrix.copy(c);
    }
    this.cameraL.matrixWorld.copy(a.matrixWorld).multiply(dj);
    this.cameraR.matrixWorld.copy(a.matrixWorld).multiply(cj);
  } });
  Object.assign(Ig.prototype, { start: function() {
    this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now();
    this.elapsedTime = 0;
    this.running = true;
  }, stop: function() {
    this.getElapsedTime();
    this.autoStart = this.running = false;
  }, getElapsedTime: function() {
    this.getDelta();
    return this.elapsedTime;
  }, getDelta: function() {
    var a = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      var b = ("undefined" === typeof performance ? Date : performance).now();
      a = (b - this.oldTime) / 1e3;
      this.oldTime = b;
      this.elapsedTime += a;
    }
    return a;
  } });
  var wc = new n(), ej = new Da(), dl = new n(), xc = new n();
  Jg.prototype = Object.assign(
    Object.create(D.prototype),
    { constructor: Jg, getInput: function() {
      return this.gain;
    }, removeFilter: function() {
      null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null);
      return this;
    }, getFilter: function() {
      return this.filter;
    }, setFilter: function(a) {
      null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination);
      this.filter = a;
      this.gain.connect(this.filter);
      this.filter.connect(this.context.destination);
      return this;
    }, getMasterVolume: function() {
      return this.gain.gain.value;
    }, setMasterVolume: function(a) {
      this.gain.gain.setTargetAtTime(a, this.context.currentTime, 0.01);
      return this;
    }, updateMatrixWorld: function(a) {
      D.prototype.updateMatrixWorld.call(this, a);
      a = this.context.listener;
      var b = this.up;
      this.timeDelta = this._clock.getDelta();
      this.matrixWorld.decompose(wc, ej, dl);
      xc.set(0, 0, -1).applyQuaternion(ej);
      if (a.positionX) {
        var c = this.context.currentTime + this.timeDelta;
        a.positionX.linearRampToValueAtTime(wc.x, c);
        a.positionY.linearRampToValueAtTime(wc.y, c);
        a.positionZ.linearRampToValueAtTime(wc.z, c);
        a.forwardX.linearRampToValueAtTime(xc.x, c);
        a.forwardY.linearRampToValueAtTime(xc.y, c);
        a.forwardZ.linearRampToValueAtTime(xc.z, c);
        a.upX.linearRampToValueAtTime(b.x, c);
        a.upY.linearRampToValueAtTime(b.y, c);
        a.upZ.linearRampToValueAtTime(b.z, c);
      } else a.setPosition(wc.x, wc.y, wc.z), a.setOrientation(xc.x, xc.y, xc.z, b.x, b.y, b.z);
    } }
  );
  id.prototype = Object.assign(
    Object.create(D.prototype),
    {
      constructor: id,
      getOutput: function() {
        return this.gain;
      },
      setNodeSource: function(a) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = a;
        this.connect();
        return this;
      },
      setMediaElementSource: function(a) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(a);
        this.connect();
        return this;
      },
      setMediaStreamSource: function(a) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(a);
        this.connect();
        return this;
      },
      setBuffer: function(a) {
        this.buffer = a;
        this.sourceType = "buffer";
        this.autoplay && this.play();
        return this;
      },
      play: function(a) {
        void 0 === a && (a = 0);
        if (true === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
        else if (false === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return this._startedAt = this.context.currentTime + a, a = this.context.createBufferSource(), a.buffer = this.buffer, a.loop = this.loop, a.loopStart = this.loopStart, a.loopEnd = this.loopEnd, a.onended = this.onEnded.bind(this), a.start(this._startedAt, this._pausedAt + this.offset, this.duration), this.isPlaying = true, this.source = a, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
      },
      pause: function() {
        if (false === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return true === this.isPlaying && (this._pausedAt = (this.context.currentTime - this._startedAt) * this.playbackRate, this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
      },
      stop: function() {
        if (false === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return this._pausedAt = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
      },
      connect: function() {
        if (0 < this.filters.length) {
          this.source.connect(this.filters[0]);
          for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
      },
      disconnect: function() {
        if (0 < this.filters.length) {
          this.source.disconnect(this.filters[0]);
          for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
      },
      getFilters: function() {
        return this.filters;
      },
      setFilters: function(a) {
        a || (a = []);
        true === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
        return this;
      },
      setDetune: function(a) {
        this.detune = a;
        if (void 0 !== this.source.detune) return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
      },
      getDetune: function() {
        return this.detune;
      },
      getFilter: function() {
        return this.getFilters()[0];
      },
      setFilter: function(a) {
        return this.setFilters(a ? [a] : []);
      },
      setPlaybackRate: function(a) {
        if (false === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return this.playbackRate = a, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ), this;
      },
      getPlaybackRate: function() {
        return this.playbackRate;
      },
      onEnded: function() {
        this.isPlaying = false;
      },
      getLoop: function() {
        return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
      },
      setLoop: function(a) {
        if (false === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
        else return this.loop = a, true === this.isPlaying && (this.source.loop = this.loop), this;
      },
      setLoopStart: function(a) {
        this.loopStart = a;
        return this;
      },
      setLoopEnd: function(a) {
        this.loopEnd = a;
        return this;
      },
      getVolume: function() {
        return this.gain.gain.value;
      },
      setVolume: function(a) {
        this.gain.gain.setTargetAtTime(a, this.context.currentTime, 0.01);
        return this;
      }
    }
  );
  var yc = new n(), fj = new Da(), el = new n(), zc = new n();
  Lg.prototype = Object.assign(Object.create(id.prototype), {
    constructor: Lg,
    getOutput: function() {
      return this.panner;
    },
    getRefDistance: function() {
      return this.panner.refDistance;
    },
    setRefDistance: function(a) {
      this.panner.refDistance = a;
      return this;
    },
    getRolloffFactor: function() {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(a) {
      this.panner.rolloffFactor = a;
      return this;
    },
    getDistanceModel: function() {
      return this.panner.distanceModel;
    },
    setDistanceModel: function(a) {
      this.panner.distanceModel = a;
      return this;
    },
    getMaxDistance: function() {
      return this.panner.maxDistance;
    },
    setMaxDistance: function(a) {
      this.panner.maxDistance = a;
      return this;
    },
    setDirectionalCone: function(a, b, c) {
      this.panner.coneInnerAngle = a;
      this.panner.coneOuterAngle = b;
      this.panner.coneOuterGain = c;
      return this;
    },
    updateMatrixWorld: function(a) {
      D.prototype.updateMatrixWorld.call(
        this,
        a
      );
      if (true !== this.hasPlaybackControl || false !== this.isPlaying) if (this.matrixWorld.decompose(yc, fj, el), zc.set(0, 0, 1).applyQuaternion(fj), a = this.panner, a.positionX) {
        var b = this.context.currentTime + this.listener.timeDelta;
        a.positionX.linearRampToValueAtTime(yc.x, b);
        a.positionY.linearRampToValueAtTime(yc.y, b);
        a.positionZ.linearRampToValueAtTime(yc.z, b);
        a.orientationX.linearRampToValueAtTime(zc.x, b);
        a.orientationY.linearRampToValueAtTime(zc.y, b);
        a.orientationZ.linearRampToValueAtTime(zc.z, b);
      } else a.setPosition(
        yc.x,
        yc.y,
        yc.z
      ), a.setOrientation(zc.x, zc.y, zc.z);
    }
  });
  Object.assign(Mg.prototype, { getFrequencyData: function() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }, getAverageFrequency: function() {
    for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
    return a / b.length;
  } });
  Object.assign(Ng.prototype, { accumulate: function(a, b) {
    var c = this.buffer, d = this.valueSize;
    a = a * d + d;
    var e = this.cumulativeWeight;
    if (0 === e) {
      for (e = 0; e !== d; ++e) c[a + e] = c[e];
      e = b;
    } else e += b, this._mixBufferRegion(c, a, 0, b / e, d);
    this.cumulativeWeight = e;
  }, apply: function(a) {
    var b = this.valueSize, c = this.buffer;
    a = a * b + b;
    var d = this.cumulativeWeight, e = this.binding;
    this.cumulativeWeight = 0;
    1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
    d = b;
    for (var f = b + b; d !== f; ++d) if (c[d] !== c[d + b]) {
      e.setValue(c, a);
      break;
    }
  }, saveOriginalState: function() {
    var a = this.buffer, b = this.valueSize, c = 3 * b;
    this.binding.getValue(a, c);
    for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
    this.cumulativeWeight = 0;
  }, restoreOriginalState: function() {
    this.binding.setValue(this.buffer, 3 * this.valueSize);
  }, _select: function(a, b, c, d, e) {
    if (0.5 <= d) for (d = 0; d !== e; ++d) a[b + d] = a[c + d];
  }, _slerp: function(a, b, c, d) {
    Da.slerpFlat(a, b, a, b, a, c, d);
  }, _lerp: function(a, b, c, d, e) {
    for (var f = 1 - d, g = 0; g !== e; ++g) {
      var h2 = b + g;
      a[h2] = a[h2] * f + a[c + g] * d;
    }
  } });
  var fl = /[\[\]\.:\/]/g, gl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", hl = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), il = /(WCOD+)?/.source.replace("WCOD", gl), jl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), kl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), ll = new RegExp("^" + hl + il + jl + kl + "$"), ml = ["material", "materials", "bones"];
  Object.assign(mi.prototype, { getValue: function(a, b) {
    this.bind();
    var c = this._bindings[this._targetGroup.nCachedObjects_];
    void 0 !== c && c.getValue(a, b);
  }, setValue: function(a, b) {
    for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b);
  }, bind: function() {
    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind();
  }, unbind: function() {
    for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind();
  } });
  Object.assign(Ba, { Composite: mi, create: function(a, b, c) {
    return a && a.isAnimationObjectGroup ? new Ba.Composite(a, b, c) : new Ba(a, b, c);
  }, sanitizeNodeName: function(a) {
    return a.replace(/\s/g, "_").replace(fl, "");
  }, parseTrackName: function(a) {
    var b = ll.exec(a);
    if (!b) throw Error("PropertyBinding: Cannot parse trackName: " + a);
    b = { nodeName: b[2], objectName: b[3], objectIndex: b[4], propertyName: b[5], propertyIndex: b[6] };
    var c = b.nodeName && b.nodeName.lastIndexOf(".");
    if (void 0 !== c && -1 !== c) {
      var d = b.nodeName.substring(c + 1);
      -1 !== ml.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c), b.objectName = d);
    }
    if (null === b.propertyName || 0 === b.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + a);
    return b;
  }, findNode: function(a, b) {
    if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
    if (a.skeleton) {
      var c = a.skeleton.getBoneByName(b);
      if (void 0 !== c) return c;
    }
    if (a.children) {
      var d = function(a2) {
        for (var c2 = 0; c2 < a2.length; c2++) {
          var e = a2[c2];
          if (e.name === b || e.uuid === b || (e = d(e.children))) return e;
        }
        return null;
      };
      if (a = d(a.children)) return a;
    }
    return null;
  } });
  Object.assign(Ba.prototype, { _getValue_unavailable: function() {
  }, _setValue_unavailable: function() {
  }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [
    function(a, b) {
      a[b] = this.node[this.propertyName];
    },
    function(a, b) {
      for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d];
    },
    function(a, b) {
      a[b] = this.resolvedProperty[this.propertyIndex];
    },
    function(a, b) {
      this.resolvedProperty.toArray(a, b);
    }
  ], SetterByBindingTypeAndVersioning: [[function(a, b) {
    this.targetObject[this.propertyName] = a[b];
  }, function(a, b) {
    this.targetObject[this.propertyName] = a[b];
    this.targetObject.needsUpdate = true;
  }, function(a, b) {
    this.targetObject[this.propertyName] = a[b];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [function(a, b) {
    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
  }, function(a, b) {
    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
    this.targetObject.needsUpdate = true;
  }, function(a, b) {
    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
  }, function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
    this.targetObject.needsUpdate = true;
  }, function(a, b) {
    this.resolvedProperty[this.propertyIndex] = a[b];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [function(a, b) {
    this.resolvedProperty.fromArray(a, b);
  }, function(a, b) {
    this.resolvedProperty.fromArray(
      a,
      b
    );
    this.targetObject.needsUpdate = true;
  }, function(a, b) {
    this.resolvedProperty.fromArray(a, b);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }]], getValue: function(a, b) {
    this.bind();
    this.getValue(a, b);
  }, setValue: function(a, b) {
    this.bind();
    this.setValue(a, b);
  }, bind: function() {
    var a = this.node, b = this.parsedPath, c = b.objectName, d = b.propertyName, e = b.propertyIndex;
    a || (this.node = a = Ba.findNode(this.rootNode, b.nodeName) || this.rootNode);
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (a) {
      if (c) {
        var f = b.objectIndex;
        switch (c) {
          case "materials":
            if (!a.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!a.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            a = a.material.materials;
            break;
          case "bones":
            if (!a.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            a = a.skeleton.bones;
            for (c = 0; c < a.length; c++) if (a[c].name === f) {
              f = c;
              break;
            }
            break;
          default:
            if (void 0 === a[c]) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            a = a[c];
        }
        if (void 0 !== f) {
          if (void 0 === a[f]) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, a);
            return;
          }
          a = a[f];
        }
      }
      f = a[d];
      if (void 0 === f) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a);
      else {
        b = this.Versioning.None;
        this.targetObject = a;
        void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate);
        c = this.BindingType.Direct;
        if (void 0 !== e) {
          if ("morphTargetInfluences" === d) {
            if (!a.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (a.geometry.isBufferGeometry) {
              if (!a.geometry.morphAttributes) {
                console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
                return;
              }
              for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++) if (a.geometry.morphAttributes.position[c].name === e) {
                e = c;
                break;
              }
            } else {
              if (!a.geometry.morphTargets) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                return;
              }
              for (c = 0; c < this.node.geometry.morphTargets.length; c++) if (a.geometry.morphTargets[c].name === e) {
                e = c;
                break;
              }
            }
          }
          c = this.BindingType.ArrayElement;
          this.resolvedProperty = f;
          this.propertyIndex = e;
        } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d;
        this.getValue = this.GetterByBindingType[c];
        this.setValue = this.SetterByBindingTypeAndVersioning[c][b];
      }
    } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
  }, unbind: function() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  } });
  Object.assign(Ba.prototype, { _getValue_unbound: Ba.prototype.getValue, _setValue_unbound: Ba.prototype.setValue });
  Object.assign(ni.prototype, { isAnimationObjectGroup: true, add: function() {
    for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, f = this._parsedPaths, g = this._bindings, h2 = g.length, l = void 0, m = 0, n2 = arguments.length; m !== n2; ++m) {
      var p = arguments[m], q = p.uuid, t = d[q];
      if (void 0 === t) {
        t = b++;
        d[q] = t;
        a.push(p);
        q = 0;
        for (var r = h2; q !== r; ++q) g[q].push(new Ba(p, e[q], f[q]));
      } else if (t < c) {
        l = a[t];
        var u = --c;
        r = a[u];
        d[r.uuid] = t;
        a[t] = r;
        d[q] = u;
        a[u] = p;
        q = 0;
        for (r = h2; q !== r; ++q) {
          var w2 = g[q], v = w2[t];
          w2[t] = w2[u];
          void 0 === v && (v = new Ba(p, e[q], f[q]));
          w2[u] = v;
        }
      } else a[t] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = c;
  }, remove: function() {
    for (var a = this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, d = this._bindings, e = d.length, f = 0, g = arguments.length; f !== g; ++f) {
      var h2 = arguments[f], l = h2.uuid, m = c[l];
      if (void 0 !== m && m >= b) {
        var n2 = b++, p = a[n2];
        c[p.uuid] = m;
        a[m] = p;
        c[l] = n2;
        a[n2] = h2;
        h2 = 0;
        for (l = e; h2 !== l; ++h2) {
          p = d[h2];
          var q = p[m];
          p[m] = p[n2];
          p[n2] = q;
        }
      }
    }
    this.nCachedObjects_ = b;
  }, uncache: function() {
    for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h2 = arguments.length; g !== h2; ++g) {
      var l = arguments[g].uuid, m = d[l];
      if (void 0 !== m) if (delete d[l], m < c) {
        l = --c;
        var n2 = a[l], p = --b, q = a[p];
        d[n2.uuid] = m;
        a[m] = n2;
        d[q.uuid] = l;
        a[l] = q;
        a.pop();
        n2 = 0;
        for (q = f; n2 !== q; ++n2) {
          var t = e[n2], r = t[p];
          t[m] = t[l];
          t[l] = r;
          t.pop();
        }
      } else for (p = --b, q = a[p], d[q.uuid] = m, a[m] = q, a.pop(), n2 = 0, q = f; n2 !== q; ++n2) t = e[n2], t[m] = t[p], t.pop();
    }
    this.nCachedObjects_ = c;
  }, subscribe_: function(a, b) {
    var c = this._bindingsIndicesByPath, d = c[a], e = this._bindings;
    if (void 0 !== d) return e[d];
    var f = this._paths, g = this._parsedPaths, h2 = this._objects, l = this.nCachedObjects_, m = Array(h2.length);
    d = e.length;
    c[a] = d;
    f.push(a);
    g.push(b);
    e.push(m);
    c = l;
    for (d = h2.length; c !== d; ++c) m[c] = new Ba(h2[c], a, b);
    return m;
  }, unsubscribe_: function(a) {
    var b = this._bindingsIndicesByPath, c = b[a];
    if (void 0 !== c) {
      var d = this._paths, e = this._parsedPaths, f = this._bindings, g = f.length - 1, h2 = f[g];
      b[a[g]] = c;
      f[c] = h2;
      f.pop();
      e[c] = e[g];
      e.pop();
      d[c] = d[g];
      d.pop();
    }
  } });
  Object.assign(oi.prototype, {
    play: function() {
      this._mixer._activateAction(this);
      return this;
    },
    stop: function() {
      this._mixer._deactivateAction(this);
      return this.reset();
    },
    reset: function() {
      this.paused = false;
      this.enabled = true;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    },
    isRunning: function() {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
    },
    isScheduled: function() {
      return this._mixer._isActiveAction(this);
    },
    startAt: function(a) {
      this._startTime = a;
      return this;
    },
    setLoop: function(a, b) {
      this.loop = a;
      this.repetitions = b;
      return this;
    },
    setEffectiveWeight: function(a) {
      this.weight = a;
      this._effectiveWeight = this.enabled ? a : 0;
      return this.stopFading();
    },
    getEffectiveWeight: function() {
      return this._effectiveWeight;
    },
    fadeIn: function(a) {
      return this._scheduleFading(a, 0, 1);
    },
    fadeOut: function(a) {
      return this._scheduleFading(
        a,
        1,
        0
      );
    },
    crossFadeFrom: function(a, b, c) {
      a.fadeOut(b);
      this.fadeIn(b);
      if (c) {
        c = this._clip.duration;
        var d = a._clip.duration, e = c / d;
        a.warp(1, d / c, b);
        this.warp(e, 1, b);
      }
      return this;
    },
    crossFadeTo: function(a, b, c) {
      return a.crossFadeFrom(this, b, c);
    },
    stopFading: function() {
      var a = this._weightInterpolant;
      null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
      return this;
    },
    setEffectiveTimeScale: function(a) {
      this.timeScale = a;
      this._effectiveTimeScale = this.paused ? 0 : a;
      return this.stopWarping();
    },
    getEffectiveTimeScale: function() {
      return this._effectiveTimeScale;
    },
    setDuration: function(a) {
      this.timeScale = this._clip.duration / a;
      return this.stopWarping();
    },
    syncWith: function(a) {
      this.time = a.time;
      this.timeScale = a.timeScale;
      return this.stopWarping();
    },
    halt: function(a) {
      return this.warp(this._effectiveTimeScale, 0, a);
    },
    warp: function(a, b, c) {
      var d = this._mixer, e = d.time, f = this._timeScaleInterpolant, g = this.timeScale;
      null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant());
      d = f.parameterPositions;
      f = f.sampleValues;
      d[0] = e;
      d[1] = e + c;
      f[0] = a / g;
      f[1] = b / g;
      return this;
    },
    stopWarping: function() {
      var a = this._timeScaleInterpolant;
      null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
      return this;
    },
    getMixer: function() {
      return this._mixer;
    },
    getClip: function() {
      return this._clip;
    },
    getRoot: function() {
      return this._localRoot || this._mixer._root;
    },
    _update: function(a, b, c, d) {
      if (this.enabled) {
        var e = this._startTime;
        if (null !== e) {
          b = (a - e) * c;
          if (0 > b || 0 === c) return;
          this._startTime = null;
          b *= c;
        }
        b *= this._updateTimeScale(a);
        c = this._updateTime(b);
        a = this._updateWeight(a);
        if (0 < a) {
          b = this._interpolants;
          e = this._propertyBindings;
          for (var f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a);
        }
      } else this._updateWeight(a);
    },
    _updateWeight: function(a) {
      var b = 0;
      if (this.enabled) {
        b = this.weight;
        var c = this._weightInterpolant;
        if (null !== c) {
          var d = c.evaluate(a)[0];
          b *= d;
          a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = false));
        }
      }
      return this._effectiveWeight = b;
    },
    _updateTimeScale: function(a) {
      var b = 0;
      if (!this.paused) {
        b = this.timeScale;
        var c = this._timeScaleInterpolant;
        if (null !== c) {
          var d = c.evaluate(a)[0];
          b *= d;
          a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = true : this.timeScale = b);
        }
      }
      return this._effectiveTimeScale = b;
    },
    _updateTime: function(a) {
      var b = this.time + a, c = this._clip.duration, d = this.loop, e = this._loopCount, f = 2202 === d;
      if (0 === a) return -1 === e ? b : f && 1 === (e & 1) ? c - b : b;
      if (2200 === d) a: {
        if (-1 === e && (this._loopCount = 0, this._setEndings(true, true, false)), b >= c) b = c;
        else if (0 > b) b = 0;
        else {
          this.time = b;
          break a;
        }
        this.clampWhenFinished ? this.paused = true : this.enabled = false;
        this.time = b;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: 0 > a ? -1 : 1
        });
      }
      else {
        -1 === e && (0 <= a ? (e = 0, this._setEndings(true, 0 === this.repetitions, f)) : this._setEndings(0 === this.repetitions, true, f));
        if (b >= c || 0 > b) {
          d = Math.floor(b / c);
          b -= c * d;
          e += Math.abs(d);
          var g = this.repetitions - e;
          0 >= g ? (this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = b = 0 < a ? c : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < a ? 1 : -1 })) : (1 === g ? (a = 0 > a, this._setEndings(a, !a, f)) : this._setEndings(false, false, f), this._loopCount = e, this.time = b, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: d
          }));
        } else this.time = b;
        if (f && 1 === (e & 1)) return c - b;
      }
      return b;
    },
    _setEndings: function(a, b, c) {
      var d = this._interpolantSettings;
      c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    },
    _scheduleFading: function(a, b, c) {
      var d = this._mixer, e = d.time, f = this._weightInterpolant;
      null === f && (this._weightInterpolant = f = d._lendControlInterpolant());
      d = f.parameterPositions;
      f = f.sampleValues;
      d[0] = e;
      f[0] = b;
      d[1] = e + a;
      f[1] = c;
      return this;
    }
  });
  Og.prototype = Object.assign(Object.create(Fa.prototype), {
    constructor: Og,
    _bindAction: function(a, b) {
      var c = a._localRoot || this._root, d = a._clip.tracks, e = d.length, f = a._propertyBindings;
      a = a._interpolants;
      var g = c.uuid, h2 = this._bindingsByRootAndName, l = h2[g];
      void 0 === l && (l = {}, h2[g] = l);
      for (h2 = 0; h2 !== e; ++h2) {
        var m = d[h2], n2 = m.name, p = l[n2];
        if (void 0 === p) {
          p = f[h2];
          if (void 0 !== p) {
            null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, g, n2));
            continue;
          }
          p = new Ng(
            Ba.create(c, n2, b && b._propertyBindings[h2].binding.parsedPath),
            m.ValueTypeName,
            m.getValueSize()
          );
          ++p.referenceCount;
          this._addInactiveBinding(p, g, n2);
        }
        f[h2] = p;
        a[h2].resultBuffer = p.buffer;
      }
    },
    _activateAction: function(a) {
      if (!this._isActiveAction(a)) {
        if (null === a._cacheIndex) {
          var b = (a._localRoot || this._root).uuid, c = a._clip.uuid, d = this._actionsByClip[c];
          this._bindAction(a, d && d.knownActions[0]);
          this._addInactiveAction(a, c, b);
        }
        b = a._propertyBindings;
        c = 0;
        for (d = b.length; c !== d; ++c) {
          var e = b[c];
          0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState());
        }
        this._lendAction(a);
      }
    },
    _deactivateAction: function(a) {
      if (this._isActiveAction(a)) {
        for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
          var e = b[c];
          0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e));
        }
        this._takeBackAction(a);
      }
    },
    _initMemoryManager: function() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      var a = this;
      this.stats = { actions: {
        get total() {
          return a._actions.length;
        },
        get inUse() {
          return a._nActiveActions;
        }
      }, bindings: { get total() {
        return a._bindings.length;
      }, get inUse() {
        return a._nActiveBindings;
      } }, controlInterpolants: { get total() {
        return a._controlInterpolants.length;
      }, get inUse() {
        return a._nActiveControlInterpolants;
      } } };
    },
    _isActiveAction: function(a) {
      a = a._cacheIndex;
      return null !== a && a < this._nActiveActions;
    },
    _addInactiveAction: function(a, b, c) {
      var d = this._actions, e = this._actionsByClip, f = e[b];
      void 0 === f ? (f = { knownActions: [a], actionByRoot: {} }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a));
      a._cacheIndex = d.length;
      d.push(a);
      f.actionByRoot[c] = a;
    },
    _removeInactiveAction: function(a) {
      var b = this._actions, c = b[b.length - 1], d = a._cacheIndex;
      c._cacheIndex = d;
      b[d] = c;
      b.pop();
      a._cacheIndex = null;
      b = a._clip.uuid;
      c = this._actionsByClip;
      d = c[b];
      var e = d.knownActions, f = e[e.length - 1], g = a._byClipCacheIndex;
      f._byClipCacheIndex = g;
      e[g] = f;
      e.pop();
      a._byClipCacheIndex = null;
      delete d.actionByRoot[(a._localRoot || this._root).uuid];
      0 === e.length && delete c[b];
      this._removeInactiveBindingsForAction(a);
    },
    _removeInactiveBindingsForAction: function(a) {
      a = a._propertyBindings;
      for (var b = 0, c = a.length; b !== c; ++b) {
        var d = a[b];
        0 === --d.referenceCount && this._removeInactiveBinding(d);
      }
    },
    _lendAction: function(a) {
      var b = this._actions, c = a._cacheIndex, d = this._nActiveActions++, e = b[d];
      a._cacheIndex = d;
      b[d] = a;
      e._cacheIndex = c;
      b[c] = e;
    },
    _takeBackAction: function(a) {
      var b = this._actions, c = a._cacheIndex, d = --this._nActiveActions, e = b[d];
      a._cacheIndex = d;
      b[d] = a;
      e._cacheIndex = c;
      b[c] = e;
    },
    _addInactiveBinding: function(a, b, c) {
      var d = this._bindingsByRootAndName, e = d[b], f = this._bindings;
      void 0 === e && (e = {}, d[b] = e);
      e[c] = a;
      a._cacheIndex = f.length;
      f.push(a);
    },
    _removeInactiveBinding: function(a) {
      var b = this._bindings, c = a.binding, d = c.rootNode.uuid;
      c = c.path;
      var e = this._bindingsByRootAndName, f = e[d], g = b[b.length - 1];
      a = a._cacheIndex;
      g._cacheIndex = a;
      b[a] = g;
      b.pop();
      delete f[c];
      0 === Object.keys(f).length && delete e[d];
    },
    _lendBinding: function(a) {
      var b = this._bindings, c = a._cacheIndex, d = this._nActiveBindings++, e = b[d];
      a._cacheIndex = d;
      b[d] = a;
      e._cacheIndex = c;
      b[c] = e;
    },
    _takeBackBinding: function(a) {
      var b = this._bindings, c = a._cacheIndex, d = --this._nActiveBindings, e = b[d];
      a._cacheIndex = d;
      b[d] = a;
      e._cacheIndex = c;
      b[c] = e;
    },
    _lendControlInterpolant: function() {
      var a = this._controlInterpolants, b = this._nActiveControlInterpolants++, c = a[b];
      void 0 === c && (c = new qe(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
      return c;
    },
    _takeBackControlInterpolant: function(a) {
      var b = this._controlInterpolants, c = a.__cacheIndex, d = --this._nActiveControlInterpolants, e = b[d];
      a.__cacheIndex = d;
      b[d] = a;
      e.__cacheIndex = c;
      b[c] = e;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(a, b) {
      var c = b || this._root, d = c.uuid;
      c = "string" === typeof a ? Ra.findByName(c, a) : a;
      a = null !== c ? c.uuid : a;
      var e = this._actionsByClip[a], f = null;
      if (void 0 !== e) {
        f = e.actionByRoot[d];
        if (void 0 !== f) return f;
        f = e.knownActions[0];
        null === c && (c = f._clip);
      }
      if (null === c) return null;
      b = new oi(this, c, b);
      this._bindAction(b, f);
      this._addInactiveAction(b, a, d);
      return b;
    },
    existingAction: function(a, b) {
      var c = b || this._root;
      b = c.uuid;
      c = "string" === typeof a ? Ra.findByName(c, a) : a;
      a = this._actionsByClip[c ? c.uuid : a];
      return void 0 !== a ? a.actionByRoot[b] || null : null;
    },
    stopAllAction: function() {
      for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
      for (e = 0; e !== d; ++e) c[e].useCount = 0;
      return this;
    },
    update: function(a) {
      a *= this.timeScale;
      for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) b[g]._update(
        d,
        a,
        e,
        f
      );
      a = this._bindings;
      b = this._nActiveBindings;
      for (g = 0; g !== b; ++g) a[g].apply(f);
      return this;
    },
    setTime: function(a) {
      for (var b = this.time = 0; b < this._actions.length; b++) this._actions[b].time = 0;
      return this.update(a);
    },
    getRoot: function() {
      return this._root;
    },
    uncacheClip: function(a) {
      var b = this._actions;
      a = a.uuid;
      var c = this._actionsByClip, d = c[a];
      if (void 0 !== d) {
        d = d.knownActions;
        for (var e = 0, f = d.length; e !== f; ++e) {
          var g = d[e];
          this._deactivateAction(g);
          var h2 = g._cacheIndex, l = b[b.length - 1];
          g._cacheIndex = null;
          g._byClipCacheIndex = null;
          l._cacheIndex = h2;
          b[h2] = l;
          b.pop();
          this._removeInactiveBindingsForAction(g);
        }
        delete c[a];
      }
    },
    uncacheRoot: function(a) {
      a = a.uuid;
      var b = this._actionsByClip;
      for (d in b) {
        var c = b[d].actionByRoot[a];
        void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c));
      }
      var d = this._bindingsByRootAndName[a];
      if (void 0 !== d) for (var e in d) a = d[e], a.restoreOriginalState(), this._removeInactiveBinding(a);
    },
    uncacheAction: function(a, b) {
      a = this.existingAction(a, b);
      null !== a && (this._deactivateAction(a), this._removeInactiveAction(a));
    }
  });
  vf.prototype.clone = function() {
    return new vf(void 0 === this.value.clone ? this.value : this.value.clone());
  };
  Pg.prototype = Object.assign(Object.create(sb.prototype), { constructor: Pg, isInstancedInterleavedBuffer: true, copy: function(a) {
    sb.prototype.copy.call(this, a);
    this.meshPerAttribute = a.meshPerAttribute;
    return this;
  } });
  Object.assign(pi.prototype, { linePrecision: 1, set: function(a, b) {
    this.ray.set(a, b);
  }, setFromCamera: function(a, b) {
    b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(
      a.x,
      a.y,
      0.5
    ).unproject(b).sub(this.ray.origin).normalize(), this.camera = b) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld), this.camera = b) : console.error("THREE.Raycaster: Unsupported camera type.");
  }, intersectObject: function(a, b, c) {
    c = c || [];
    Qg(a, this, c, b);
    c.sort(qi);
    return c;
  }, intersectObjects: function(a, b, c) {
    c = c || [];
    if (false === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
    for (var d = 0, e = a.length; d < e; d++) Qg(a[d], this, c, b);
    c.sort(qi);
    return c;
  } });
  Object.assign(ri.prototype, { set: function(a, b, c) {
    this.radius = a;
    this.phi = b;
    this.theta = c;
    return this;
  }, clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    this.radius = a.radius;
    this.phi = a.phi;
    this.theta = a.theta;
    return this;
  }, makeSafe: function() {
    this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi));
    return this;
  }, setFromVector3: function(a) {
    return this.setFromCartesianCoords(a.x, a.y, a.z);
  }, setFromCartesianCoords: function(a, b, c) {
    this.radius = Math.sqrt(a * a + b * b + c * c);
    0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, c), this.phi = Math.acos(P.clamp(b / this.radius, -1, 1)));
    return this;
  } });
  Object.assign(si.prototype, { set: function(a, b, c) {
    this.radius = a;
    this.theta = b;
    this.y = c;
    return this;
  }, clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    this.radius = a.radius;
    this.theta = a.theta;
    this.y = a.y;
    return this;
  }, setFromVector3: function(a) {
    return this.setFromCartesianCoords(a.x, a.y, a.z);
  }, setFromCartesianCoords: function(a, b, c) {
    this.radius = Math.sqrt(a * a + c * c);
    this.theta = Math.atan2(a, c);
    this.y = b;
    return this;
  } });
  var gj = new w();
  Object.assign(Rg.prototype, { set: function(a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  }, setFromPoints: function(a) {
    this.makeEmpty();
    for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
    return this;
  }, setFromCenterAndSize: function(a, b) {
    b = gj.copy(b).multiplyScalar(0.5);
    this.min.copy(a).sub(b);
    this.max.copy(a).add(b);
    return this;
  }, clone: function() {
    return new this.constructor().copy(this);
  }, copy: function(a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  }, makeEmpty: function() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }, isEmpty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }, getCenter: function(a) {
    void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new w());
    return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(0.5);
  }, getSize: function(a) {
    void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new w());
    return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min);
  }, expandByPoint: function(a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  }, expandByVector: function(a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  }, expandByScalar: function(a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  }, containsPoint: function(a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? false : true;
  }, containsBox: function(a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y;
  }, getParameter: function(a, b) {
    void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new w());
    return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
  }, intersectsBox: function(a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? false : true;
  }, clampPoint: function(a, b) {
    void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new w());
    return b.copy(a).clamp(this.min, this.max);
  }, distanceToPoint: function(a) {
    return gj.copy(a).clamp(
      this.min,
      this.max
    ).sub(a).length();
  }, intersect: function(a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  }, union: function(a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  }, translate: function(a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  }, equals: function(a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  } });
  var hj = new n(), Wf = new n();
  Object.assign(Sg.prototype, {
    set: function(a, b) {
      this.start.copy(a);
      this.end.copy(b);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(a) {
      this.start.copy(a.start);
      this.end.copy(a.end);
      return this;
    },
    getCenter: function(a) {
      void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new n());
      return a.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(a) {
      void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"), a = new n());
      return a.subVectors(this.end, this.start);
    },
    distanceSq: function() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function() {
      return this.start.distanceTo(this.end);
    },
    at: function(a, b) {
      void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new n());
      return this.delta(b).multiplyScalar(a).add(this.start);
    },
    closestPointToPointParameter: function(a, b) {
      hj.subVectors(a, this.start);
      Wf.subVectors(this.end, this.start);
      a = Wf.dot(Wf);
      a = Wf.dot(hj) / a;
      b && (a = P.clamp(a, 0, 1));
      return a;
    },
    closestPointToPoint: function(a, b, c) {
      a = this.closestPointToPointParameter(a, b);
      void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), c = new n());
      return this.delta(c).multiplyScalar(a).add(this.start);
    },
    applyMatrix4: function(a) {
      this.start.applyMatrix4(a);
      this.end.applyMatrix4(a);
      return this;
    },
    equals: function(a) {
      return a.start.equals(this.start) && a.end.equals(this.end);
    }
  });
  ue.prototype = Object.create(D.prototype);
  ue.prototype.constructor = ue;
  ue.prototype.isImmediateRenderObject = true;
  var ij = new n();
  jd.prototype = Object.create(D.prototype);
  jd.prototype.constructor = jd;
  jd.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  };
  jd.prototype.update = function() {
    this.light.updateMatrixWorld();
    var a = this.light.distance ? this.light.distance : 1e3, b = a * Math.tan(this.light.angle);
    this.cone.scale.set(b, b, a);
    ij.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(ij);
    void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  };
  var Rb = new n(), Xf = new O(), vh = new O();
  kd.prototype = Object.create(ma.prototype);
  kd.prototype.constructor = kd;
  kd.prototype.updateMatrixWorld = function(a) {
    var b = this.bones, c = this.geometry, d = c.getAttribute("position");
    vh.getInverse(this.root.matrixWorld);
    for (var e = 0, f = 0; e < b.length; e++) {
      var g = b[e];
      g.parent && g.parent.isBone && (Xf.multiplyMatrices(vh, g.matrixWorld), Rb.setFromMatrixPosition(Xf), d.setXYZ(f, Rb.x, Rb.y, Rb.z), Xf.multiplyMatrices(vh, g.parent.matrixWorld), Rb.setFromMatrixPosition(Xf), d.setXYZ(f + 1, Rb.x, Rb.y, Rb.z), f += 2);
    }
    c.getAttribute("position").needsUpdate = true;
    D.prototype.updateMatrixWorld.call(this, a);
  };
  ld.prototype = Object.create(ca.prototype);
  ld.prototype.constructor = ld;
  ld.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
  };
  ld.prototype.update = function() {
    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  };
  var nl = new n(), jj = new B(), kj = new B();
  md.prototype = Object.create(D.prototype);
  md.prototype.constructor = md;
  md.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  md.prototype.update = function() {
    var a = this.children[0];
    if (void 0 !== this.color) this.material.color.set(this.color);
    else {
      var b = a.geometry.getAttribute("color");
      jj.copy(this.light.color);
      kj.copy(this.light.groundColor);
      for (var c = 0, d = b.count; c < d; c++) {
        var e = c < d / 2 ? jj : kj;
        b.setXYZ(c, e.r, e.g, e.b);
      }
      b.needsUpdate = true;
    }
    a.lookAt(nl.setFromMatrixPosition(this.light.matrixWorld).negate());
  };
  wf.prototype = Object.assign(Object.create(ma.prototype), { constructor: wf, copy: function(a) {
    ma.prototype.copy.call(this, a);
    this.geometry.copy(a.geometry);
    this.material.copy(a.material);
    return this;
  }, clone: function() {
    return new this.constructor().copy(this);
  } });
  xf.prototype = Object.create(ma.prototype);
  xf.prototype.constructor = xf;
  var lj = new n(), Yf = new n(), mj = new n();
  nd.prototype = Object.create(D.prototype);
  nd.prototype.constructor = nd;
  nd.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  };
  nd.prototype.update = function() {
    lj.setFromMatrixPosition(this.light.matrixWorld);
    Yf.setFromMatrixPosition(this.light.target.matrixWorld);
    mj.subVectors(Yf, lj);
    this.lightPlane.lookAt(Yf);
    void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color));
    this.targetLine.lookAt(Yf);
    this.targetLine.scale.z = mj.length();
  };
  var yf = new n(), R = new eb();
  ve.prototype = Object.create(ma.prototype);
  ve.prototype.constructor = ve;
  ve.prototype.update = function() {
    var a = this.geometry, b = this.pointMap;
    R.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    na("c", b, a, R, 0, 0, -1);
    na("t", b, a, R, 0, 0, 1);
    na(
      "n1",
      b,
      a,
      R,
      -1,
      -1,
      -1
    );
    na("n2", b, a, R, 1, -1, -1);
    na("n3", b, a, R, -1, 1, -1);
    na("n4", b, a, R, 1, 1, -1);
    na("f1", b, a, R, -1, -1, 1);
    na("f2", b, a, R, 1, -1, 1);
    na("f3", b, a, R, -1, 1, 1);
    na("f4", b, a, R, 1, 1, 1);
    na("u1", b, a, R, 0.7, 1.1, -1);
    na("u2", b, a, R, -0.7, 1.1, -1);
    na("u3", b, a, R, 0, 2, -1);
    na("cf1", b, a, R, -1, 0, 1);
    na("cf2", b, a, R, 1, 0, 1);
    na("cf3", b, a, R, 0, -1, 1);
    na("cf4", b, a, R, 0, 1, 1);
    na("cn1", b, a, R, -1, 0, -1);
    na("cn2", b, a, R, 1, 0, -1);
    na("cn3", b, a, R, 0, -1, -1);
    na("cn4", b, a, R, 0, 1, -1);
    a.getAttribute("position").needsUpdate = true;
  };
  var Zf = new Ta();
  xb.prototype = Object.create(ma.prototype);
  xb.prototype.constructor = xb;
  xb.prototype.update = function(a) {
    void 0 !== a && console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    void 0 !== this.object && Zf.setFromObject(this.object);
    if (!Zf.isEmpty()) {
      a = Zf.min;
      var b = Zf.max, c = this.geometry.attributes.position, d = c.array;
      d[0] = b.x;
      d[1] = b.y;
      d[2] = b.z;
      d[3] = a.x;
      d[4] = b.y;
      d[5] = b.z;
      d[6] = a.x;
      d[7] = a.y;
      d[8] = b.z;
      d[9] = b.x;
      d[10] = a.y;
      d[11] = b.z;
      d[12] = b.x;
      d[13] = b.y;
      d[14] = a.z;
      d[15] = a.x;
      d[16] = b.y;
      d[17] = a.z;
      d[18] = a.x;
      d[19] = a.y;
      d[20] = a.z;
      d[21] = b.x;
      d[22] = a.y;
      d[23] = a.z;
      c.needsUpdate = true;
      this.geometry.computeBoundingSphere();
    }
  };
  xb.prototype.setFromObject = function(a) {
    this.object = a;
    this.update();
    return this;
  };
  xb.prototype.copy = function(a) {
    ma.prototype.copy.call(this, a);
    this.object = a.object;
    return this;
  };
  xb.prototype.clone = function() {
    return new this.constructor().copy(this);
  };
  we.prototype = Object.create(ma.prototype);
  we.prototype.constructor = we;
  we.prototype.updateMatrixWorld = function(a) {
    var b = this.box;
    b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(0.5), D.prototype.updateMatrixWorld.call(this, a));
  };
  xe.prototype = Object.create(La.prototype);
  xe.prototype.constructor = xe;
  xe.prototype.updateMatrixWorld = function(a) {
    var b = -this.plane.constant;
    1e-8 > Math.abs(b) && (b = 1e-8);
    this.scale.set(0.5 * this.size, 0.5 * this.size, b);
    this.children[0].material.side = 0 > b ? 1 : 0;
    this.lookAt(this.plane.normal);
    D.prototype.updateMatrixWorld.call(this, a);
  };
  var nj = new n(), zf, Tg;
  yb.prototype = Object.create(D.prototype);
  yb.prototype.constructor = yb;
  yb.prototype.setDirection = function(a) {
    0.99999 < a.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > a.y ? this.quaternion.set(1, 0, 0, 0) : (nj.set(a.z, 0, -a.x).normalize(), this.quaternion.setFromAxisAngle(nj, Math.acos(a.y)));
  };
  yb.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = 0.2 * a);
    void 0 === c && (c = 0.2 * b);
    this.line.scale.set(1, Math.max(1e-4, a - b), 1);
    this.line.updateMatrix();
    this.cone.scale.set(c, b, c);
    this.cone.position.y = a;
    this.cone.updateMatrix();
  };
  yb.prototype.setColor = function(a) {
    this.line.material.color.set(a);
    this.cone.material.color.set(a);
  };
  yb.prototype.copy = function(a) {
    D.prototype.copy.call(this, a, false);
    this.line.copy(a.line);
    this.cone.copy(a.cone);
    return this;
  };
  yb.prototype.clone = function() {
    return new this.constructor().copy(this);
  };
  ye.prototype = Object.create(ma.prototype);
  ye.prototype.constructor = ye;
  var lb = Math.pow(2, 8), oj = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], yi = 5 + oj.length, mb = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 }, Xg = new hd(), Af = function(a) {
    var b = new Float32Array(a), c = new n(0, 1, 0);
    a = new vb({
      defines: { n: a },
      uniforms: {
        envMap: { value: null },
        samples: { value: 1 },
        weights: { value: b },
        latitudinal: { value: false },
        dTheta: { value: 0 },
        mipInt: { value: 0 },
        poleAxis: { value: c },
        inputEncoding: { value: mb[3e3] },
        outputEncoding: { value: mb[3e3] }
      },
      vertexShader: Zg(),
      fragmentShader: "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n" + $g() + "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n	gl_FragColor = vec4(0.0);\n	for (int i = 0; i < n; i++) {\n		if (i >= samples)\n			break;\n		for (int dir = -1; dir < 2; dir += 2) {\n			if (i == 0 && dir == 1)\n				continue;\n			vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n			if (all(equal(axis, vec3(0.0))))\n				axis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);\n			axis = normalize(axis);\n			float theta = dTheta * float(dir * i);\n			float cosTheta = cos(theta);\n			// Rodrigues' axis-angle rotation\n			vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross(axis, vOutputDirection) * sin(theta)\n					+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n			gl_FragColor.rgb +=\n					weights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);\n		}\n	}\n	gl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n		",
      blending: 0,
      depthTest: false,
      depthWrite: false
    });
    a.type = "SphericalGaussianBlur";
    return a;
  }(20), Sb = null, Tb = null, wh = function() {
    for (var a = [], b = [], c = [], d = 8, e = 0; e < yi; e++) {
      var f = Math.pow(2, d);
      b.push(f);
      var g = 1 / f;
      4 < e ? g = oj[e - 8 + 4 - 1] : 0 == e && (g = 0);
      c.push(g);
      g = 1 / (f - 1);
      f = -g / 2;
      g = 1 + g / 2;
      var h2 = [f, f, g, f, g, g, f, f, g, g, f, g];
      f = new Float32Array(108);
      g = new Float32Array(72);
      for (var l = new Float32Array(36), m = 0; 6 > m; m++) {
        var n2 = m % 3 * 2 / 3 - 1, p = 2 < m ? 0 : -1;
        f.set([n2, p, 0, n2 + 2 / 3, p, 0, n2 + 2 / 3, p + 1, 0, n2, p, 0, n2 + 2 / 3, p + 1, 0, n2, p + 1, 0], 18 * m);
        g.set(h2, 12 * m);
        l.set([
          m,
          m,
          m,
          m,
          m,
          m
        ], 6 * m);
      }
      h2 = new A();
      h2.setAttribute("position", new M(f, 3));
      h2.setAttribute("uv", new M(g, 2));
      h2.setAttribute("faceIndex", new M(l, 1));
      a.push(h2);
      4 < d && d--;
    }
    return { _lodPlanes: a, _sizeLods: b, _sigmas: c };
  }(), ze = wh._lodPlanes, Ci = wh._sizeLods, Cf = wh._sigmas, Bf = null, Y = null, Wg = null, Ac = (1 + Math.sqrt(5)) / 2, Bd = 1 / Ac, Ai = [new n(1, 1, 1), new n(-1, 1, 1), new n(1, 1, -1), new n(-1, 1, -1), new n(0, Ac, Bd), new n(0, Ac, -Bd), new n(Bd, 0, Ac), new n(-Bd, 0, Ac), new n(Ac, Bd, 0), new n(-Ac, Bd, 0)];
  Ug.prototype = {
    constructor: Ug,
    fromScene: function(a, b, c, d) {
      void 0 === b && (b = 0);
      void 0 === c && (c = 0.1);
      void 0 === d && (d = 100);
      Wg = Y.getRenderTarget();
      var e = ui();
      c = new da(90, 1, c, d);
      d = [1, 1, 1, 1, -1, 1];
      var f = [1, 1, -1, -1, -1, 1], g = Y.outputEncoding, h2 = Y.toneMapping, l = Y.toneMappingExposure, m = Y.getClearColor(), n2 = Y.getClearAlpha();
      Y.toneMapping = 1;
      Y.toneMappingExposure = 1;
      Y.outputEncoding = 3e3;
      a.scale.z *= -1;
      var p = a.background;
      if (p && p.isColor) {
        p.convertSRGBToLinear();
        var q = Math.min(Math.max(Math.ceil(Math.log2(Math.max(p.r, p.g, p.b))), -128), 127);
        p = p.multiplyScalar(Math.pow(2, -q));
        Y.setClearColor(p, (q + 128) / 255);
        a.background = null;
      }
      for (p = 0; 6 > p; p++) q = p % 3, 0 == q ? (c.up.set(0, d[p], 0), c.lookAt(f[p], 0, 0)) : 1 == q ? (c.up.set(0, 0, d[p]), c.lookAt(0, f[p], 0)) : (c.up.set(0, d[p], 0), c.lookAt(0, 0, f[p])), Yg(e, q * lb, 2 < p ? lb : 0, lb, lb), Y.setRenderTarget(e), Y.render(a, c);
      Y.toneMapping = h2;
      Y.toneMappingExposure = l;
      Y.outputEncoding = g;
      Y.setClearColor(m, n2);
      a.scale.z *= -1;
      0 < b && zi(e, 0, 0, b);
      xi(e);
      wi(e);
      return e;
    },
    fromEquirectangular: function(a) {
      a.magFilter = 1003;
      a.minFilter = 1003;
      a.generateMipmaps = false;
      return this.fromCubemap(a);
    },
    fromCubemap: function(a) {
      Wg = Y.getRenderTarget();
      var b = ui(a), c = new pb();
      a.isCubeTexture ? null == Tb && (Tb = Ei()) : null == Sb && (Sb = Di());
      var d = a.isCubeTexture ? Tb : Sb;
      c.add(new ca(ze[0], d));
      d = d.uniforms;
      d.envMap.value = a;
      a.isCubeTexture || d.texelSize.value.set(1 / a.image.width, 1 / a.image.height);
      d.inputEncoding.value = mb[a.encoding];
      d.outputEncoding.value = mb[a.encoding];
      Yg(b, 0, 0, 3 * lb, 2 * lb);
      Y.setRenderTarget(b);
      Y.render(c, Xg);
      xi(b);
      wi(b);
      return b;
    },
    compileCubemapShader: function() {
      null == Tb && (Tb = Ei(), Vg(Tb));
    },
    compileEquirectangularShader: function() {
      null == Sb && (Sb = Di(), Vg(Sb));
    },
    dispose: function() {
      Af.dispose();
      null != Tb && Tb.dispose();
      null != Sb && Sb.dispose();
      for (var a = 0; a < ze.length; a++) ze[a].dispose();
    }
  };
  I.create = function(a, b) {
    console.log("THREE.Curve.create() has been deprecated");
    a.prototype = Object.create(I.prototype);
    a.prototype.constructor = a;
    a.prototype.getPoint = b;
    return a;
  };
  Object.assign(wb.prototype, { createPointsGeometry: function(a) {
    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    a = this.getPoints(a);
    return this.createGeometry(a);
  }, createSpacedPointsGeometry: function(a) {
    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    a = this.getSpacedPoints(a);
    return this.createGeometry(a);
  }, createGeometry: function(a) {
    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
    for (var b = new L(), c = 0, d = a.length; c < d; c++) {
      var e = a[c];
      b.vertices.push(new n(
        e.x,
        e.y,
        e.z || 0
      ));
    }
    return b;
  } });
  Object.assign(ab.prototype, { fromPoints: function(a) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
    return this.setFromPoints(a);
  } });
  Fi.prototype = Object.create(Aa.prototype);
  Gi.prototype = Object.create(Aa.prototype);
  ah.prototype = Object.create(Aa.prototype);
  Object.assign(ah.prototype, {
    initFromArray: function() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
      console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
    }
  });
  wf.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  kd.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  Object.assign(V.prototype, { extractUrlBase: function(a) {
    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
    return th.extractUrlBase(a);
  } });
  V.Handlers = { add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  }, get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  } };
  Object.assign(sf.prototype, { setTexturePath: function(a) {
    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
    return this.setResourcePath(a);
  } });
  Object.assign(Rg.prototype, { center: function(a) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  }, empty: function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }, isIntersectionBox: function(a) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, size: function(a) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(a);
  } });
  Object.assign(Ta.prototype, { center: function(a) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  }, empty: function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  }, isIntersectionBox: function(a) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, isIntersectionSphere: function(a) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(a);
  }, size: function(a) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(a);
  } });
  Hc.prototype.setFromMatrix = function(a) {
    console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
    return this.setFromProjectionMatrix(a);
  };
  Sg.prototype.center = function(a) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(a);
  };
  Object.assign(P, { random16: function() {
    console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
    return Math.random();
  }, nearestPowerOfTwo: function(a) {
    console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
    return P.floorPowerOfTwo(a);
  }, nextPowerOfTwo: function(a) {
    console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
    return P.ceilPowerOfTwo(a);
  } });
  Object.assign(za.prototype, {
    flattenToArrayOffset: function(a, b) {
      console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(a, b);
    },
    multiplyVector3: function(a) {
      console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
      return a.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBufferAttribute: function(a) {
      console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
      return a.applyMatrix3(this);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
  });
  Object.assign(O.prototype, {
    extractPosition: function(a) {
      console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
      return this.copyPosition(a);
    },
    flattenToArrayOffset: function(a, b) {
      console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(a, b);
    },
    getPosition: function() {
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return new n().setFromMatrixColumn(this, 3);
    },
    setRotationFromQuaternion: function(a) {
      console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
      return this.makeRotationFromQuaternion(a);
    },
    multiplyToArray: function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(a) {
      console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return a.applyMatrix4(this);
    },
    multiplyVector4: function(a) {
      console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return a.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(a) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
      a.transformDirection(this);
    },
    crossVector: function(a) {
      console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return a.applyMatrix4(this);
    },
    translate: function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBufferAttribute: function(a) {
      console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
      return a.applyMatrix4(this);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(a, b, c, d, e, f) {
      console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
      return this.makePerspective(a, b, d, c, e, f);
    }
  });
  Ua.prototype.isIntersectionLine = function(a) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(a);
  };
  Da.prototype.multiplyVector3 = function(a) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return a.applyQuaternion(this);
  };
  Object.assign(Wb.prototype, { isIntersectionBox: function(a) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(a);
  }, isIntersectionPlane: function(a) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(a);
  }, isIntersectionSphere: function(a) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(a);
  } });
  Object.assign(oa.prototype, { area: function() {
    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
    return this.getArea();
  }, barycoordFromPoint: function(a, b) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return this.getBarycoord(a, b);
  }, midpoint: function(a) {
    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
    return this.getMidpoint(a);
  }, normal: function(a) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return this.getNormal(a);
  }, plane: function(a) {
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
    return this.getPlane(a);
  } });
  Object.assign(
    oa,
    { barycoordFromPoint: function(a, b, c, d, e) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return oa.getBarycoord(a, b, c, d, e);
    }, normal: function(a, b, c, d) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return oa.getNormal(a, b, c, d);
    } }
  );
  Object.assign(Lb.prototype, { extractAllPoints: function(a) {
    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
    return this.extractPoints(a);
  }, extrude: function(a) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new gc(this, a);
  }, makeGeometry: function(a) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new ic(this, a);
  } });
  Object.assign(w.prototype, {
    fromAttribute: function(a, b, c) {
      console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(a, b, c);
    },
    distanceToManhattan: function(a) {
      console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(a);
    },
    lengthManhattan: function() {
      console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    }
  });
  Object.assign(n.prototype, {
    setEulerFromRotationMatrix: function() {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function() {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(a) {
      console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
      return this.setFromMatrixPosition(a);
    },
    getScaleFromMatrix: function(a) {
      console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
      return this.setFromMatrixScale(a);
    },
    getColumnFromMatrix: function(a, b) {
      console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
      return this.setFromMatrixColumn(b, a);
    },
    applyProjection: function(a) {
      console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
      return this.applyMatrix4(a);
    },
    fromAttribute: function(a, b, c) {
      console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(a, b, c);
    },
    distanceToManhattan: function(a) {
      console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(a);
    },
    lengthManhattan: function() {
      console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    }
  });
  Object.assign(
    ia.prototype,
    { fromAttribute: function(a, b, c) {
      console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(a, b, c);
    }, lengthManhattan: function() {
      console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    } }
  );
  Object.assign(L.prototype, {
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
    },
    applyMatrix: function(a) {
      console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(a);
    }
  });
  Object.assign(D.prototype, { getChildByName: function(a) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(a);
  }, renderDepth: function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  }, translate: function(a, b) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(b, a);
  }, getWorldRotation: function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  }, applyMatrix: function(a) {
    console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(a);
  } });
  Object.defineProperties(D.prototype, { eulerOrder: { get: function() {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
    return this.rotation.order;
  }, set: function(a) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
    this.rotation.order = a;
  } }, useQuaternion: { get: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  } } });
  Object.assign(ca.prototype, { setDrawMode: function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  } });
  Object.defineProperties(ca.prototype, { drawMode: { get: function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
    return 0;
  }, set: function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  } } });
  Object.defineProperties(Td.prototype, { objects: { get: function() {
    console.warn("THREE.LOD: .objects has been renamed to .levels.");
    return this.levels;
  } } });
  Object.defineProperty(Ue.prototype, "useVertexTexture", { get: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  }, set: function() {
    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
  } });
  Ud.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  Object.defineProperty(I.prototype, "__arcLengthDivisions", {
    get: function() {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
      return this.arcLengthDivisions;
    },
    set: function(a) {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
      this.arcLengthDivisions = a;
    }
  });
  da.prototype.setLens = function(a, b) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    void 0 !== b && (this.filmGauge = b);
    this.setFocalLength(a);
  };
  Object.defineProperties(ba.prototype, { onlyShadow: { set: function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  } }, shadowCameraFov: { set: function(a) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
    this.shadow.camera.fov = a;
  } }, shadowCameraLeft: { set: function(a) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
    this.shadow.camera.left = a;
  } }, shadowCameraRight: { set: function(a) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
    this.shadow.camera.right = a;
  } }, shadowCameraTop: { set: function(a) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
    this.shadow.camera.top = a;
  } }, shadowCameraBottom: { set: function(a) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
    this.shadow.camera.bottom = a;
  } }, shadowCameraNear: { set: function(a) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
    this.shadow.camera.near = a;
  } }, shadowCameraFar: { set: function(a) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
    this.shadow.camera.far = a;
  } }, shadowCameraVisible: { set: function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  } }, shadowBias: { set: function(a) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
    this.shadow.bias = a;
  } }, shadowDarkness: { set: function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  } }, shadowMapWidth: { set: function(a) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
    this.shadow.mapSize.width = a;
  } }, shadowMapHeight: { set: function(a) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
    this.shadow.mapSize.height = a;
  } } });
  Object.defineProperties(M.prototype, { length: { get: function() {
    console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
    return this.array.length;
  } }, dynamic: { get: function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
    return 35048 === this.usage;
  }, set: function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
    this.setUsage(35048);
  } } });
  Object.assign(M.prototype, {
    setDynamic: function(a) {
      console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(true === a ? 35048 : 35044);
      return this;
    },
    copyIndicesArray: function() {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    },
    setArray: function() {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    }
  });
  Object.assign(A.prototype, { addIndex: function(a) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(a);
  }, addAttribute: function(a, b, c) {
    console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
    return b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? "index" === a ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this) : this.setAttribute(a, b) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(a, new M(b, c)));
  }, addDrawCall: function(a, b, c) {
    void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(a, b);
  }, clearDrawCalls: function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  }, computeTangents: function() {
    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
  }, computeOffsets: function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  }, removeAttribute: function(a) {
    console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
    return this.deleteAttribute(a);
  }, applyMatrix: function(a) {
    console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(a);
  } });
  Object.defineProperties(A.prototype, { drawcalls: { get: function() {
    console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
    return this.groups;
  } }, offsets: { get: function() {
    console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
    return this.groups;
  } } });
  Object.defineProperties(sb.prototype, { dynamic: { get: function() {
    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
    return 35048 === this.usage;
  }, set: function(a) {
    console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
    this.setUsage(a);
  } } });
  Object.assign(sb.prototype, { setDynamic: function(a) {
    console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(true === a ? 35048 : 35044);
    return this;
  }, setArray: function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  } });
  Object.assign(gb.prototype, {
    getArrays: function() {
      console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
    },
    addShapeList: function() {
      console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
    },
    addShape: function() {
      console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
    }
  });
  Object.defineProperties(vf.prototype, { dynamic: { set: function() {
    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
  } }, onUpdate: { value: function() {
    console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
    return this;
  } } });
  Object.defineProperties(K.prototype, { wrapAround: { get: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  } }, overdraw: { get: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  } }, wrapRGB: { get: function() {
    console.warn("THREE.Material: .wrapRGB has been removed.");
    return new B();
  } }, shading: { get: function() {
    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
  }, set: function(a) {
    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
    this.flatShading = 1 === a;
  } }, stencilMask: { get: function() {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
    return this.stencilFuncMask;
  }, set: function(a) {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
    this.stencilFuncMask = a;
  } } });
  Object.defineProperties(Kb.prototype, { metal: { get: function() {
    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
    return false;
  }, set: function() {
    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
  } } });
  Object.defineProperties(qa.prototype, { derivatives: {
    get: function() {
      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      return this.extensions.derivatives;
    },
    set: function(a) {
      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
      this.extensions.derivatives = a;
    }
  } });
  Object.assign(qg.prototype, {
    clearTarget: function(a, b, c, d) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
      this.setRenderTarget(a);
      this.clear(b, c, d);
    },
    animate: function(a) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
      this.setAnimationLoop(a);
    },
    getCurrentRenderTarget: function() {
      console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
      return this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
      console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
      return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
      console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
      return this.capabilities.precision;
    },
    resetGLState: function() {
      console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
      return this.state.reset();
    },
    supportsFloatTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
      return this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
      return this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
      console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
      return this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
      return this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
      return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
      console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
      return this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
      return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
      console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
      return this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(a) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
      this.setScissorTest(a);
    },
    initMaterial: function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    },
    allocTextureUnit: function() {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    },
    setTexture: function() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    },
    setTexture2D: function() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    },
    setTextureCube: function() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    },
    getActiveMipMapLevel: function() {
      console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
      return this.getActiveMipmapLevel();
    }
  });
  Object.defineProperties(qg.prototype, {
    shadowMapEnabled: { get: function() {
      return this.shadowMap.enabled;
    }, set: function(a) {
      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
      this.shadowMap.enabled = a;
    } },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(a) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
        this.shadowMap.type = a;
      }
    },
    shadowMapCullFace: { get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    }, set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
    } },
    context: { get: function() {
      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
      return this.getContext();
    } },
    vr: { get: function() {
      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
      return this.xr;
    } },
    gammaInput: { get: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      return false;
    }, set: function() {
      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
    } },
    gammaOutput: { get: function() {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      return false;
    }, set: function(a) {
      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
      this.outputEncoding = true === a ? 3001 : 3e3;
    } }
  });
  Object.defineProperties(Wh.prototype, { cullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  } }, renderReverseSided: {
    get: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    },
    set: function() {
      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
    }
  }, renderSingleSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  } } });
  Object.defineProperties(wa.prototype, { wrapS: { get: function() {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
    return this.texture.wrapS;
  }, set: function(a) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
    this.texture.wrapS = a;
  } }, wrapT: { get: function() {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
    return this.texture.wrapT;
  }, set: function(a) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
    this.texture.wrapT = a;
  } }, magFilter: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      return this.texture.magFilter;
    },
    set: function(a) {
      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
      this.texture.magFilter = a;
    }
  }, minFilter: { get: function() {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
    return this.texture.minFilter;
  }, set: function(a) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
    this.texture.minFilter = a;
  } }, anisotropy: {
    get: function() {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      return this.texture.anisotropy;
    },
    set: function(a) {
      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
      this.texture.anisotropy = a;
    }
  }, offset: { get: function() {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
    return this.texture.offset;
  }, set: function(a) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
    this.texture.offset = a;
  } }, repeat: { get: function() {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
    return this.texture.repeat;
  }, set: function(a) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
    this.texture.repeat = a;
  } }, format: { get: function() {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
    return this.texture.format;
  }, set: function(a) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
    this.texture.format = a;
  } }, type: { get: function() {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
    return this.texture.type;
  }, set: function(a) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
    this.texture.type = a;
  } }, generateMipmaps: { get: function() {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
    return this.texture.generateMipmaps;
  }, set: function(a) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
    this.texture.generateMipmaps = a;
  } } });
  Object.defineProperties(id.prototype, { load: { value: function(a) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var b = this;
    new tf().load(a, function(a2) {
      b.setBuffer(a2);
    });
    return this;
  } }, startTime: { set: function() {
    console.warn("THREE.Audio: .startTime is now .play( delay ).");
  } } });
  Mg.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  Gc.prototype.updateCubeMap = function(a, b) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(a, b);
  };
  Mb.crossOrigin = void 0;
  Mb.loadTexture = function(a, b, c, d) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var e = new ef();
    e.setCrossOrigin(this.crossOrigin);
    a = e.load(a, c, void 0, d);
    b && (a.mapping = b);
    return a;
  };
  Mb.loadTextureCube = function(a, b, c, d) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var e = new df();
    e.setCrossOrigin(this.crossOrigin);
    a = e.load(a, c, void 0, d);
    b && (a.mapping = b);
    return a;
  };
  Mb.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  Mb.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  "undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "113" } }));
  h.ACESFilmicToneMapping = 5;
  h.AddEquation = 100;
  h.AddOperation = 2;
  h.AdditiveBlending = 2;
  h.AlphaFormat = 1021;
  h.AlwaysDepth = 1;
  h.AlwaysStencilFunc = 519;
  h.AmbientLight = mf;
  h.AmbientLightProbe = Hg;
  h.AnimationClip = Ra;
  h.AnimationLoader = yg;
  h.AnimationMixer = Og;
  h.AnimationObjectGroup = ni;
  h.AnimationUtils = ea;
  h.ArcCurve = gd;
  h.ArrayCamera = Qe;
  h.ArrowHelper = yb;
  h.Audio = id;
  h.AudioAnalyser = Mg;
  h.AudioContext = Kg;
  h.AudioListener = Jg;
  h.AudioLoader = tf;
  h.AxesHelper = ye;
  h.AxisHelper = function(a) {
    console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
    return new ye(a);
  };
  h.BackSide = 1;
  h.BasicDepthPacking = 3200;
  h.BasicShadowMap = 0;
  h.BinaryTextureLoader = function(a) {
    console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
    return new cf(a);
  };
  h.Bone = rg;
  h.BooleanKeyframeTrack = Ze;
  h.BoundingBoxHelper = function(a, b) {
    console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
    return new xb(a, b);
  };
  h.Box2 = Rg;
  h.Box3 = Ta;
  h.Box3Helper = we;
  h.BoxBufferGeometry = Kd;
  h.BoxGeometry = nh;
  h.BoxHelper = xb;
  h.BufferAttribute = M;
  h.BufferGeometry = A;
  h.BufferGeometryLoader = rf;
  h.ByteType = 1010;
  h.Cache = vc;
  h.Camera = eb;
  h.CameraHelper = ve;
  h.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been removed");
  };
  h.CanvasTexture = Vd;
  h.CatmullRomCurve3 = Aa;
  h.CineonToneMapping = 4;
  h.CircleBufferGeometry = cd;
  h.CircleGeometry = pe;
  h.ClampToEdgeWrapping = 1001;
  h.Clock = Ig;
  h.ClosedSplineCurve3 = Fi;
  h.Color = B;
  h.ColorKeyframeTrack = $e;
  h.CompressedTexture = Qc;
  h.CompressedTextureLoader = zg;
  h.ConeBufferGeometry = oe;
  h.ConeGeometry = ne;
  h.CubeCamera = Gc;
  h.CubeGeometry = nh;
  h.CubeReflectionMapping = 301;
  h.CubeRefractionMapping = 302;
  h.CubeTexture = rb;
  h.CubeTextureLoader = df;
  h.CubeUVReflectionMapping = 306;
  h.CubeUVRefractionMapping = 307;
  h.CubicBezierCurve = Xa;
  h.CubicBezierCurve3 = ib;
  h.CubicInterpolant = Xe;
  h.CullFaceBack = 1;
  h.CullFaceFront = 2;
  h.CullFaceFrontBack = 3;
  h.CullFaceNone = 0;
  h.Curve = I;
  h.CurvePath = wb;
  h.CustomBlending = 5;
  h.CylinderBufferGeometry = ub;
  h.CylinderGeometry = kc;
  h.Cylindrical = si;
  h.DataTexture = bc;
  h.DataTexture2DArray = Ic;
  h.DataTexture3D = Jc;
  h.DataTextureLoader = cf;
  h.DecrementStencilOp = 7683;
  h.DecrementWrapStencilOp = 34056;
  h.DefaultLoadingManager = ji;
  h.DepthFormat = 1026;
  h.DepthStencilFormat = 1027;
  h.DepthTexture = Wd;
  h.DirectionalLight = lf;
  h.DirectionalLightHelper = nd;
  h.DirectionalLightShadow = kf;
  h.DiscreteInterpolant = Ye;
  h.DodecahedronBufferGeometry = Vc;
  h.DodecahedronGeometry = be;
  h.DoubleSide = 2;
  h.DstAlphaFactor = 206;
  h.DstColorFactor = 208;
  h.DynamicBufferAttribute = function(a, b) {
    console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
    return new M(a, b).setUsage(35048);
  };
  h.DynamicCopyUsage = 35050;
  h.DynamicDrawUsage = 35048;
  h.DynamicReadUsage = 35049;
  h.EdgesGeometry = bd;
  h.EdgesHelper = function(a, b) {
    console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
    return new ma(new bd(a.geometry), new ka({ color: void 0 !== b ? b : 16777215 }));
  };
  h.EllipseCurve = Na;
  h.EqualDepth = 4;
  h.EqualStencilFunc = 514;
  h.EquirectangularReflectionMapping = 303;
  h.EquirectangularRefractionMapping = 304;
  h.Euler = Ub;
  h.EventDispatcher = Fa;
  h.ExtrudeBufferGeometry = gb;
  h.ExtrudeGeometry = gc;
  h.Face3 = Bc;
  h.Face4 = function(a, b, c, d, e, f, g) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new Bc(a, b, c, e, f, g);
  };
  h.FaceColors = 1;
  h.FileLoader = Sa;
  h.FlatShading = 1;
  h.Float32Attribute = function(a, b) {
    console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
    return new E(a, b);
  };
  h.Float32BufferAttribute = E;
  h.Float64Attribute = function(a, b) {
    console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
    return new Hd(a, b);
  };
  h.Float64BufferAttribute = Hd;
  h.FloatType = 1015;
  h.Fog = Se;
  h.FogExp2 = Re;
  h.Font = Eg;
  h.FontLoader = Fg;
  h.FrontFaceDirectionCCW = 1;
  h.FrontFaceDirectionCW = 0;
  h.FrontSide = 0;
  h.Frustum = Hc;
  h.GammaEncoding = 3007;
  h.Geometry = L;
  h.GeometryUtils = { merge: function(a, b, c) {
    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
    if (b.isMesh) {
      b.matrixAutoUpdate && b.updateMatrix();
      var d = b.matrix;
      b = b.geometry;
    }
    a.merge(b, d, c);
  }, center: function(a) {
    console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
    return a.center();
  } };
  h.GreaterDepth = 6;
  h.GreaterEqualDepth = 5;
  h.GreaterEqualStencilFunc = 518;
  h.GreaterStencilFunc = 516;
  h.GridHelper = wf;
  h.Group = Mc;
  h.HalfFloatType = 1016;
  h.HemisphereLight = ff;
  h.HemisphereLightHelper = md;
  h.HemisphereLightProbe = Gg;
  h.IcosahedronBufferGeometry = Uc;
  h.IcosahedronGeometry = ae;
  h.ImageBitmapLoader = Cg;
  h.ImageLoader = fd;
  h.ImageUtils = Mb;
  h.ImmediateRenderObject = ue;
  h.IncrementStencilOp = 7682;
  h.IncrementWrapStencilOp = 34055;
  h.InstancedBufferAttribute = qf;
  h.InstancedBufferGeometry = pf;
  h.InstancedInterleavedBuffer = Pg;
  h.InstancedMesh = Ve;
  h.Int16Attribute = function(a, b) {
    console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
    return new Fd(a, b);
  };
  h.Int16BufferAttribute = Fd;
  h.Int32Attribute = function(a, b) {
    console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
    return new Gd(a, b);
  };
  h.Int32BufferAttribute = Gd;
  h.Int8Attribute = function(a, b) {
    console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
    return new Cd(a, b);
  };
  h.Int8BufferAttribute = Cd;
  h.IntType = 1013;
  h.InterleavedBuffer = sb;
  h.InterleavedBufferAttribute = Qd;
  h.Interpolant = Ma;
  h.InterpolateDiscrete = 2300;
  h.InterpolateLinear = 2301;
  h.InterpolateSmooth = 2302;
  h.InvertStencilOp = 5386;
  h.JSONLoader = function() {
    console.error("THREE.JSONLoader has been removed.");
  };
  h.KeepStencilOp = 7680;
  h.KeyframeTrack = ua;
  h.LOD = Td;
  h.LatheBufferGeometry = ad;
  h.LatheGeometry = me;
  h.Layers = ag;
  h.LensFlare = function() {
    console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js");
  };
  h.LessDepth = 2;
  h.LessEqualDepth = 3;
  h.LessEqualStencilFunc = 515;
  h.LessStencilFunc = 513;
  h.Light = ba;
  h.LightProbe = bb;
  h.LightShadow = kb;
  h.Line = La;
  h.Line3 = Sg;
  h.LineBasicMaterial = ka;
  h.LineCurve = Ea;
  h.LineCurve3 = Ya;
  h.LineDashedMaterial = rc;
  h.LineLoop = We;
  h.LinePieces = 1;
  h.LineSegments = ma;
  h.LineStrip = 0;
  h.LinearEncoding = 3e3;
  h.LinearFilter = 1006;
  h.LinearInterpolant = qe;
  h.LinearMipMapLinearFilter = 1008;
  h.LinearMipMapNearestFilter = 1007;
  h.LinearMipmapLinearFilter = 1008;
  h.LinearMipmapNearestFilter = 1007;
  h.LinearToneMapping = 1;
  h.Loader = V;
  h.LoaderUtils = th;
  h.LoadingManager = xg;
  h.LogLuvEncoding = 3003;
  h.LoopOnce = 2200;
  h.LoopPingPong = 2202;
  h.LoopRepeat = 2201;
  h.LuminanceAlphaFormat = 1025;
  h.LuminanceFormat = 1024;
  h.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  h.Material = K;
  h.MaterialLoader = of;
  h.Math = P;
  h.MathUtils = P;
  h.Matrix3 = za;
  h.Matrix4 = O;
  h.MaxEquation = 104;
  h.Mesh = ca;
  h.MeshBasicMaterial = Pa;
  h.MeshDepthMaterial = Gb;
  h.MeshDistanceMaterial = Hb;
  h.MeshFaceMaterial = function(a) {
    console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
    return a;
  };
  h.MeshLambertMaterial = pc;
  h.MeshMatcapMaterial = qc;
  h.MeshNormalMaterial = oc;
  h.MeshPhongMaterial = Kb;
  h.MeshPhysicalMaterial = mc;
  h.MeshStandardMaterial = hb;
  h.MeshToonMaterial = nc;
  h.MinEquation = 103;
  h.MirroredRepeatWrapping = 1002;
  h.MixOperation = 1;
  h.MultiMaterial = function(a) {
    void 0 === a && (a = []);
    console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
    a.isMultiMaterial = true;
    a.materials = a;
    a.clone = function() {
      return a.slice();
    };
    return a;
  };
  h.MultiplyBlending = 4;
  h.MultiplyOperation = 0;
  h.NearestFilter = 1003;
  h.NearestMipMapLinearFilter = 1005;
  h.NearestMipMapNearestFilter = 1004;
  h.NearestMipmapLinearFilter = 1005;
  h.NearestMipmapNearestFilter = 1004;
  h.NeverDepth = 0;
  h.NeverStencilFunc = 512;
  h.NoBlending = 0;
  h.NoColors = 0;
  h.NoToneMapping = 0;
  h.NormalBlending = 1;
  h.NotEqualDepth = 7;
  h.NotEqualStencilFunc = 517;
  h.NumberKeyframeTrack = dd;
  h.Object3D = D;
  h.ObjectLoader = sf;
  h.ObjectSpaceNormalMap = 1;
  h.OctahedronBufferGeometry = dc;
  h.OctahedronGeometry = $d;
  h.OneFactor = 201;
  h.OneMinusDstAlphaFactor = 207;
  h.OneMinusDstColorFactor = 209;
  h.OneMinusSrcAlphaFactor = 205;
  h.OneMinusSrcColorFactor = 203;
  h.OrthographicCamera = hd;
  h.PCFShadowMap = 1;
  h.PCFSoftShadowMap = 2;
  h.PMREMGenerator = Ug;
  h.ParametricBufferGeometry = Sc;
  h.ParametricGeometry = Xd;
  h.Particle = function(a) {
    console.warn("THREE.Particle has been renamed to THREE.Sprite.");
    return new Rd(a);
  };
  h.ParticleBasicMaterial = function(a) {
    console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
    return new Wa(a);
  };
  h.ParticleSystem = function(a, b) {
    console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
    return new Pc(a, b);
  };
  h.ParticleSystemMaterial = function(a) {
    console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
    return new Wa(a);
  };
  h.Path = ab;
  h.PerspectiveCamera = da;
  h.Plane = Ua;
  h.PlaneBufferGeometry = cc;
  h.PlaneGeometry = Jd;
  h.PlaneHelper = xe;
  h.PointCloud = function(a, b) {
    console.warn("THREE.PointCloud has been renamed to THREE.Points.");
    return new Pc(a, b);
  };
  h.PointCloudMaterial = function(a) {
    console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
    return new Wa(a);
  };
  h.PointLight = jf;
  h.PointLightHelper = ld;
  h.Points = Pc;
  h.PointsMaterial = Wa;
  h.PolarGridHelper = xf;
  h.PolyhedronBufferGeometry = Ja;
  h.PolyhedronGeometry = Yd;
  h.PositionalAudio = Lg;
  h.PropertyBinding = Ba;
  h.PropertyMixer = Ng;
  h.QuadraticBezierCurve = Za;
  h.QuadraticBezierCurve3 = jb;
  h.Quaternion = Da;
  h.QuaternionKeyframeTrack = re;
  h.QuaternionLinearInterpolant = af;
  h.REVISION = "113";
  h.RGBADepthPacking = 3201;
  h.RGBAFormat = 1023;
  h.RGBAIntegerFormat = 1033;
  h.RGBA_ASTC_10x10_Format = 37819;
  h.RGBA_ASTC_10x5_Format = 37816;
  h.RGBA_ASTC_10x6_Format = 37817;
  h.RGBA_ASTC_10x8_Format = 37818;
  h.RGBA_ASTC_12x10_Format = 37820;
  h.RGBA_ASTC_12x12_Format = 37821;
  h.RGBA_ASTC_4x4_Format = 37808;
  h.RGBA_ASTC_5x4_Format = 37809;
  h.RGBA_ASTC_5x5_Format = 37810;
  h.RGBA_ASTC_6x5_Format = 37811;
  h.RGBA_ASTC_6x6_Format = 37812;
  h.RGBA_ASTC_8x5_Format = 37813;
  h.RGBA_ASTC_8x6_Format = 37814;
  h.RGBA_ASTC_8x8_Format = 37815;
  h.RGBA_PVRTC_2BPPV1_Format = 35843;
  h.RGBA_PVRTC_4BPPV1_Format = 35842;
  h.RGBA_S3TC_DXT1_Format = 33777;
  h.RGBA_S3TC_DXT3_Format = 33778;
  h.RGBA_S3TC_DXT5_Format = 33779;
  h.RGBDEncoding = 3006;
  h.RGBEEncoding = 3002;
  h.RGBEFormat = 1023;
  h.RGBFormat = 1022;
  h.RGBIntegerFormat = 1032;
  h.RGBM16Encoding = 3005;
  h.RGBM7Encoding = 3004;
  h.RGB_ETC1_Format = 36196;
  h.RGB_PVRTC_2BPPV1_Format = 35841;
  h.RGB_PVRTC_4BPPV1_Format = 35840;
  h.RGB_S3TC_DXT1_Format = 33776;
  h.RGFormat = 1030;
  h.RGIntegerFormat = 1031;
  h.RawShaderMaterial = vb;
  h.Ray = Wb;
  h.Raycaster = pi;
  h.RectAreaLight = nf;
  h.RedFormat = 1028;
  h.RedIntegerFormat = 1029;
  h.ReinhardToneMapping = 2;
  h.RepeatWrapping = 1e3;
  h.ReplaceStencilOp = 7681;
  h.ReverseSubtractEquation = 102;
  h.RingBufferGeometry = $c;
  h.RingGeometry = le;
  h.Scene = pb;
  h.SceneUtils = { createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  }, detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  }, attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js");
  } };
  h.ShaderChunk = N;
  h.ShaderLib = fb;
  h.ShaderMaterial = qa;
  h.ShadowMaterial = lc;
  h.Shape = Lb;
  h.ShapeBufferGeometry = jc;
  h.ShapeGeometry = ic;
  h.ShapePath = Dg;
  h.ShapeUtils = tb;
  h.ShortType = 1011;
  h.Skeleton = Ue;
  h.SkeletonHelper = kd;
  h.SkinnedMesh = Ud;
  h.SmoothShading = 2;
  h.Sphere = qb;
  h.SphereBufferGeometry = hc;
  h.SphereGeometry = ke;
  h.Spherical = ri;
  h.SphericalHarmonics3 = uf;
  h.SphericalReflectionMapping = 305;
  h.Spline = ah;
  h.SplineCurve = $a;
  h.SplineCurve3 = Gi;
  h.SpotLight = hf;
  h.SpotLightHelper = jd;
  h.SpotLightShadow = gf;
  h.Sprite = Rd;
  h.SpriteMaterial = Jb;
  h.SrcAlphaFactor = 204;
  h.SrcAlphaSaturateFactor = 210;
  h.SrcColorFactor = 202;
  h.StaticCopyUsage = 35046;
  h.StaticDrawUsage = 35044;
  h.StaticReadUsage = 35045;
  h.StereoCamera = li;
  h.StreamCopyUsage = 35042;
  h.StreamDrawUsage = 35040;
  h.StreamReadUsage = 35041;
  h.StringKeyframeTrack = bf;
  h.SubtractEquation = 101;
  h.SubtractiveBlending = 3;
  h.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  h.TangentSpaceNormalMap = 0;
  h.TetrahedronBufferGeometry = Tc;
  h.TetrahedronGeometry = Zd;
  h.TextBufferGeometry = Zc;
  h.TextGeometry = je;
  h.Texture = Z;
  h.TextureLoader = ef;
  h.TorusBufferGeometry = Xc;
  h.TorusGeometry = ee;
  h.TorusKnotBufferGeometry = Wc;
  h.TorusKnotGeometry = de;
  h.Triangle = oa;
  h.TriangleFanDrawMode = 2;
  h.TriangleStripDrawMode = 1;
  h.TrianglesDrawMode = 0;
  h.TubeBufferGeometry = ec;
  h.TubeGeometry = ce;
  h.UVMapping = 300;
  h.Uint16Attribute = function(a, b) {
    console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
    return new Xb(a, b);
  };
  h.Uint16BufferAttribute = Xb;
  h.Uint32Attribute = function(a, b) {
    console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
    return new Yb(a, b);
  };
  h.Uint32BufferAttribute = Yb;
  h.Uint8Attribute = function(a, b) {
    console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
    return new Dd(a, b);
  };
  h.Uint8BufferAttribute = Dd;
  h.Uint8ClampedAttribute = function(a, b) {
    console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
    return new Ed(a, b);
  };
  h.Uint8ClampedBufferAttribute = Ed;
  h.Uncharted2ToneMapping = 3;
  h.Uniform = vf;
  h.UniformsLib = F;
  h.UniformsUtils = Th;
  h.UnsignedByteType = 1009;
  h.UnsignedInt248Type = 1020;
  h.UnsignedIntType = 1014;
  h.UnsignedShort4444Type = 1017;
  h.UnsignedShort5551Type = 1018;
  h.UnsignedShort565Type = 1019;
  h.UnsignedShortType = 1012;
  h.VSMShadowMap = 3;
  h.Vector2 = w;
  h.Vector3 = n;
  h.Vector4 = ia;
  h.VectorKeyframeTrack = ed;
  h.Vertex = function(a, b, c) {
    console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
    return new n(a, b, c);
  };
  h.VertexColors = 2;
  h.VideoTexture = ug;
  h.WebGLCubeRenderTarget = Eb;
  h.WebGLMultisampleRenderTarget = $f;
  h.WebGLRenderTarget = wa;
  h.WebGLRenderTargetCube = function(a, b, c) {
    console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
    return new Eb(a, c);
  };
  h.WebGLRenderer = qg;
  h.WebGLUtils = Yh;
  h.WireframeGeometry = Rc;
  h.WireframeHelper = function(a, b) {
    console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
    return new ma(new Rc(a.geometry), new ka({ color: void 0 !== b ? b : 16777215 }));
  };
  h.WrapAroundEnding = 2402;
  h.XHRLoader = function(a) {
    console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
    return new Sa(a);
  };
  h.ZeroCurvatureEnding = 2400;
  h.ZeroFactor = 200;
  h.ZeroSlopeEnding = 2401;
  h.ZeroStencilOp = 0;
  h.sRGBEncoding = 3001;
  Object.defineProperty(h, "__esModule", { value: true });
});
var speRuntimeFactory = function(exports, THREE) {
  var extendStatics = function(e, t) {
    return (extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e2, t2) {
      e2.__proto__ = t2;
    } || function(e2, t2) {
      for (var i in t2)
        Object.prototype.hasOwnProperty.call(t2, i) && (e2[i] = t2[i]);
    })(e, t);
  };
  function __extends(e, t) {
    if ("function" != typeof t && null !== t)
      throw new TypeError(
        "Class extends value " + String(t) + " is not a constructor or null"
      );
    function i() {
      this.constructor = e;
    }
    extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (i.prototype = t.prototype, new i());
  }
  var __assign = function() {
    return (__assign = Object.assign || function(e) {
      for (var t, i = 1, r = arguments.length; i < r; i++)
        for (var n in t = arguments[i])
          Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
      return e;
    }).apply(this, arguments);
  }, GLTF_GENERATOR_FORMAT, GLTF_COMPONENT_TYPE, GLTF_RENDER_MODE, GLTF_TEXTURE_MAG_FILTER, GLTF_TEXTURE_MIN_FILTER, GLTF_TEXTURE_WRAP_MODE, GLTF_BUFFER_TARGET, GLTF_ACCESSOR_TYPE, GLTF_LIGHTING_TECHNIQUE, GLTF_MATERIAL_ALPHA_MODE, GLTF_MATERIAL_SIDE, GLTF_MATERIAL_SHADING_MODE, RUNTIME_VIEWMODE, RUNTIME_QUALITY, OBJECT_TYPE, CAMERA_TYPE, LIGHT_TYPE, LAYER_TYPE, UNIFORM_TYPE;
  function __awaiter(e, t, i, r) {
    return new (i || (i = Promise))(function(n, o) {
      function a(e2) {
        try {
          l(r.next(e2));
        } catch (e3) {
          o(e3);
        }
      }
      function s(e2) {
        try {
          l(r.throw(e2));
        } catch (e3) {
          o(e3);
        }
      }
      function l(e2) {
        var t2;
        e2.done ? n(e2.value) : (t2 = e2.value, t2 instanceof i ? t2 : new i(function(e3) {
          e3(t2);
        })).then(a, s);
      }
      l((r = r.apply(e, t || [])).next());
    });
  }
  function __generator(e, t) {
    var i, r, n, o, a = {
      label: 0,
      sent: function() {
        if (1 & n[0]) throw n[1];
        return n[1];
      },
      trys: [],
      ops: []
    };
    return o = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
      return this;
    }), o;
    function s(o2) {
      return function(s2) {
        return function(o3) {
          if (i) throw new TypeError("Generator is already executing.");
          for (; a; )
            try {
              if (i = 1, r && (n = 2 & o3[0] ? r.return : o3[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, o3[1])).done)
                return n;
              switch (r = 0, n && (o3 = [2 & o3[0], n.value]), o3[0]) {
                case 0:
                case 1:
                  n = o3;
                  break;
                case 4:
                  return a.label++, { value: o3[1], done: false };
                case 5:
                  a.label++, r = o3[1], o3 = [0];
                  continue;
                case 7:
                  ;
                  o3 = a.ops.pop(), a.trys.pop();
                  continue;
                default:
                  if (!(n = a.trys, (n = n.length > 0 && n[n.length - 1]) || 6 !== o3[0] && 2 !== o3[0])) {
                    a = 0;
                    continue;
                  }
                  if (3 === o3[0] && (!n || o3[1] > n[0] && o3[1] < n[3])) {
                    a.label = o3[1];
                    break;
                  }
                  if (6 === o3[0] && a.label < n[1]) {
                    ;
                    a.label = n[1], n = o3;
                    break;
                  }
                  if (n && a.label < n[2]) {
                    ;
                    a.label = n[2], a.ops.push(o3);
                    break;
                  }
                  n[2] && a.ops.pop(), a.trys.pop();
                  continue;
              }
              o3 = t.call(e, a);
            } catch (e2) {
              o3 = [6, e2], r = 0;
            } finally {
              i = n = 0;
            }
          if (5 & o3[0]) throw o3[1];
          return { value: o3[0] ? o3[1] : void 0, done: true };
        }([o2, s2]);
      };
    }
  }
  function __values(e) {
    var t = "function" == typeof Symbol && Symbol.iterator, i = t && e[t], r = 0;
    if (i) return i.call(e);
    if (e && "number" == typeof e.length)
      return {
        next: function() {
          return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
        }
      };
    throw new TypeError(
      t ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  }
  function __read(e, t) {
    var i = "function" == typeof Symbol && e[Symbol.iterator];
    if (!i) return e;
    var r, n, o = i.call(e), a = [];
    try {
      for (; (void 0 === t || t-- > 0) && !(r = o.next()).done; )
        a.push(r.value);
    } catch (e2) {
      n = { error: e2 };
    } finally {
      try {
        r && !r.done && (i = o.return) && i.call(o);
      } finally {
        if (n) throw n.error;
      }
    }
    return a;
  }
  function __spread() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e = e.concat(__read(arguments[t]));
    return e;
  }
  function GetAccessorComponentSize(e) {
    switch (e) {
      case GLTF_COMPONENT_TYPE.UNSIGNED_BYTE:
        return 1;
      case GLTF_COMPONENT_TYPE.UNSIGNED_SHORT:
        return 2;
      case GLTF_COMPONENT_TYPE.UNSIGNED_INT:
      case GLTF_COMPONENT_TYPE.FLOAT:
        return 4;
      default:
        return console.error(
          "GetAccessorComponentSize >>> invalid component-type (" + e + ")"
        ), 1;
    }
  }
  function GetAccessorItemSize(e) {
    switch (e) {
      case GLTF_ACCESSOR_TYPE.SCALAR:
        return 1;
      case GLTF_ACCESSOR_TYPE.VEC2:
        return 2;
      case GLTF_ACCESSOR_TYPE.VEC3:
        return 3;
      case GLTF_ACCESSOR_TYPE.VEC4:
      case GLTF_ACCESSOR_TYPE.MAT2:
        return 4;
      case GLTF_ACCESSOR_TYPE.MAT3:
        return 9;
      case GLTF_ACCESSOR_TYPE.MAT4:
        return 16;
      default:
        return console.error(
          "GetAccessorItemSize >>> invalid item-type (" + e + ")"
        ), 1;
    }
  }
  function CreateFromJson(e) {
    return e;
  }
  !function(e) {
    e[e.FORMAT_GLTF_2_0_COMPAT = 0] = "FORMAT_GLTF_2_0_COMPAT", e[e.FORMAT_GLTF_SPLINE_EXT = 1] = "FORMAT_GLTF_SPLINE_EXT";
  }(GLTF_GENERATOR_FORMAT || (GLTF_GENERATOR_FORMAT = {})), function(e) {
    e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT", e[e.FLOAT = 5126] = "FLOAT";
  }(GLTF_COMPONENT_TYPE || (GLTF_COMPONENT_TYPE = {})), function(e) {
    e[e.POINTS = 0] = "POINTS", e[e.LINES = 1] = "LINES", e[e.LINE_LOOP = 2] = "LINE_LOOP", e[e.LINE_STRIP = 3] = "LINE_STRIP", e[e.TRIANGLES = 4] = "TRIANGLES", e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
  }(GLTF_RENDER_MODE || (GLTF_RENDER_MODE = {})), function(e) {
    e[e.NEAREST = 9728] = "NEAREST", e[e.LINEAR = 9729] = "LINEAR";
  }(GLTF_TEXTURE_MAG_FILTER || (GLTF_TEXTURE_MAG_FILTER = {})), function(e) {
    e[e.NEAREST = 9728] = "NEAREST", e[e.LINEAR = 9729] = "LINEAR", e[e.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", e[e.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", e[e.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", e[e.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR";
  }(GLTF_TEXTURE_MIN_FILTER || (GLTF_TEXTURE_MIN_FILTER = {})), function(e) {
    e[e.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", e[e.REPEAT = 10497] = "REPEAT";
  }(GLTF_TEXTURE_WRAP_MODE || (GLTF_TEXTURE_WRAP_MODE = {})), function(e) {
    e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
  }(GLTF_BUFFER_TARGET || (GLTF_BUFFER_TARGET = {})), function(e) {
    e.SCALAR = "SCALAR", e.VEC2 = "VEC2", e.VEC3 = "VEC3", e.VEC4 = "VEC4", e.MAT2 = "MAT2", e.MAT3 = "MAT3", e.MAT4 = "MAT4";
  }(GLTF_ACCESSOR_TYPE || (GLTF_ACCESSOR_TYPE = {})), function(e) {
    e.CONSTANT = "CONSTANT", e.BLINN = "BLINN", e.LAMBERT = "LAMBERT", e.PHYSICAL = "PHYSICAL", e.TOON = "TOON";
  }(GLTF_LIGHTING_TECHNIQUE || (GLTF_LIGHTING_TECHNIQUE = {})), function(e) {
    e.OPAQUE = "OPAQUE", e.MASK = "MASK", e.BLEND = "BLEND";
  }(GLTF_MATERIAL_ALPHA_MODE || (GLTF_MATERIAL_ALPHA_MODE = {})), function(e) {
    e[e.FRONT_SIDE = 0] = "FRONT_SIDE", e[e.BACK_SIDE = 1] = "BACK_SIDE", e[e.DOUBLE_SIDE = 2] = "DOUBLE_SIDE";
  }(GLTF_MATERIAL_SIDE || (GLTF_MATERIAL_SIDE = {})), function(e) {
    e[e.FLAT_SHADING = 1] = "FLAT_SHADING", e[e.SMOOTH_SHADING = 2] = "SMOOTH_SHADING";
  }(GLTF_MATERIAL_SHADING_MODE || (GLTF_MATERIAL_SHADING_MODE = {})), function(e) {
    e[e.FULLSCREEN = 1] = "FULLSCREEN", e[e.CUSTOM_SIZE = 2] = "CUSTOM_SIZE";
  }(RUNTIME_VIEWMODE || (RUNTIME_VIEWMODE = {})), function(e) {
    e.HIGH = "high", e.MIDDLE = "middle", e.LOW = "low", e.DEFAULT = "default";
  }(RUNTIME_QUALITY || (RUNTIME_QUALITY = {})), function(e) {
    e.EMPTY_OBJECT = "emtpy_object", e.MESH_3D = "mesh_3d", e.MESH_2D = "mesh_2d", e.TEXTFRAME = "textframe", e.VECTOR_OBJECT = "vector_object", e.LIGHT = "light", e.CAMERA = "camera", e.SCENE = "scene";
  }(OBJECT_TYPE || (OBJECT_TYPE = {})), function(e) {
    e.PERSPECTIVE = "perspective", e.ORTHOGRAPHIC = "orthographic";
  }(CAMERA_TYPE || (CAMERA_TYPE = {})), function(e) {
    e.SPOT = "spot", e.POINT = "point", e.DIRECTIONAL = "directional", e.HEMISPHERIC = "hemispheric";
  }(LIGHT_TYPE || (LIGHT_TYPE = {})), function(e) {
    e.LIGHTING = "light", e.COLOR = "color", e.GRADIENT = "gradient", e.NORMAL = "normal", e.DEPTH = "depth", e.TEXTURE = "texture", e.NOISE = "noise", e.FRESNEL = "fresnel", e.POINTS = "points", e.LINES = "lines";
  }(LAYER_TYPE || (LAYER_TYPE = {})), function(e) {
    e[e.BOOLEAN = 0] = "BOOLEAN", e[e.INTEGER = 1] = "INTEGER", e[e.FLOAT = 2] = "FLOAT", e[e.VECTOR2 = 3] = "VECTOR2", e[e.VECTOR3 = 4] = "VECTOR3", e[e.VECTOR4 = 5] = "VECTOR4", e[e.COLOR = 6] = "COLOR", e[e.ARRAY_INTEGER = 7] = "ARRAY_INTEGER", e[e.ARRAY_FLOAT = 8] = "ARRAY_FLOAT", e[e.ARRAY_VECTOR2 = 9] = "ARRAY_VECTOR2", e[e.ARRAY_VECTOR3 = 10] = "ARRAY_VECTOR3", e[e.ARRAY_VECTOR4 = 11] = "ARRAY_VECTOR4", e[e.ARRAY_COLOR = 12] = "ARRAY_COLOR", e[e.MATRIX_3 = 13] = "MATRIX_3", e[e.MATRIX_4 = 14] = "MATRIX_4", e[e.TEXTURE = 15] = "TEXTURE";
  }(UNIFORM_TYPE || (UNIFORM_TYPE = {}));
  var Raycaster = function(e) {
    function t() {
      return null !== e && e.apply(this, arguments) || this;
    }
    return __extends(t, e), t.prototype.setFromCamera = function(e2, t2) {
      "OrthographicCamera" === t2.cameraType ? (this.ray.origin.set(e2.x, e2.y, -1).unproject(t2), this.ray.direction.set(0, 0, -1).transformDirection(t2.matrixWorld), this.camera = t2) : "PerspectiveCamera" === t2.cameraType ? (this.ray.origin.setFromMatrixPosition(t2.matrixWorld), this.ray.direction.set(e2.x, e2.y, 0.5).unproject(t2).sub(this.ray.origin).normalize(), this.camera = t2) : console.error("Raycaster: Unsupported camera type.");
    }, t.prototype.createRaycastLineHelper = function() {
      var e2 = new THREE.LineBasicMaterial({
        color: 16711680,
        linewidth: 10
      }), t2 = new THREE.Geometry(), i = new THREE.Vector3(
        this.ray.origin.x,
        this.ray.origin.y,
        this.ray.origin.z
      ), r = new THREE.Vector3(
        this.ray.direction.x,
        this.ray.direction.y,
        this.ray.direction.z
      ), n = new THREE.Vector3().lerpVectors(i, r, 0.5);
      return r.multiplyScalar(0), t2.vertices.push(i), t2.vertices.push(n), t2.vertices.push(r), new THREE.Line(t2, e2);
    }, t;
  }(THREE.Raycaster), CylinderGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o, a, s = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          radialSegments: 64,
          heightSegments: 1,
          openEnded: false,
          thetaStart: 0,
          thetaLength: 360,
          cornerRadius: 0,
          cornerSegments: 8,
          hollow: 0
        },
        e2.parameters
      ), l = s.width / 2, c = null !== (r = s.radiusTop) && void 0 !== r ? r : l, u = null !== (n = s.radiusBottom) && void 0 !== n ? n : l;
      return c === u ? (c = l, u = l) : c > u ? u = u * l / (c = l) : (c = c * l / u, u = l), {
        parameters: Object.assign(s, {
          width: Math.abs(s.width),
          height: Math.abs(
            null !== (o = s.height) && void 0 !== o ? o : s.width
          ),
          depth: Math.abs(
            null !== (a = s.depth) && void 0 !== a ? a : s.width
          ),
          radiusTop: c,
          radiusBottom: u
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.depth, n = t.height, o = t.radialSegments, a = t.heightSegments, s = t.openEnded, l = t.thetaStart, c = t.thetaLength, u = t.radiusTop, h = t.radiusBottom, d = t.cornerRadius, f = t.cornerSegments, p = t.hollow, v = new RoundedCylinderBufferGeometry(
        u,
        h,
        n,
        o,
        a,
        s,
        l,
        c * Math.PI / 180,
        d,
        d,
        f,
        p
      );
      return v.scale(1, 1, r / i), Object.assign(v, {
        userData: __assign(__assign({}, e2), { type: "CylinderGeometry" })
      });
    }, e;
  }();
  function two2three(e, t, i) {
    i.x = e.x * t.x, i.y = e.y, i.z = e.x * t.y;
  }
  function flip(e) {
    return new THREE.Vector2(e.y, -e.x);
  }
  var RoundedCylinderBufferGeometry = function(e) {
    function t(t2, i, r, n, o, a, s, l, c, u, h, d, f) {
      void 0 === f && (f = false);
      var p = e.call(this) || this;
      p.type = "RoundedCylinderBufferGeometry", t2 = void 0 !== t2 ? t2 : 1, i = void 0 !== i ? i : 1, r = r || 1, n = Math.floor(n) || 8, o = Math.floor(o) || 1, a = void 0 !== a && a, s = void 0 !== s ? s : 0, l = void 0 !== l ? l : 2 * Math.PI, a && (c = 0, u = 0);
      var v = [], m = [], g = [], E = [], y = 0, A = r / 2, T = new THREE.Vector3(), x = new THREE.Vector3();
      f && 0 == t2 && (t2 = c), f && 0 == i && (i = u);
      var _ = new THREE.Vector2(t2, A), w = new THREE.Vector2(i, -A), S = null, b = null, R = null, C = null, O = _.clone().sub(w), D = 0, M = 0, L = 0;
      d > 0 && (D = Math.min(t2, i) * (1 - d), M = t2 - D, L = i - D);
      var I = _.clone();
      I.x -= D;
      var P = Math.PI - O.angle(), B = O.angle(), H = Math.tan(B / 2), N = Math.tan(P / 2), F = H + N, G = d ? F : N, U = d ? F : H;
      if (c = Math.min(c, (t2 - M) / G, O.length() / F), u = Math.min(u, (i - L) / U, O.length() / F), c > 0) {
        var z = c / H;
        S = _.clone().sub(new THREE.Vector2(z, c)), d && ((R = S.clone()).x -= D - F * c), _.sub(O.clone().setLength(z));
      }
      if (u > 0) {
        z = u / N;
        b = w.clone().sub(new THREE.Vector2(z, -u)), w.add(O.clone().setLength(z)), d && ((C = b.clone()).x -= D - F * u, I.sub(O.clone().setLength(z)));
      }
      for (var V = (O = _.clone().sub(w)).length() < 0.5, k = [], j = 0; j <= n; j++) {
        var Y = [], Q = j / n, $ = Q * l + s, W = new THREE.Vector2(Math.sin($), Math.cos($));
        if (C && b ? (oe(Y, Q, W, P, u, C, -1, true), oe(Y, Q, W, B, u, b, -1, false)) : b ? (ae(Y, W, b.x, 0, -1), oe(Y, Q, W, B, u, b, -1, false)) : a || ae(Y, W, i, L, -1), two2three(flip(O).normalize(), W, T), !V)
          for (var X = 0; X <= o; X++) {
            var J = X / o;
            two2three(O.clone().multiplyScalar(J).add(w), W, x), m.push(x.x, x.y, x.z), g.push(T.x, T.y, T.z), E.push(Q, 0.5 + x.y / r), Y.push(y++);
          }
        if (R && S ? (oe(Y, Q, W, P, c, S, 1, false), oe(Y, Q, W, B, c, R, 1, true)) : S ? (oe(Y, Q, W, P, c, S, 1, false), ae(Y, W, S.x, 0, 1)) : a || ae(Y, W, t2, M, 1), d && !V) {
          two2three(flip(O).multiplyScalar(-1).normalize(), W, T);
          for (X = 0; X <= o; X++) {
            J = X / o;
            two2three(O.clone().multiplyScalar(-J).add(I), W, x), m.push(x.x, x.y, x.z), g.push(T.x, T.y, T.z), E.push(Q, 0.5 + x.y / r), Y.push(y++);
          }
        }
        d && !a && Y.push(Y[0]), k.push(Y);
      }
      for (var K = 0; K < k.length - 1; K++)
        for (var q = 0; q < k[0].length - 1; q++)
          if (!a || !d || q != o) {
            var Z = k[K][q], ee = k[K + 1][q], te = k[K + 1][q + 1], ie = k[K][q + 1], re = m[3 * te + 0], ne = m[3 * te + 2];
            v.push(Z, ee, ie), 0 == re && 0 == ne || v.push(ee, te, ie);
          }
      function oe(e2, t3, i2, n2, o2, a2, s2, l2) {
        for (var c2 = 0; c2 < h + 1; c2++) {
          var u2 = c2 / h, d2 = s2 < 0 ? u2 : 1 - u2;
          l2 && (d2 -= 1), d2 *= n2;
          var f2 = new THREE.Vector2(Math.sin(d2), Math.cos(d2) * s2);
          two2three(f2.clone().multiplyScalar(o2).add(a2), i2, x), m.push(x.x, x.y, x.z), two2three(f2, i2, T), g.push(T.x, T.y, T.z), E.push(t3, 0.5 + x.y / r), e2.push(y++);
        }
      }
      function ae(e2, t3, i2, r2, n2) {
        var o2, a2, s2 = new THREE.Vector3(), l2 = new THREE.Vector2(), c2 = [i2, r2];
        n2 < 0 && c2.reverse();
        try {
          for (var u2 = __values(c2), h2 = u2.next(); !h2.done; h2 = u2.next()) {
            var d2 = h2.value;
            l2.set(d2, A * n2), two2three(l2, t3, s2), m.push(s2.x, s2.y, s2.z), g.push(0, n2, 0), E.push(0.5, 0.5), e2.push(y++);
          }
        } catch (e3) {
          o2 = { error: e3 };
        } finally {
          try {
            h2 && !h2.done && (a2 = u2.return) && a2.call(u2);
          } finally {
            if (o2) throw o2.error;
          }
        }
      }
      function se(e2, r2, n2) {
        var o2, a2, s2 = new THREE.Vector2(Math.sin(n2), Math.cos(n2)), l2 = new THREE.Vector2(-Math.cos(n2), Math.sin(n2)), c2 = new THREE.Vector3(), u2 = e2 < 0 ? function(e3, t3, i2) {
          return v.push(e3, t3, i2);
        } : function(e3, t3, i2) {
          return v.push(e3, i2, t3);
        };
        two2three(new THREE.Vector2((t2 + i + M + L) / 4, 0), s2, c2), m.push(c2.x, c2.y, c2.z), g.push(l2.x, 0, l2.y), E.push(0.5, 0.5);
        var h2 = y++;
        try {
          for (var d2 = __values(r2), f2 = d2.next(); !f2.done; f2 = d2.next()) {
            var p2 = f2.value, A2 = m.slice(3 * p2, 3 * p2 + 3);
            m.push.apply(m, __spread(A2)), g.push(l2.x, 0, l2.y);
            var T2 = E.slice(2 * p2, 2 * p2 + 2);
            E.push.apply(E, __spread(T2)), y++;
          }
        } catch (e3) {
          o2 = { error: e3 };
        } finally {
          try {
            f2 && !f2.done && (a2 = d2.return) && a2.call(d2);
          } finally {
            if (o2) throw o2.error;
          }
        }
        for (var x2 = h2 + 1; x2 < y - 1; x2++) u2(h2, x2, x2 + 1);
        u2(h2, y - 1, h2 + 1);
      }
      return l < 2 * Math.PI && (se(-1, k[0], s), se(1, k[k.length - 1], s + l)), p.setIndex(v), p.setAttribute("position", new THREE.Float32BufferAttribute(m, 3)), p.setAttribute("normal", new THREE.Float32BufferAttribute(g, 3)), p.setAttribute("uv", new THREE.Float32BufferAttribute(E, 2)), p;
    }
    return __extends(t, e), t;
  }(THREE.BufferGeometry), ConeGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          radialSegments: 32,
          heightSegments: 32,
          openEnded: false,
          thetaStart: 0,
          thetaLength: 360,
          cornerRadiusTop: 0,
          cornerRadiusBottom: 0,
          cornerSegments: 8
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (r = o.height) && void 0 !== r ? r : o.width
          ),
          depth: Math.abs(
            null !== (n = o.depth) && void 0 !== n ? n : o.width
          )
        })
      };
    }, e.build = function(e2) {
      var t, i = e2.parameters, r = i.width, n = i.depth, o = i.height, a = i.radialSegments, s = i.heightSegments, l = i.openEnded, c = i.thetaStart, u = i.thetaLength, h = i.cornerRadiusTop, d = i.cornerRadiusBottom, f = i.cornerSegments;
      return (t = h > 0 || d > 0 || u < 360 ? new RoundedCylinderBufferGeometry(
        0,
        r / 2,
        o,
        a,
        s,
        l,
        c,
        u * Math.PI / 180,
        h,
        d,
        f,
        0,
        true
      ) : new THREE.ConeBufferGeometry(r / 2, o, a, s, l)).scale(
        1,
        1,
        n / r
      ), Object.assign(t, {
        userData: __assign(__assign({}, e2), { type: "ConeGeometry" })
      });
    }, e;
  }(), CubeGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          widthSegments: 1,
          heightSegments: 1,
          depthSegments: 1,
          cornerRadius: 0,
          cornerSegments: 8
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (r = o.height) && void 0 !== r ? r : o.width
          ),
          depth: Math.abs(
            null !== (n = o.depth) && void 0 !== n ? n : o.width
          )
        })
      };
    }, e.build = function(e2) {
      var t, i = e2.parameters, r = i.width, n = i.height, o = i.depth, a = i.widthSegments, s = i.heightSegments, l = i.depthSegments, c = i.cornerRadius, u = i.cornerSegments;
      return t = 0 == c ? new THREE.BoxBufferGeometry(r, n, o, a, s, l) : new RoundedBoxBufferGeometry(r, n, o, a, s, l, c, u), Object.assign(t, {
        userData: __assign(__assign({}, e2), { type: "CubeGeometry" })
      });
    }, e;
  }(), pi2 = Math.PI / 2, RoundedBoxBufferGeometry = function(e) {
    function t(t2, i, r, n, o, a, s, l) {
      void 0 === t2 && (t2 = 1), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === n && (n = 1), void 0 === o && (o = 1), void 0 === a && (a = 1), void 0 === s && (s = 0), void 0 === l && (l = 4);
      var c = e.call(this) || this;
      c.type = "BoxBufferGeometry";
      var u = c;
      n = Math.floor(n), o = Math.floor(o), a = Math.floor(a), l = Math.floor(l), s = Math.min(s, t2 / 2, i / 2, r / 2);
      var h = [], d = [], f = [], p = [], v = 0, m = 0;
      function g(e2, t3, i2, r2, n2, o2, a2, l2, c2, g2, E2) {
        for (var y2 = (o2 - 2 * s) / c2, A = (a2 - 2 * s) / g2, T = o2 / 2 - s, x = a2 / 2 - s, _ = l2 / 2, w = c2 + 1, S = g2 + 1, b = 0, R = 0, C = new THREE.Vector3(), O = 0; O < S; O++)
          for (var D = O * A - x, M = 0; M < w; M++) {
            var L = M * y2 - T;
            C[e2] = L * r2, C[t3] = D * n2, C[i2] = _, d.push(C.x, C.y, C.z), C[e2] = 0, C[t3] = 0, C[i2] = l2 > 0 ? 1 : -1, f.push(C.x, C.y, C.z), p.push(M / c2), p.push(1 - O / g2), b += 1;
          }
        for (O = 0; O < g2; O++)
          for (M = 0; M < c2; M++) {
            var I = v + M + w * O, P = v + M + w * (O + 1), B = v + (M + 1) + w * (O + 1), H = v + (M + 1) + w * O;
            h.push(I, P, H), h.push(P, B, H), R += 6;
          }
        u.addGroup(m, R, E2), m += R, v += b;
      }
      function E(e2, t3, i2, r2, n2, o2, a2, c2, g2, E2, y2) {
        for (var A = (a2 - 2 * s) / E2, T = a2 / 2 - s, x = c2 / 2 - s, _ = g2 / 2, w = E2 + 1, S = 0, b = 0, R = new THREE.Vector3(), C = new THREE.Vector3(), O = 0; O < l + 1; O++) {
          var D = O / l * pi2, M = Math.sin(D) * s, L = (1 - Math.cos(D)) * s, I = Math.sin(D), P = Math.cos(D);
          R[t3] = (x + M) * n2, R[i2] = (_ - L) * o2, C[e2] = 0, C[t3] = I * Math.sign(R[t3]), C[i2] = P * Math.sign(R[i2]);
          for (var B = 0; B < w; B++) {
            var H = B * A - T;
            R[e2] = H * r2, d.push(R.x, R.y, R.z), f.push(C.x, C.y, C.z), p.push(B / E2), p.push(0), S += 1;
          }
        }
        for (O = 0; O < l; O++)
          for (B = 0; B < E2; B++) {
            D = v + B + w * O;
            var N = v + B + w * (O + 1), F = v + (B + 1) + w * (O + 1), G = v + (B + 1) + w * O;
            h.push(D, N, G), h.push(N, F, G), b += 6;
          }
        u.addGroup(m, b, y2), m += b, v += S;
      }
      function y(e2, n2, o2) {
        var a2 = new THREE.Vector3(), c2 = new THREE.Vector3(t2 / 2, i / 2, r / 2);
        c2.subScalar(s);
        for (var u2 = [], m2 = e2 * n2 * o2 > 0 ? function(e3, t3, i2) {
          return h.push(e3, t3, i2);
        } : function(e3, t3, i2) {
          return h.push(e3, i2, t3);
        }, g2 = 0; g2 <= l; g2++) {
          for (var E2 = [], y2 = pi2 * (1 - g2 / l), A = Math.cos(y2), T = Math.sin(y2), x = 0, _ = 0; _ <= g2; _++) {
            var w = Math.cos(x), S = Math.sin(x);
            a2.x = A * w, a2.y = T, a2.z = A * S;
            var b = c2.clone().addScaledVector(a2, s);
            d.push(e2 * b.x, n2 * b.y, o2 * b.z), f.push(e2 * a2.x, n2 * a2.y, o2 * a2.z), p.push(0, 0), E2.push(v++), x += pi2 / g2;
          }
          u2.push(E2);
        }
        for (var R = u2.length - 1, C = 0; C < R; C++) {
          var O = u2[C], D = u2[C + 1], M = O.length - 1;
          m2(O[0], D[1], D[0]);
          for (var L = 1; L <= M; L++)
            m2(O[L - 1], O[L], D[L]), m2(O[L], D[L + 1], D[L]);
        }
      }
      return g("z", "y", "x", -1, -1, r, i, t2, a, o, 0), g("z", "y", "x", 1, -1, r, i, -t2, a, o, 1), g("x", "z", "y", 1, 1, t2, r, i, n, a, 2), g("x", "z", "y", 1, -1, t2, r, -i, n, a, 3), g("x", "y", "z", 1, -1, t2, i, r, n, o, 4), g("x", "y", "z", -1, -1, t2, i, -r, n, o, 5), s > 0 && (E("z", "y", "x", -1, -1, 1, r, i, t2, a, 0), E("z", "y", "x", 1, -1, -1, r, i, t2, a, 1), E("z", "y", "x", -1, 1, -1, r, i, t2, a, 1), E("z", "y", "x", 1, 1, 1, r, i, t2, a, 0), E("x", "y", "z", -1, -1, -1, t2, i, r, n, 0), E("x", "y", "z", 1, -1, 1, t2, i, r, n, 1), E("x", "y", "z", -1, 1, 1, t2, i, r, n, 0), E("x", "y", "z", 1, 1, -1, t2, i, r, n, 1), E("y", "x", "z", -1, -1, 1, i, t2, r, o, 0), E("y", "x", "z", 1, -1, -1, i, t2, r, o, 1), E("y", "x", "z", 1, 1, 1, i, t2, r, o, 1), E("y", "x", "z", -1, 1, -1, i, t2, r, o, 0), y(1, 1, 1), y(-1, 1, 1), y(1, -1, 1), y(-1, -1, 1), y(1, 1, -1), y(-1, 1, -1), y(1, -1, -1), y(-1, -1, -1)), c.setIndex(h), c.setAttribute("position", new THREE.Float32BufferAttribute(d, 3)), c.setAttribute("normal", new THREE.Float32BufferAttribute(f, 3)), c.setAttribute("uv", new THREE.Float32BufferAttribute(p, 2)), c;
    }
    return __extends(t, e), t;
  }(THREE.BufferGeometry), DodecahedronGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : { width: 100, detail: 0 },
        e2.parameters
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (r = o.height) && void 0 !== r ? r : o.width
          ),
          depth: Math.abs(
            null !== (n = o.depth) && void 0 !== n ? n : o.width
          )
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.height, n = t.depth, o = t.detail, a = new THREE.DodecahedronBufferGeometry(0.5 * i, o);
      return a.scale(1, r / i, n / i), Object.assign(a, {
        userData: __assign(__assign({}, e2), {
          type: "DodecahedronGeometry"
        })
      });
    }, e;
  }(), asVec = function(e, t) {
    var i = t.x - e.x, r = t.y - e.y, n = Math.sqrt(i * i + r * r), o = i / n, a = r / n;
    return { x: i, y: r, len: n, nx: o, ny: a, ang: Math.atan2(a, o) };
  }, roundShapePolygon = function(e, t, i) {
    var r, n, o, a, s, l, c, u, h, d, f, p, v, m, g = t.length;
    for (a = t[g - 2], e.curves = [], r = 1; r < g - 1; r++) {
      s = t[r % g], l = t[(r + 1) % g];
      var E = asVec(s, a), y = asVec(s, l);
      c = E.nx * y.ny - E.ny * y.nx, u = E.nx * y.nx - E.ny * -y.ny, f = Math.asin(c), h = 1, d = false, u < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, h = -1, d = true) : f > 0 && (h = -1, d = true), p = f / 2, (m = Math.abs(Math.cos(p) * i / Math.sin(p))) > Math.min(E.len / 2, y.len / 2) ? (m = Math.min(E.len / 2, y.len / 2), v = Math.abs(m * Math.sin(p) / Math.cos(p))) : v = i, n = s.x + y.nx * m, o = s.y + y.ny * m, n += -y.ny * v * h, o += y.nx * v * h, e.absarc(
        n,
        o,
        v,
        E.ang + Math.PI / 2 * h,
        y.ang - Math.PI / 2 * h,
        d
      ), a = s, s = l;
    }
    e.closePath();
  }, resizeGeometry = function(e, t) {
    var i = t.width, r = t.height, n = t.depth;
    i = Math.abs(i), r = Math.abs(r), n = Math.abs(n);
    var o, a, s, l = e.userData.parameters;
    0 === i ? (i = l.width, o = 1) : o = i / l.width, 0 === r ? (r = l.height, a = 1) : a = r / l.height, 0 === n ? (n = l.depth, s = 1) : s = n / l.depth, e.scale(o, a, s), l.width = i, l.height = r, l.depth = n;
  }, fixUvs = function(e, t, i) {
    var r = e.getAttribute("uv");
    if (r)
      for (var n = 0; n < r.count; n++) {
        var o = r.getX(n), a = r.getY(n);
        r.setXY(n, (o + t / 2) / t, 1 - (a - i / 2) / i * -1);
      }
  }, EllipseGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          depth: 0,
          spikes: 128,
          angle: 360,
          innerRadius: 0
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(n, {
          width: Math.abs(n.width),
          height: Math.abs(
            null !== (r = n.height) && void 0 !== r ? r : n.width
          )
        })
      };
    }, e.build = function(e2) {
      var t, i = e2.parameters, r = i.width, n = i.height, o = i.spikes, a = i.angle, s = i.innerRadius;
      if (s > 0) {
        var l = 0.5 * r, c = s * l / 100;
        (t = new THREE.RingBufferGeometry(
          c,
          l,
          o,
          1,
          Math.PI / 2,
          a * Math.PI / 180
        )).scale(1, Math.abs(n) / Math.abs(r), 1);
      } else {
        for (var u = 0.5 * r, h = 0.5 * n, d = a * Math.PI / 180 * -1 / o, f = new THREE.Shape(), p = 0; p <= o; p++) {
          var v = d * p, m = 0 + Math.sin(v) * u, g = 0 + Math.cos(v) * h;
          f.lineTo(m, g);
        }
        360 === a && (f.curves = f.curves.slice(1)), t = new THREE.ShapeBufferGeometry(f), fixUvs(t, r, n);
      }
      return Object.assign(t, {
        userData: __assign(__assign({}, e2), { type: "EllipseGeometry" })
      });
    }, e;
  }(), HelixGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          revolutions: 2,
          segments: 40,
          pathRadius: 10,
          pathType: 0,
          pathSegments: 30,
          cornerRadius: 30,
          cornerSegments: 4
        },
        e2.parameters
      ), a = Math.abs(o.width), s = Math.abs(null !== (r = o.height) && void 0 !== r ? r : a), l = Math.abs(null !== (n = o.depth) && void 0 !== n ? n : a), c = Math.abs(Math.min(a, l)) / 2;
      return {
        parameters: Object.assign(o, {
          width: a,
          height: s,
          depth: l,
          radius: c,
          segments: Math.round(o.segments),
          pathSegments: Math.round(o.pathSegments),
          cornerSegments: Math.round(o.cornerSegments)
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.height, n = t.depth, o = t.radius, a = t.revolutions, s = t.segments, l = t.pathRadius, c = t.pathType, u = t.pathSegments, h = t.cornerRadius, d = t.cornerSegments, f = new HelixBufferGeometry(false, i, r, n, o, a, s, l, c, u, h, d);
      return Object.assign(f, {
        userData: __assign(__assign({}, e2), { type: "HelixGeometry" })
      });
    }, e;
  }(), HelixBufferGeometry = function(e) {
    function t(t2, i, r, n, o, a, s, l, c, u, h, d) {
      var f, p, v, m, g, E, y, A, T = e.call(this) || this, x = [], _ = [], w = [], S = [], b = [], R = [], C = [], O = new THREE.Vector3(), D = new THREE.Vector3(), M = new THREE.Vector3(), L = new THREE.Vector3(), I = new THREE.Vector3(), P = new THREE.Vector3(), B = new THREE.Vector3(), H = new THREE.Vector3(), N = new THREE.Vector3(), F = new THREE.Vector3(), G = new THREE.Vector3(), U = o - l, z = r - 2 * l + 1e-3, V = z / a, k = Math.ceil(s * a), j = z / k, Y = -z / 2, Q = 2 * Math.PI / u, $ = Math.PI / 2 / d, W = Math.min((1 - h / 100) * l, l - 0.1), X = l - W;
      function J(e2, i2) {
        var r2 = Math.PI / 2;
        E = i2 * j, A = 2 * Math.PI * (E % V) / V + r2, E += Y, y = Math.sin(A) * U, g = Math.cos(A) * U, t2 ? e2.set(g, y, E) : e2.set(g, E, y);
      }
      J(M, -1), J(L, 0), I.copy(M);
      for (var K = M.distanceTo(L), q = K * k + 2 * X, Z = q - X, ee = 0; ee <= k; ee++) {
        J(O, ee), G.subVectors(O, I).normalize(), I.copy(O), N.copy(O).setComponent(+t2 + 1, 0).normalize(), F.crossVectors(G, N).normalize();
        for (var te = 0 == ee ? 3 * Math.PI / 2 : $, ie = 0 == ee ? 0 : Z, re = 0, ne = 0; re <= u; ne = ++re * Q) {
          if (P.addVectors(
            M.copy(N).multiplyScalar(l * Math.cos(ne)),
            L.copy(F).multiplyScalar(l * Math.sin(ne))
          ), H.copy(P).normalize(), 0 == ee || ee == k) {
            L.copy(H).multiplyScalar(W), D.addVectors(O, L);
            for (var oe = 0, ae = te; oe < d; ae = ++oe * $ + te) {
              B.addVectors(
                M.copy(G).multiplyScalar(X * Math.sin(ae)),
                L.copy(H).multiplyScalar(X * Math.cos(ae))
              ), L.addVectors(D, B), B.normalize(), b.push(L.x, L.y, L.z), R.push(B.x, B.y, B.z);
              var se = +(0 == ee) + Math.sin(ae);
              C.push((ie + X * se) / q, re / u, 0);
            }
          }
          L.addVectors(O, P), _.push(L.x, L.y, L.z), w.push(H.x, H.y, H.z), S.push((X + ee * K) / q, re / u);
        }
      }
      var le = b.length / 2;
      for (re = 0; re < d; re++)
        for (oe = 0; oe <= u; oe++) {
          var ce = le + 3 * (oe * d + re), ue = 3 * ((u - oe) * d + d - re - 1);
          _.push.apply(_, __spread(b.slice(ce, ce + 3))), _.unshift.apply(_, __spread(b.slice(ue, ue + 3))), w.push.apply(w, __spread(R.slice(ce, ce + 3))), w.unshift.apply(w, __spread(R.slice(ue, ue + 3))), S.push.apply(S, __spread(C.slice(ce, ce + 2))), S.unshift.apply(S, __spread(C.slice(ue, ue + 2)));
        }
      var he = u + 1;
      for (re = 0; re < k + 2 * d; re++)
        for (oe = 0; oe < he - 1; oe++)
          v = (f = re * he + oe) + he, m = (p = f + 1) + he, x.push(f, p, v, p, m, v);
      f = _.length / 3 - u - 1;
      for (re = 0; re < u - 2; re++)
        x.push(f, f + re + 1, f + re + 2), x.push(0, re + 2, re + 1);
      return T.setIndex(x), T.setAttribute("position", new THREE.Float32BufferAttribute(_, 3)), T.setAttribute("normal", new THREE.Float32BufferAttribute(w, 3)), T.setAttribute("uv", new THREE.Float32BufferAttribute(S, 2)), T;
    }
    return __extends(t, e), t;
  }(THREE.BufferGeometry), IcosahedronGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : { width: 100, detail: 0 },
        e2.parameters
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (r = o.height) && void 0 !== r ? r : o.width
          ),
          depth: Math.abs(
            null !== (n = o.depth) && void 0 !== n ? n : o.width
          )
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.height, n = t.depth, o = t.detail, a = new THREE.IcosahedronBufferGeometry(0.5 * i, o);
      return a.scale(1, r / i, n / i), Object.assign(a, {
        userData: __assign(__assign({}, e2), {
          type: "IcosahedronGeometry"
        })
      });
    }, e;
  }(), LatheGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          segments: 64,
          verticalSegments: 64,
          points: [
            { x: 0, y: -50, id: 0 },
            { x: 50, y: -50, id: 1 },
            { x: 50, y: 50, id: 2 },
            { x: 0, y: 50, id: 3 }
          ]
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (r = o.height) && void 0 !== r ? r : o.width
          ),
          depth: Math.abs(
            null !== (n = o.depth) && void 0 !== n ? n : o.width
          )
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.points, r = t.segments, n = t.verticalSegments, o = new THREE.Shape();
      o.moveTo(i[0].x, i[0].y), o.bezierCurveTo(i[1].x, i[1].y, i[2].x, i[2].y, i[3].x, i[3].y);
      var a = new THREE.LatheBufferGeometry(o.extractPoints(n).shape, r);
      return a.rotateZ(Math.PI), Object.assign(a, {
        userData: __assign(__assign({}, e2), { type: "LatheGeometry" })
      });
    }, e;
  }(), ABC = ["a", "b", "c"];
  function getFaceIndexByString(e, t) {
    switch (t) {
      case "c":
        return e.c;
      case "b":
        return e.b;
      case "a":
      default:
        return e.a;
    }
  }
  function getEdge(e, t, i) {
    var r = Math.min(e, t) + "_" + Math.max(e, t);
    return i.get(r);
  }
  function processEdge(e, t, i, r, n, o) {
    var a, s = Math.min(e, t), l = Math.max(e, t), c = s + "_" + l;
    r.has(c) ? a = r.get(c) : (a = { a: i[s], b: i[l], newEdge: null, faces: [] }, r.set(c, a));
    a.faces.push(n), o[e].edges.push(a), o[t].edges.push(a);
  }
  function generateLookups(e, t, i, r) {
    var n, o, a;
    for (n = 0, o = e.length; n < o; n++) i[n] = { edges: [] };
    for (n = 0, o = t.length; n < o; n++)
      processEdge((a = t[n]).a, a.b, e, r, a, i), processEdge(a.b, a.c, e, r, a, i), processEdge(a.c, a.a, e, r, a, i);
  }
  function newFace(e, t, i, r, n) {
    e.push(new THREE.Face3(t, i, r, void 0, void 0, n));
  }
  function midpoint(e, t) {
    return Math.abs(t - e) / 2 + Math.min(e, t);
  }
  function newUv(e, t, i, r) {
    e.push([t.clone(), i.clone(), r.clone()]);
  }
  var SubdivisionModifier = function() {
    function e(e2) {
      void 0 === e2 && (e2 = 1), this.subdivisions = e2;
    }
    return e.prototype.modify = function(e2) {
      (e2 = e2 instanceof THREE.BufferGeometry ? new THREE.Geometry().fromBufferGeometry(e2) : e2.clone()).mergeVertices();
      for (var t = this.subdivisions; t-- > 0; ) this._smooth(e2);
      return e2.computeFaceNormals(), e2.computeVertexNormals(), e2;
    }, e.prototype._smooth = function(e2) {
      var t, i, r, n, o, a, s, l = new THREE.Vector3(), c = e2.vertices, u = e2.faces, h = e2.faceVertexUvs[0], d = void 0 !== h && h.length > 0, f = [], p = /* @__PURE__ */ new Map();
      generateLookups(c, u, f, p);
      var v, m, g, E, y, A, T, x, _, w, S, b, R, C, O = [];
      try {
        for (var D = __values(Array.from(p.keys())), M = D.next(); !M.done; M = D.next()) {
          var L = M.value;
          for (m = p.get(L), g = new THREE.Vector3(), y = 3 / 8, A = 1 / 8, 2 != (T = m.faces.length) && (y = 0.5, A = 0), g.addVectors(m.a, m.b).multiplyScalar(y), l.set(0, 0, 0), a = 0; a < T; a++) {
            for (E = m.faces[a], s = 0; s < 3 && ((v = c[getFaceIndexByString(E, ABC[s])]) === m.a || v === m.b); s++) ;
            v && l.add(v);
          }
          l.multiplyScalar(A), g.add(l), m.newEdge = O.length, O.push(g);
        }
      } catch (e3) {
        t = { error: e3 };
      } finally {
        try {
          M && !M.done && (i = D.return) && i.call(D);
        } finally {
          if (t) throw t.error;
        }
      }
      var I = [];
      for (n = 0, o = c.length; n < o; n++) {
        for (R = c[n], 3 == (r = (b = f[n].edges).length) ? x = 3 / 16 : r > 3 && (x = 3 / (8 * r)), _ = 1 - r * Number(x), w = x, r <= 2 && 2 == r && (_ = 3 / 4, w = 1 / 8), C = R.clone().multiplyScalar(_), l.set(0, 0, 0), a = 0; a < r; a++)
          v = (S = b[a]).a !== R ? S.a : S.b, l.add(v);
        l.multiplyScalar(Number(w)), C.add(l), I.push(C);
      }
      var P, B, H, N, F, G, U, z = I.concat(O), V = I.length, k = [], j = [], Y = new THREE.Vector2(), Q = new THREE.Vector2(), $ = new THREE.Vector2();
      for (n = 0, o = u.length; n < o; n++)
        E = u[n], newFace(
          k,
          P = Number(getEdge(E.a, E.b, p).newEdge) + V,
          B = Number(getEdge(E.b, E.c, p).newEdge) + V,
          H = Number(getEdge(E.c, E.a, p).newEdge) + V,
          E.materialIndex
        ), newFace(k, E.a, P, H, E.materialIndex), newFace(k, E.b, B, P, E.materialIndex), newFace(k, E.c, H, B, E.materialIndex), d && (F = (N = h[n])[0], G = N[1], U = N[2], Y.set(midpoint(F.x, G.x), midpoint(F.y, G.y)), Q.set(midpoint(G.x, U.x), midpoint(G.y, U.y)), $.set(midpoint(F.x, U.x), midpoint(F.y, U.y)), newUv(j, Y, Q, $), newUv(j, F, Y, $), newUv(j, G, Q, Y), newUv(j, U, $, Q));
      e2.vertices = z, e2.faces = k, d && (e2.faceVertexUvs[0] = j);
    }, e;
  }(), _size = new THREE.Vector3(), NonParametricGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = null !== (r = null !== (i = e2.geometry) && void 0 !== i ? i : null == t ? void 0 : t.geometry) && void 0 !== r ? r : new THREE.BufferGeometry().copy(
        new THREE.BoxBufferGeometry(100, 100, 100)
      );
      void 0 === t ? (o.computeBoundingBox(), o.boundingBox.getSize(_size), n = {
        width: _size.x,
        height: _size.y,
        depth: _size.z,
        subdivisions: 0
      }) : n = t.parameters;
      var a = __assign(__assign({}, n), e2.parameters);
      return {
        parameters: {
          width: Math.abs(a.width),
          height: Math.abs(a.height),
          depth: Math.abs(a.depth),
          subdivisions: Math.abs(a.subdivisions)
        },
        geometry: o
      };
    }, e.build = function(e2) {
      var t, i = e2.parameters, r = i.width, n = i.height, o = i.depth, a = i.subdivisions, s = null !== (t = e2.geometry) && void 0 !== t ? t : new THREE.BufferGeometry().copy(
        new THREE.BoxBufferGeometry(100, 100, 100)
      ), l = s.userData.parameters;
      void 0 === l ? (s.computeBoundingBox(), s.boundingBox.getSize(_size)) : _size.set(l.width, l.height, l.depth), r === _size.x && n === _size.y && o === _size.z || s.scale(
        0 === _size.x ? 1 : r / _size.x,
        0 === _size.y ? 1 : n / _size.y,
        0 === _size.z ? 1 : o / _size.z
      );
      var c = s.originalGeometry;
      if (a > 0) {
        if (void 0 === c || (null == l ? void 0 : l.subdivisions) !== a) {
          void 0 === c && (c = s);
          var u = new SubdivisionModifier(a);
          s = new THREE.BufferGeometry().fromGeometry(u.modify(c));
        }
      } else void 0 !== c && (s = c), c = void 0;
      return void 0 !== c && Object.assign(s, { originalGeometry: c }), delete e2.geometry, Object.assign(s, {
        userData: __assign(__assign({}, e2), {
          type: "NonParametricGeometry"
        })
      });
    }, e.loadFromUrl = function(e2, t, i) {
      var r = this;
      new THREE.BufferGeometryLoader(i).load(e2, function(e3) {
        var i2 = r.normalizeInputs({ geometry: e3 });
        e3.boundingBox.getSize(_size);
        var n = 100 / _size.x;
        Object.assign(i2.parameters, {
          width: 100,
          height: _size.y * n,
          depth: _size.z * n
        }), t(r.build(i2));
      });
    }, e;
  }(), PolygonGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          depth: 0,
          spikes: 5,
          cornerRadius: 0,
          extrudeDepth: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(n, {
          width: Math.abs(n.width),
          height: Math.abs(
            null !== (r = n.height) && void 0 !== r ? r : n.width
          )
        })
      };
    }, e.build = function(e2) {
      for (var t, i = e2.parameters, r = i.width, n = i.height, o = i.spikes, a = i.cornerRadius, s = i.extrudeDepth, l = i.extrudeBevelSize, c = i.extrudeBevelSegments, u = 0.5 * r, h = 0.5 * n, d = 2 * Math.PI / o, f = new THREE.Shape(), p = 0; p <= o; p++) {
        var v = d * p, m = 0 + Math.sin(v) * u, g = 0 + Math.cos(v) * h;
        f.lineTo(m, g);
      }
      return 0 !== a && roundShapePolygon(f, f.getPoints(), a), t = s > 0 ? new THREE.ExtrudeBufferGeometry(f, {
        curveSegments: 64,
        steps: 1,
        depth: s,
        bevelEnabled: true,
        bevelThickness: l,
        bevelSize: l,
        bevelOffset: 0,
        bevelSegments: c
      }) : new THREE.ShapeBufferGeometry(f, 32), fixUvs(t, r, n), Object.assign(t, {
        userData: __assign(__assign({}, e2), { type: "PolygonGeometry" })
      });
    }, e;
  }(), PyramidGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          radialSegments: 4,
          heightSegments: 1,
          cornerRadius: 0,
          cornerSegments: 8,
          openEnded: false
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (r = o.height) && void 0 !== r ? r : o.width
          ),
          depth: Math.abs(
            null !== (n = o.depth) && void 0 !== n ? n : o.width
          )
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.height, n = t.depth, o = t.radialSegments, a = t.heightSegments, s = t.openEnded, l = t.cornerRadius, c = t.cornerSegments, u = new RoundedPyramidBufferGeometry(0.5 * i, r, o, a, s, l, c);
      return u.scale(1, 1, n / i), Object.assign(u, {
        userData: __assign(__assign({}, e2), { type: "PyramidGeometry" })
      });
    }, e;
  }();
  function two2three$1(e, t, i) {
    i.x = e.x * t.x, i.y = e.y, i.z = e.x * t.y;
  }
  function offset3d(e, t, i, r, n, o) {
    var a = t.clone().sub(e), s = i.clone().sub(e), l = a.angleTo(s);
    if (a.normalize(), s.normalize(), r === n) {
      var c = a.add(s).normalize();
      o.copy(e).addScaledVector(c, r / Math.sin(l / 2));
    } else {
      var u = a.angleTo(s);
      o.copy(e), o.addScaledVector(a, n / Math.sin(u)), o.addScaledVector(s, r / Math.sin(u));
    }
  }
  function projectOntoLine(e, t, i) {
    var r = e.clone().sub(t), n = i.clone().sub(t);
    return r.projectOnVector(n), r.add(t);
  }
  var RoundedPyramidBufferGeometry = function(e) {
    function t(t2, i, r, n, o, a, s) {
      var l;
      void 0 === t2 && (t2 = 0.5), void 0 === i && (i = 1), void 0 === r && (r = 4), void 0 === o && (o = false), void 0 === a && (a = 0), void 0 === s && (s = 4);
      var c = e.call(this) || this;
      r = Math.floor(Math.max(3, r)), s = Math.floor(s);
      var u, h = [], d = [], f = [], p = [], v = 0, m = i / 2, g = Math.PI / r, E = t2 * Math.cos(Math.PI / r), y = 2 * Math.PI / r, A = (r - 2) * Math.PI / r, T = Math.PI - A, x = new THREE.Vector3(0, -m, 0), _ = new THREE.Vector3(0, m, 0), w = new THREE.Vector2(t2, -m), S = new THREE.Vector2(E, -m), b = new THREE.Vector2(0, _.y).sub(S), R = new THREE.Vector2(0, _.y).sub(w), C = new THREE.Vector2(b.y, -b.x).normalize(), O = new THREE.Vector2(R.y, -R.x).normalize(), D = t2 * Math.cos(Math.PI / r) * Math.tan((Math.PI - b.angle()) / 2) - 1e-8;
      a = Math.min(a, D);
      var M = new THREE.Vector3(C.x, C.y, 0), L = new THREE.Vector3(Math.cos(y) * M.x, M.y, Math.sin(y) * M.x);
      u = M.angleTo(L);
      var I = a / Math.tan((Math.PI - b.angle()) / 2), P = a / Math.tan((Math.PI - u) / 2), B = new THREE.Vector3();
      if (!o) {
        d.push(x.x, x.y, x.z), f.push(0, -1, 0), p.push(0, 0);
        var H = v++, N = [], F = w.clone(), G = I / Math.cos(Math.PI / r);
        F.x -= G;
        for (var U = 0; U < r; U++) {
          var z = U / r * Math.PI * 2 + g;
          two2three$1(F, new THREE.Vector2(Math.sin(z), Math.cos(z)), B), d.push(B.x, B.y, B.z), f.push(0, -1, 0), p.push(0, 0), N.push(v++);
        }
        for (U = 0; U < N.length; U++) h.push(N[U], H, N[(U + 1) % N.length]);
      }
      M = new THREE.Vector3();
      var V = new THREE.Vector3(), k = new THREE.Vector3(), j = new THREE.Vector3(), Y = new THREE.Vector3(), Q = new THREE.Vector3();
      for (U = 0; U < r; U++) {
        var $ = U / r * Math.PI * 2 + g, W = (U + 0.5) / r * Math.PI * 2 + g, X = (U + 1) / r * Math.PI * 2 + g, J = new THREE.Vector2(Math.sin($), Math.cos($)), K = new THREE.Vector2(Math.sin(W), Math.cos(W)), q = new THREE.Vector2(Math.sin(X), Math.cos(X));
        two2three$1(w, J, V), two2three$1(w, q, k), two2three$1(C, K, M), offset3d(_, V, k, P, P, j), d.push(j.x, j.y, j.z), offset3d(V, _, k, P, I, Y), d.push(Y.x, Y.y, Y.z), offset3d(k, V, _, I, P, Q), d.push(Q.x, Q.y, Q.z), f.push(M.x, M.y, M.z), f.push(M.x, M.y, M.z), f.push(M.x, M.y, M.z), p.push(0, 0), p.push(0, 0), p.push(0, 0);
        var Z = v++, ee = v++, te = v++;
        if (h.push(Z, ee, te), a > 0) {
          H = V.clone().add(k).multiplyScalar(0.5);
          var ie = _.clone().sub(H).normalize(), re = x.clone().sub(H).normalize().add(ie).normalize().multiplyScalar(-1);
          Ce(H, Q.clone().sub(Y), re, b.angle());
          var ne, oe = void 0;
          two2three$1(O, q, re = new THREE.Vector3()), ne = (l = __read(
            Ce(
              H = projectOntoLine(
                H = Q.clone().add(j).multiplyScalar(0.5),
                k,
                _
              ),
              Q.clone().sub(j),
              re,
              u,
              j.y
            ),
            2
          ))[0], oe = l[1];
          var ae = (H = ne).clone().setY(0).normalize(), se = new THREE.Vector3(0, -1, 0), le = ae.clone().cross(se);
          Oe(H, ae, se, le);
          var ce = b.angle(), ue = Math.PI - ce;
          (H = _.clone()).y -= a / Math.sin(ce - Math.PI / 2);
          for (var he = new THREE.Vector3(), de = [], fe = 0; fe < s; fe++) {
            for (var pe = [], ve = Math.PI / 2 - ue * fe / s, me = Math.cos(ve), ge = Math.sin(ve), Ee = W, ye = 0; ye <= fe; ye++) {
              var Ae = Math.cos(Ee), Te = Math.sin(Ee);
              M.x = me * Te, M.y = ge, M.z = me * Ae, he.copy(H).addScaledVector(M, a), d.push(he.x, he.y, he.z), f.push(M.x, M.y, M.z), p.push(0, 0), pe.push(v++), Ee += 2 * Math.PI / fe / r;
            }
            de.push(pe);
          }
          oe.reverse(), de.push(oe);
          for (var xe = de.length - 1, _e = 0; _e < xe; _e++) {
            var we = de[_e], Se = de[_e + 1], be = we.length - 1;
            h.push(Se[1], we[0], Se[0]);
            for (var Re = 1; Re <= be; Re++)
              h.push(we[Re], we[Re - 1], Se[Re]), h.push(Se[Re + 1], we[Re], Se[Re]);
          }
        }
      }
      function Ce(e2, t3, i2, r2, n2) {
        var o2 = -r2 / 2, l2 = (Math.PI - r2) / 2, c2 = t3.clone().normalize().cross(i2);
        e2.addScaledVector(i2, -a / Math.sin(l2));
        for (var u2 = new THREE.Vector3(), m2 = new THREE.Vector3(), g2 = v, E2 = [], y2 = 0; y2 <= s; y2++) {
          var A2 = o2 + y2 / s * r2;
          m2.set(0, 0, 0), m2.addScaledVector(c2, Math.sin(A2)), m2.addScaledVector(i2, Math.cos(A2));
          for (var T2 = 0; T2 <= 1; T2++) {
            var x2 = T2 / 1 - 0.5;
            if (u2.copy(e2), u2.addScaledVector(t3, x2), u2.addScaledVector(m2, a), null != n2) {
              var _2 = Math.max(0, u2.y - n2);
              u2.addScaledVector(t3, -_2 / t3.y);
            }
            d.push(u2.x, u2.y, u2.z), f.push(m2.x, m2.y, m2.z), p.push(0, 0), 0 === T2 && E2.push(v), v++;
          }
        }
        for (y2 = 0; y2 < s; y2++)
          for (T2 = 0; T2 < 1; T2++) {
            var w2 = (A2 = g2 + T2 + 2 * y2) + 2, S2 = w2 + 1, b2 = A2 + 1;
            h.push(A2, w2, b2), h.push(w2, S2, b2);
          }
        return [e2.clone().addScaledVector(t3, 0.5), E2];
      }
      function Oe(e2, t3, i2, r2) {
        for (var n2 = Math.PI / 2, o2 = R.angle() - n2, l2 = [], c2 = new THREE.Vector3(), u2 = new THREE.Vector3(), m2 = 0; m2 <= s; m2++) {
          for (var g2 = [], E2 = m2 / s, y2 = 0; y2 <= m2; y2++) {
            var A2 = ((m2 ? y2 / m2 : 0) - 0.5) * T, x2 = Math.cos(A2), _2 = Math.sin(A2), w2 = (n2 + Math.atan(Math.tan(o2) * x2)) * E2, S2 = Math.cos(w2), b2 = Math.sin(w2);
            c2.set(0, 0, 0), c2.addScaledVector(t3, b2 * x2), c2.addScaledVector(i2, S2), c2.addScaledVector(r2, b2 * _2), u2.copy(e2).addScaledVector(c2, a), d.push(u2.x, u2.y, u2.z), f.push(c2.x, c2.y, c2.z), p.push(0, 0), g2.push(v++);
          }
          l2.push(g2);
        }
        for (var C2 = l2.length - 1, O2 = 0; O2 < C2; O2++) {
          var D2 = l2[O2], M2 = l2[O2 + 1], L2 = D2.length - 1;
          h.push(D2[0], M2[1], M2[0]);
          for (var I2 = 1; I2 <= L2; I2++)
            h.push(D2[I2 - 1], D2[I2], M2[I2]), h.push(D2[I2], M2[I2 + 1], M2[I2]);
        }
      }
      return c.setIndex(h), c.setAttribute("position", new THREE.Float32BufferAttribute(d, 3)), c.setAttribute("normal", new THREE.Float32BufferAttribute(f, 3)), c.setAttribute("uv", new THREE.Float32BufferAttribute(p, 2)), c;
    }
    return __extends(t, e), t;
  }(THREE.BufferGeometry), RectangleGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          depth: 0,
          cornerRadius: [0, 0, 0, 0],
          cornerType: 1,
          extrudeDepth: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1
        },
        e2.parameters
      ), a = Object.assign(
        null !== (r = null == t ? void 0 : t.ui) && void 0 !== r ? r : { enabledIndieCorners: false },
        e2.ui
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (n = o.height) && void 0 !== n ? n : o.width
          )
        }),
        ui: a
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.height, n = t.cornerRadius, o = t.cornerType, a = t.extrudeDepth, s = t.extrudeBevelSize, l = t.extrudeBevelSegments, c = { x: 0.5 * i, y: 0.5 * r }, u = { x: -c.x, y: -c.y }, h = { x: c.x, y: c.y };
      function d(e3, t2, n2) {
        return t2 > i && n2 > r ? Math.min(e3 * i / t2, e3 * r / n2) : t2 > i ? e3 * i / t2 : n2 > r ? e3 * r / n2 : e3;
      }
      var f = [];
      f[0] = 0 === n[0] ? 0 : d(n[0], n[0] + n[3], n[0] + n[1]), f[1] = 0 === n[1] ? 0 : d(n[1], n[1] + n[2], n[1] + n[0]), f[2] = 0 === n[2] ? 0 : d(n[2], n[2] + n[1], n[2] + n[3]), f[3] = 0 === n[3] ? 0 : d(n[3], n[3] + n[0], n[3] + n[2]);
      var p, v = u.x, m = h.x, g = h.y, E = u.y, y = new THREE.Shape();
      if (y.moveTo(v, g - f[0]), 1 == o)
        n[0] > 0 && y.quadraticCurveTo(v, g, v + f[0], g), y.lineTo(m - f[1], g), n[1] > 0 && y.quadraticCurveTo(m, g, m, g - f[1]), y.lineTo(m, E + f[2]), n[2] > 0 && y.quadraticCurveTo(m, E, m - f[2], E), y.lineTo(v + f[3], E), n[3] > 0 && y.quadraticCurveTo(v, E, v, E + f[3]), y.lineTo(v, g - f[0]);
      else {
        var A = 4 * (Math.SQRT2 - 1) / 3;
        n[0] > 0 && y.bezierCurveTo(
          v,
          g + f[0] * (A - 1),
          v - f[0] * (A - 1),
          g,
          v + f[0],
          g
        ), y.lineTo(m - f[1], g), n[1] > 0 && y.bezierCurveTo(
          m + f[1] * (A - 1),
          g,
          m,
          g + f[1] * (A - 1),
          m,
          g - f[1]
        ), y.lineTo(m, E + f[2]), n[2] > 0 && y.bezierCurveTo(
          m,
          E - f[2] * (A - 1),
          m + f[2] * (A - 1),
          E,
          m - f[2],
          E
        ), y.lineTo(v + f[3], E), n[3] > 0 && y.bezierCurveTo(
          v - f[3] * (A - 1),
          E,
          v,
          E - f[3] * (A - 1),
          v,
          E + f[3]
        );
      }
      return y.lineTo(v, g - f[0]), p = a > 0 ? new THREE.ExtrudeBufferGeometry(y, {
        curveSegments: 64,
        steps: 1,
        depth: a,
        bevelEnabled: true,
        bevelThickness: s,
        bevelSize: s,
        bevelOffset: 0,
        bevelSegments: l
      }) : new THREE.ShapeBufferGeometry(y, 32), fixUvs(p, i, r), Object.assign(p, {
        userData: __assign(__assign({}, e2), { type: "RectangleGeometry" })
      });
    }, e;
  }(), SphereGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          widthSegments: 64,
          heightSegments: 64,
          phiStart: 0,
          phiLength: 2 * Math.PI,
          thetaStart: 0,
          thetaLength: Math.PI
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (r = o.height) && void 0 !== r ? r : o.width
          ),
          depth: Math.abs(
            null !== (n = o.depth) && void 0 !== n ? n : o.width
          )
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = void 0 === i ? 100 : i, n = t.height, o = void 0 === n ? r : n, a = t.depth, s = void 0 === a ? r : a, l = t.widthSegments, c = void 0 === l ? 64 : l, u = t.heightSegments, h = void 0 === u ? 64 : u, d = t.phiStart, f = t.phiLength, p = t.thetaStart, v = t.thetaLength, m = new THREE.SphereBufferGeometry(0.5 * r, c, h, d, f, p, v);
      return m.scale(1, o / r, s / r), Object.assign(m, {
        userData: __assign(__assign({}, e2), { type: "SphereGeometry" })
      });
    }, e;
  }(), StarGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          depth: 0,
          innerRadiusPercent: 38.19,
          spikes: 5,
          cornerRadius: 0,
          angle: 360,
          extrudeDepth: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(n, {
          width: Math.abs(n.width),
          height: Math.abs(
            null !== (r = n.height) && void 0 !== r ? r : n.width
          )
        })
      };
    }, e.build = function(e2) {
      var t, i = e2.parameters, r = i.width, n = i.height, o = i.innerRadiusPercent, a = i.spikes, s = i.cornerRadius, l = i.angle, c = i.extrudeDepth, u = i.extrudeBevelSize, h = i.extrudeBevelSegments, d = 0.5 * r, f = 0.5 * n, p = l * Math.PI / 360 / a, v = Math.PI / 2 * 3 * -1, m = d * o / 100, g = f * o / 100, E = new THREE.Shape();
      if (3 == a && 50 == o) {
        p = 2 * Math.PI / a;
        for (var y = 0; y <= a; y++) {
          var A = p * y, T = 0 + Math.sin(A) * d, x = 0 + Math.cos(A) * f;
          E.lineTo(T, x);
        }
      } else {
        E.moveTo(0, 0 + l == 360 ? f : 0);
        for (y = 0; y < a; y++) {
          T = 0 + Math.cos(v) * d, x = 0 + Math.sin(v) * f;
          E.lineTo(T, x), v += p, T = 0 + Math.cos(v) * m, x = 0 + Math.sin(v) * g, E.lineTo(T, x), v += p;
        }
        E.lineTo(0, 0 + l == 360 ? f : 0);
      }
      return 0 !== s && roundShapePolygon(E, E.getPoints(), s), t = c > 0 ? new THREE.ExtrudeBufferGeometry(E, {
        steps: 1,
        depth: c,
        bevelEnabled: true,
        bevelThickness: u,
        bevelSize: u,
        bevelOffset: 0,
        bevelSegments: h
      }) : new THREE.ShapeBufferGeometry(E), fixUvs(t, r, n), Object.assign(t, {
        userData: __assign(__assign({}, e2), { type: "StarGeometry" })
      });
    }, e;
  }(), TextFrameGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : { width: 100, depth: 0 },
        e2.parameters
      );
      return {
        parameters: Object.assign(n, {
          width: Math.abs(n.width),
          height: Math.abs(
            null !== (r = n.height) && void 0 !== r ? r : n.width
          ),
          depth: Math.abs(n.depth)
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.height, n = new THREE.PlaneBufferGeometry(i, r);
      return Object.assign(n, {
        userData: __assign(__assign({}, e2), { type: "TextFrameGeometry" })
      });
    }, e;
  }(), TorusGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          radialSegments: 64,
          tubularSegments: 64,
          arc: 2 * Math.PI,
          cornerRadius: 30,
          cornerSegments: 8
        },
        e2.parameters
      ), a = Math.abs(o.width), s = Math.abs(null !== (r = o.height) && void 0 !== r ? r : o.width), l = Math.abs(
        null !== (n = o.depth) && void 0 !== n ? n : 0.25 * o.width
      );
      return {
        parameters: Object.assign(o, { width: a, height: s, depth: l })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.height, n = t.depth, o = t.radialSegments, a = t.tubularSegments, s = genTorus(
        i,
        r,
        n,
        0.5 * i,
        t.arc,
        o,
        0,
        0,
        a,
        t.cornerRadius,
        t.cornerSegments
      );
      return s.scale(1, r / i, 1), Object.assign(s, {
        userData: __assign(__assign({}, e2), { type: "TorusGeometry" })
      });
    }, e;
  }();
  function genTorus(e, t, i, r, n, o, a, s, l, c, u) {
    var h;
    return t = (h = __read([i, t], 2))[0], i = h[1], a = t / 2, 1 == (n /= 2 * Math.PI) && (c = 0), new HelixBufferGeometry(true, e, t, i, r, n, o, a, s, l, c, u);
  }
  var TorusKnotGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          depth: 1,
          tube: 50,
          tubularSegments: 64,
          radialSegments: 32,
          p: 2,
          q: 3
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(o, {
          width: Math.abs(o.width),
          height: Math.abs(
            null !== (r = o.height) && void 0 !== r ? r : o.width
          ),
          depth: Math.abs(null !== (n = o.depth) && void 0 !== n ? n : 1)
        })
      };
    }, e.build = function(e2) {
      var t = e2.parameters, i = t.width, r = t.tube, n = t.tubularSegments, o = t.radialSegments, a = t.p, s = t.q, l = 0.5 * i - r, c = new THREE.TorusKnotBufferGeometry(l, r, n, o, a, s);
      return Object.assign(c, {
        userData: __assign(__assign({}, e2), { type: "TorusKnotGeometry" })
      });
    }, e;
  }(), TriangleGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          depth: 0,
          spikes: 5,
          cornerRadius: 0,
          extrudeDepth: 0,
          extrudeBevelSize: 0,
          extrudeBevelSegments: 1,
          isRect: false
        },
        e2.parameters
      );
      return {
        parameters: Object.assign(n, {
          width: Math.abs(n.width),
          height: Math.abs(
            null !== (r = n.height) && void 0 !== r ? r : n.width * (n.isRect ? 1 : Math.sqrt(3) / 2)
          )
        })
      };
    }, e.build = function(e2) {
      var t, i = e2.parameters, r = i.width, n = void 0 === r ? 100 : r, o = i.height, a = i.cornerRadius, s = i.extrudeDepth, l = i.extrudeBevelSize, c = i.extrudeBevelSegments, u = i.isRect, h = new THREE.Shape();
      if (u)
        h.moveTo(0.5 * -n, 0.5 * o), h.lineTo(0.5 * n, 0.5 * -o), h.lineTo(0.5 * -n, 0.5 * -o), h.lineTo(0.5 * -n, 0.5 * o);
      else {
        var d = { x: 0.5 * n, y: 0.5 * o };
        h.moveTo(0, d.y), h.lineTo(d.x, -d.y), h.lineTo(-d.x, -d.y), h.lineTo(0, d.y);
      }
      return 0 !== a && roundShapePolygonTriangle(h, h.getPoints(), a), t = s > 0 ? new THREE.ExtrudeBufferGeometry(h, {
        curveSegments: 64,
        steps: 1,
        depth: s,
        bevelEnabled: true,
        bevelThickness: l,
        bevelSize: l,
        bevelOffset: 0,
        bevelSegments: c
      }) : new THREE.ShapeBufferGeometry(h, 32), fixUvs(t, n, o), Object.assign(t, {
        userData: __assign(__assign({}, e2), { type: "TriangleGeometry" })
      });
    }, e;
  }();
  function roundShapePolygonTriangle(e, t, i) {
    var r, n, o, a, s, l, c, u, h, d, f, p, v, m, g = function(e2, t2) {
      var i2 = t2.x - e2.x, r2 = t2.y - e2.y, n2 = Math.sqrt(i2 * i2 + r2 * r2), o2 = i2 / n2, a2 = r2 / n2;
      return { x: i2, y: r2, len: n2, nx: o2, ny: a2, ang: Math.atan2(a2, o2) };
    }, E = t.length - 1;
    for (a = t[E - 1], e.curves = [], r = 0; r < E; r++) {
      s = t[r % E], l = t[(r + 1) % E];
      var y = g(s, a), A = g(s, l);
      c = y.nx * A.ny - y.ny * A.nx, u = y.nx * A.nx - y.ny * -A.ny, f = Math.asin(c), h = 1, d = false, u < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, h = -1, d = true) : f > 0 && (h = -1, d = true), p = 0.5 * f, (m = Math.abs(Math.cos(p) * i / Math.sin(p))) > Math.min(0.5 * y.len, 0.5 * A.len) ? (m = Math.min(0.5 * y.len, 0.5 * A.len), v = Math.abs(m * Math.sin(p) / Math.cos(p))) : v = i, n = s.x + A.nx * m, o = s.y + A.ny * m, n += -A.ny * v * h, o += A.nx * v * h, e.absarc(
        n,
        o,
        v,
        y.ang + Math.PI / 2 * h,
        A.ang - Math.PI / 2 * h,
        d
      ), a = s, s = l;
    }
    e.closePath();
  }
  var Point = function() {
    function e(e2) {
      this.position = new THREE.Vector2(), this.startPosition = new THREE.Vector2(), this.uuid = THREE.MathUtils.generateUUID(), this.position = e2.clone();
    }
    return e.prototype.start = function() {
      this.reset();
    }, e.prototype.reset = function() {
      this.startPosition.copy(this.position);
    }, e.prototype.applyOffset = function(e2) {
      this.position.copy(this.startPosition).add(e2);
    }, e.prototype.copy = function(e2) {
      return this.position.copy(e2.position), this.startPosition.copy(e2.startPosition), this;
    }, e.prototype.clone = function() {
      return new e(this.position).copy(this);
    }, e.prototype.toJSON = function() {
      return [this.position.x, this.position.y];
    }, e;
  }(), BezierControl = function(e) {
    function t(t2) {
      var i = e.call(this, t2.position) || this;
      return i.parent = t2, i;
    }
    return __extends(t, e), t.prototype.copy = function(t2) {
      return e.prototype.copy.call(this, t2), this;
    }, t.prototype.clone = function() {
      return new t(this.parent).copy(this);
    }, t;
  }(Point), BezierPoint = function(e) {
    function t(t2) {
      var i = e.call(this, t2) || this;
      return i.controls = [], i.roundness = 0, i.areControlsDirectionsMirrored = true, i.controls.push(new BezierControl(i), new BezierControl(i)), i;
    }
    return __extends(t, e), t.prototype.getOppositeControl = function(e2) {
      var t2 = this.controls.indexOf(e2);
      return 0 === t2 ? this.controls[1] : 1 === t2 ? this.controls[0] : null;
    }, t.prototype.applyOffsetToControls = function(e2, t2) {
      void 0 === t2 && (t2 = 1);
      for (var i = 0, r = this.controls.length; i < r; i++) {
        var n = this.controls[i];
        this.position.distanceTo(n.position) <= t2 ? n.position.copy(this.position) : n.applyOffset(e2);
      }
    }, t.prototype.controlsMoved = function() {
      return !(this.position.equals(this.controls[0].position) && this.position.equals(this.controls[1].position));
    }, t.prototype.copy = function(t2) {
      return e.prototype.copy.call(this, t2), this.controls[0].copy(t2.controls[0]), this.controls[1].copy(t2.controls[1]), this;
    }, t.prototype.clone = function() {
      return new t(this.position).copy(this);
    }, t.prototype.toJSON = function() {
      return e.prototype.toJSON.call(this).concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [
        this.roundness
      ]);
    }, t;
  }(Point), toTCurve = function(e) {
    return e;
  }, tempV2 = new THREE.Vector2(), tempbV2 = new THREE.Vector2(), tempaV3 = new THREE.Vector3(), tempbV3 = new THREE.Vector3();
  function isStraightLine(e, t) {
    return e.position.equals(e.controls[1].position) && t.position.equals(t.controls[0].position);
  }
  function pointsToBuffer(e, t, i, r) {
    void 0 === i && (i = 12), void 0 === r && (r = true);
    for (var n, o = tempbV3.set(0, 0, 0), a = 0, s = 0; s < t.length; s++)
      for (var l = toTCurve(t[s]), c = tempV2, u = getCurveDivision(l, i), h = 0; h <= u; h++)
        if (l instanceof THREE.CubicBezierCurve || l instanceof THREE.LineCurve) {
          if (l.getPoint(h / u, c), o.set(c.x, c.y, 0), null == n ? void 0 : n.equals(o))
            continue;
          void 0 === n && (n = tempaV3), n.copy(o), e.setXYZ(a, o.x, o.y, o.z), a++;
        }
    return r && a > 1 && (e.getX(a - 1) !== e.getX(0) || e.getY(a - 1) !== e.getY(0) || e.getZ(a - 1) !== e.getZ(0)) && (e.setXYZ(a, e.getX(0), e.getY(0), e.getZ(0)), a++), e;
  }
  function pointsSegmentsToBuffer(e, t, i, r, n) {
    void 0 === r && (r = 12), void 0 === n && (n = true);
    for (var o = tempbV3.set(0, 0, 0), a = 0, s = [], l = 0; l < t.length; l++)
      if (false !== i[l]) {
        var c = void 0, u = toTCurve(t[l]), h = tempV2, d = getCurveDivision(u, r);
        s.push(d);
        for (var f = 0; f <= d; f++)
          if (u instanceof THREE.CubicBezierCurve || u instanceof THREE.LineCurve) {
            if (u.getPoint(f / d, h), o.set(h.x, h.y, 0), null == c ? void 0 : c.equals(o))
              continue;
            void 0 === c ? c = tempaV3 : (e.setXYZ(a, c.x, c.y, c.z), a++, e.setXYZ(a, o.x, o.y, o.z), a++), c.copy(o);
          }
      }
    return n && a > 1 && (e.getX(a - 1) !== e.getX(0) || e.getY(a - 1) !== e.getY(0) || e.getZ(a - 1) !== e.getZ(0)) && (e.setXYZ(a, e.getX(0), e.getY(0), e.getZ(0)), a++), s;
  }
  function getCurvesDivisions(e, t) {
    void 0 === t && (t = 12);
    for (var i = [], r = 0; r < e.length; r++) i.push(getCurveDivision(e[r], t));
    return i;
  }
  function getCurveDivision(e, t) {
    return void 0 === t && (t = 12), e && e instanceof THREE.EllipseCurve ? 2 * t : e && (e instanceof THREE.LineCurve || e instanceof THREE.LineCurve3) ? 1 : e && e instanceof THREE.SplineCurve ? t * e.points.length : t;
  }
  function pointsToFlatArray(e, t, i, r) {
    var n;
    void 0 === i && (i = 12), void 0 === r && (r = true);
    for (var o = 0, a = 0; a < t.length; a++)
      for (var s = toTCurve(t[a]), l = getCurveDivision(s, i), c = tempV2, u = 0; u <= l; u++)
        if (s instanceof THREE.CubicBezierCurve || s instanceof THREE.LineCurve) {
          if (s.getPoint(u / l, c), null == n ? void 0 : n.equals(c)) continue;
          void 0 === n && (n = tempbV2), n.copy(c), e.push(c.x, c.y), o++;
        }
    return r && o > 1 && (e[o - 1] !== e[1] || e[o - 2] !== e[0]) && (e.push(e[0], e[1]), o++), e;
  }
  var ts1V2 = new THREE.Vector2(), ts2V2 = new THREE.Vector2(), ts3V2 = new THREE.Vector2(), ts4V2 = new THREE.Vector2(), ts5V2 = new THREE.Vector2(), VectorShape = function(e) {
    function t(t2, i) {
      void 0 === t2 && (t2 = 100), void 0 === i && (i = 100);
      var r = e.call(this) || this;
      return r.points = [], r.shapeHoles = [], r.eventDispatcher = new THREE.EventDispatcher(), r.plane = new THREE.Plane(new THREE.Vector3(0, 0, -1)), r.isClosed = false, r.uuid = THREE.MathUtils.generateUUID(), r._width = t2, r._height = i, r;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "width", {
      get: function() {
        return this._width;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "height", {
      get: function() {
        return this._height;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.applySize = function(e2, t2) {
      0 === e2 && (e2 = 1e-3), 0 === t2 && (t2 = 1e-3), this.applyScale(e2 / this.width, t2 / this.height), this._width = e2, this._height = t2;
    }, t.prototype.applyScale = function(e2, t2) {
      for (var i = ts1V2.set(e2, t2), r = 0, n = this.points.length; r < n; r++) {
        var o = this.points[r];
        o.position.multiply(i), o.controls[0].position.multiply(i), o.controls[1].position.multiply(i);
      }
      this.update();
    }, t.prototype.createPoint = function(e2, t2) {
      var i;
      return void 0 === t2 && (t2 = 0), i = e2 instanceof THREE.Vector2 ? e2 : new THREE.Vector2(e2, t2), new BezierPoint(i);
    }, t.prototype.addPoint = function(e2) {
      this.points.push(e2), this._update();
    }, t.prototype.addPointAt = function(e2, t2) {
      this.points.splice(t2, 0, e2), this._update();
    }, t.prototype.getLastPoint = function() {
      return this.points[this.points.length - 1];
    }, t.prototype.removePoint = function(e2) {
      var t2 = this.points.indexOf(e2);
      t2 >= 0 && this.points.splice(t2, 1), this._update();
    }, t.prototype.splitCurveAt = function(e2, t2, i) {
      void 0 === i && (i = 0.5);
      var r = this.points.indexOf(e2), n = this.points.indexOf(t2);
      if (r < 0 || n < 0) return null;
      var o = isStraightLine(e2, t2), a = new THREE.Vector2(), s = new BezierPoint(a);
      if (o)
        a.subVectors(t2.position, e2.position).multiplyScalar(i).add(e2.position), s.position.copy(a), s.controls[0].position.copy(a), s.controls[1].position.copy(a);
      else {
        var l = ts1V2.subVectors(e2.controls[1].position, e2.position).multiplyScalar(i).add(e2.position), c = ts2V2.subVectors(t2.controls[0].position, e2.controls[1].position).multiplyScalar(i).add(e2.controls[1].position), u = ts3V2.subVectors(t2.position, t2.controls[0].position).multiplyScalar(i).add(t2.controls[0].position), h = l, d = ts4V2.subVectors(c, l).multiplyScalar(i).add(l), f = ts5V2.subVectors(u, c).multiplyScalar(i).add(c), p = u;
        a.subVectors(f, d).multiplyScalar(i).add(d), s.position.copy(a), s.controls[0].position.copy(d), s.controls[1].position.copy(f), e2.controls[1].position.copy(h), t2.controls[0].position.copy(p);
      }
      return this.points.splice(r + 1, 0, s), this._update(), s;
    }, t.prototype.update = function() {
      this._update();
    }, t.prototype.extractShapePointsToBuffer = function(e2, t2) {
      return void 0 === t2 && (t2 = 12), this.curveDivisions = getCurvesDivisions(this.curves, t2), pointsToBuffer(e2, this.curves, t2, this.autoClose), this.curveDivisions.reduce(function(e3, t3) {
        return e3 + t3;
      }, 0) + 1;
    }, t.prototype.extractFilteredShapePointsToBuffer = function(e2, t2, i) {
      return void 0 === i && (i = 12), 2 * pointsSegmentsToBuffer(
        e2,
        this.curves,
        t2,
        i,
        this.autoClose
      ).reduce(function(e3, t3) {
        return e3 + t3;
      }, 0);
    }, t.prototype.extractShapePointsToFlatArray = function(e2, t2) {
      return void 0 === t2 && (t2 = 12), this.curveDivisions = getCurvesDivisions(this.curves, t2), pointsToFlatArray(e2, this.curves, t2, this.autoClose);
    }, t.prototype.getCurveIndexFromVertexId = function(e2) {
      var t2 = 0;
      if (!this.curveDivisions) throw Error("no cache curveDivisions cache");
      for (var i = 0, r = this.curveDivisions.length; i < r; i++) {
        var n = this.curveDivisions[i];
        if (e2 < t2 + n) return [i, (e2 - t2 + 1) / n];
        t2 += n;
      }
      return [0, 1];
    }, t.prototype.getCurveT = function(e2, t2, i) {
      var r = this.points[e2], n = this.points[e2 >= this.points.length - 1 ? 0 : e2 + 1], o = this.curveDivisions, a = o[e2];
      if (isStraightLine(r, n)) {
        var s = r.position.distanceTo(n.position);
        return r.position.distanceTo(ts1V2.set(i.x, i.y)) / s;
      }
      for (var l = 0, c = 0; c < e2; c++) l += o[c];
      return (t2 - l + 1) / a;
    }, t.prototype.dispose = function() {
      this.eventDispatcher = null;
    }, t.prototype._update = function() {
      var e2;
      this.curves = [];
      for (var t2 = 0, i = this.points.length; t2 < i; t2++) {
        var r = this.points[t2];
        if (0 === t2) this.moveTo(r.position.x, r.position.y);
        else
          isStraightLine(n = this.points[t2 - 1], r) ? this.lineTo(r.position.x, r.position.y) : this.bezierCurveTo(
            n.controls[1].position.x,
            n.controls[1].position.y,
            r.controls[0].position.x,
            r.controls[0].position.y,
            r.position.x,
            r.position.y
          );
      }
      if (this.isClosed) {
        var n;
        r = this.points[0];
        isStraightLine(n = this.points[this.points.length - 1], r) ? this.lineTo(r.position.x, r.position.y) : this.bezierCurveTo(
          n.controls[1].position.x,
          n.controls[1].position.y,
          r.controls[0].position.x,
          r.controls[0].position.y,
          r.position.x,
          r.position.y
        );
      }
      null === (e2 = this.eventDispatcher) || void 0 === e2 || e2.dispatchEvent({ type: "update" });
    }, t.prototype.clone = function() {
      var e2 = new t(this._width, this._height);
      return e2.points = this.points.map(function(e3) {
        return e3.clone();
      }), e2.isClosed = this.isClosed, e2;
    }, t.prototype.toJSON = function() {
      return {
        points: this.points.reduce(function(e2, t2) {
          return e2.concat(t2.toJSON());
        }, []),
        isClosed: this.isClosed
      };
    }, t.prototype.fromJSON = function(e2) {
      this.points = [];
      for (var t2 = e2.points.length / 7, i = 0; i < t2; i++) {
        var r = 7 * i, n = e2.points[r + 0], o = e2.points[r + 1], a = e2.points[r + 2], s = e2.points[r + 3], l = e2.points[r + 4], c = e2.points[r + 5], u = e2.points[r + 6], h = new BezierPoint(new THREE.Vector2(n, o));
        h.controls[0].position.set(a, s), h.controls[1].position.set(l, c), h.roundness = u, this.points.push(h);
      }
      return this.isClosed = e2.isClosed, this._update(), this;
    }, t;
  }(THREE.Shape), WINDING, ELEMENT;
  function assert(e, t) {
    if (!e) throw t || "Assertion Failed!";
  }
  !function(e) {
    e[e.ODD = 0] = "ODD", e[e.NONZERO = 1] = "NONZERO", e[e.POSITIVE = 2] = "POSITIVE", e[e.NEGATIVE = 3] = "NEGATIVE", e[e.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO";
  }(WINDING || (WINDING = {})), function(e) {
    e[e.POLYGONS = 0] = "POLYGONS", e[e.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", e[e.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS";
  }(ELEMENT || (ELEMENT = {}));
  var Geom = function() {
    function e() {
    }
    return e.vertEq = function(e2, t) {
      return e2.s === t.s && e2.t === t.t;
    }, e.vertLeq = function(e2, t) {
      return e2.s < t.s || e2.s === t.s && e2.t <= t.t;
    }, e.transLeq = function(e2, t) {
      return e2.t < t.t || e2.t === t.t && e2.s <= t.s;
    }, e.edgeGoesLeft = function(t) {
      return e.vertLeq(t.Dst, t.Org);
    }, e.edgeGoesRight = function(t) {
      return e.vertLeq(t.Org, t.Dst);
    }, e.vertL1dist = function(e2, t) {
      return Math.abs(e2.s - t.s) + Math.abs(e2.t - t.t);
    }, e.edgeEval = function(t, i, r) {
      assert(e.vertLeq(t, i) && e.vertLeq(i, r));
      var n = i.s - t.s, o = r.s - i.s;
      return n + o > 0 ? n < o ? i.t - t.t + (t.t - r.t) * (n / (n + o)) : i.t - r.t + (r.t - t.t) * (o / (n + o)) : 0;
    }, e.edgeSign = function(t, i, r) {
      assert(e.vertLeq(t, i) && e.vertLeq(i, r));
      var n = i.s - t.s, o = r.s - i.s;
      return n + o > 0 ? (i.t - r.t) * n + (i.t - t.t) * o : 0;
    }, e.transEval = function(t, i, r) {
      assert(e.transLeq(t, i) && e.transLeq(i, r));
      var n = i.t - t.t, o = r.t - i.t;
      return n + o > 0 ? n < o ? i.s - t.s + (t.s - r.s) * (n / (n + o)) : i.s - r.s + (r.s - t.s) * (o / (n + o)) : 0;
    }, e.transSign = function(t, i, r) {
      assert(e.transLeq(t, i) && e.transLeq(i, r));
      var n = i.t - t.t, o = r.t - i.t;
      return n + o > 0 ? (i.s - r.s) * n + (i.s - t.s) * o : 0;
    }, e.vertCCW = function(e2, t, i) {
      return e2.s * (t.t - i.t) + t.s * (i.t - e2.t) + i.s * (e2.t - t.t) >= 0;
    }, e.interpolate = function(e2, t, i, r) {
      return (e2 = e2 < 0 ? 0 : e2) <= (i = i < 0 ? 0 : i) ? 0 === i ? (t + r) / 2 : t + e2 / (e2 + i) * (r - t) : r + i / (e2 + i) * (t - r);
    }, e.intersect = function(t, i, r, n, o) {
      var a, s, l;
      e.vertLeq(t, i) || (l = t, t = i, i = l), e.vertLeq(r, n) || (l = r, r = n, n = l), e.vertLeq(t, r) || (l = t, t = r, r = l, l = i, i = n, n = l), e.vertLeq(r, i) ? e.vertLeq(i, n) ? ((a = e.edgeEval(t, r, i)) + (s = e.edgeEval(r, i, n)) < 0 && (a = -a, s = -s), o.s = e.interpolate(a, r.s, s, i.s)) : ((a = e.edgeSign(t, r, i)) + (s = -e.edgeSign(t, n, i)) < 0 && (a = -a, s = -s), o.s = e.interpolate(a, r.s, s, n.s)) : o.s = (r.s + i.s) / 2, e.transLeq(t, i) || (l = t, t = i, i = l), e.transLeq(r, n) || (l = r, r = n, n = l), e.transLeq(t, r) || (l = t, t = r, r = l, l = i, i = n, n = l), e.transLeq(r, i) ? e.transLeq(i, n) ? ((a = e.transEval(t, r, i)) + (s = e.transEval(r, i, n)) < 0 && (a = -a, s = -s), o.t = e.interpolate(a, r.t, s, i.t)) : ((a = e.transSign(t, r, i)) + (s = -e.transSign(t, n, i)) < 0 && (a = -a, s = -s), o.t = e.interpolate(a, r.t, s, n.t)) : o.t = (r.t + i.t) / 2;
    }, e;
  }(), TESSface = function() {
    this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = false, this.inside = false;
  }, TESShalfEdge = function() {
    function e(e2) {
      this.side = e2, this.next = null, this.Org = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Lface = null, this.activeRegion = null, this.winding = 0;
    }
    return Object.defineProperty(e.prototype, "Rface", {
      get: function() {
        return this.Sym.Lface;
      },
      set: function(e2) {
        this.Sym.Lface = e2;
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(e.prototype, "Dst", {
      get: function() {
        return this.Sym.Org;
      },
      set: function(e2) {
        this.Sym.Org = e2;
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(e.prototype, "Oprev", {
      get: function() {
        return this.Sym.Lnext;
      },
      set: function(e2) {
        this.Sym.Lnext = e2;
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(e.prototype, "Lprev", {
      get: function() {
        return this.Onext.Sym;
      },
      set: function(e2) {
        this.Onext.Sym = e2;
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(e.prototype, "Dprev", {
      get: function() {
        return this.Lnext.Sym;
      },
      set: function(e2) {
        this.Lnext.Sym = e2;
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(e.prototype, "Rprev", {
      get: function() {
        return this.Sym.Onext;
      },
      set: function(e2) {
        this.Sym.Onext = e2;
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(e.prototype, "Dnext", {
      get: function() {
        return this.Sym.Onext.Sym;
      },
      set: function(e2) {
        this.Sym.Onext.Sym = e2;
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(e.prototype, "Rnext", {
      get: function() {
        return this.Sym.Lnext.Sym;
      },
      set: function(e2) {
        this.Sym.Lnext.Sym = e2;
      },
      enumerable: true,
      configurable: true
    }), e;
  }(), TESSvertex = function() {
    this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0;
  }, TESSmesh = function() {
    function e() {
      var e2 = new TESSvertex(), t = new TESSface(), i = new TESShalfEdge(0), r = new TESShalfEdge(1);
      e2.next = e2.prev = e2, e2.anEdge = null, t.next = t.prev = t, i.next = i, i.Sym = r, r.next = r, r.Sym = i, this.vHead = e2, this.fHead = t, this.eHead = i, this.eHeadSym = r;
    }
    return e.prototype.makeEdge_ = function(e2) {
      var t = new TESShalfEdge(0), i = new TESShalfEdge(1);
      e2.Sym.side < e2.side && (e2 = e2.Sym);
      var r = e2.Sym.next;
      return i.next = r, r.Sym.next = t, t.next = e2, e2.Sym.next = i, t.Sym = i, t.Onext = t, t.Lnext = i, t.Org = null, t.Lface = null, t.winding = 0, t.activeRegion = null, i.Sym = t, i.Onext = i, i.Lnext = t, i.Org = null, i.Lface = null, i.winding = 0, i.activeRegion = null, t;
    }, e.prototype.splice_ = function(e2, t) {
      var i = e2.Onext, r = t.Onext;
      i.Sym.Lnext = t, r.Sym.Lnext = e2, e2.Onext = r, t.Onext = i;
    }, e.prototype.makeVertex_ = function(e2, t, i) {
      var r = e2;
      assert(r, "Vertex can't be null!");
      var n = i.prev;
      r.prev = n, n.next = r, r.next = i, i.prev = r, r.anEdge = t;
      var o = t;
      do {
        o.Org = r, o = o.Onext;
      } while (o !== t);
    }, e.prototype.makeFace_ = function(e2, t, i) {
      var r = e2;
      assert(r, "Face can't be null");
      var n = i.prev;
      r.prev = n, n.next = r, r.next = i, i.prev = r, r.anEdge = t, r.trail = null, r.marked = false, r.inside = i.inside;
      var o = t;
      do {
        o.Lface = r, o = o.Lnext;
      } while (o !== t);
    }, e.prototype.killEdge_ = function(e2) {
      e2.Sym.side < e2.side && (e2 = e2.Sym);
      var t = e2.next, i = e2.Sym.next;
      t.Sym.next = i, i.Sym.next = t;
    }, e.prototype.killVertex_ = function(e2, t) {
      var i = e2.anEdge, r = i;
      do {
        r.Org = t, r = r.Onext;
      } while (r !== i);
      var n = e2.prev, o = e2.next;
      o.prev = n, n.next = o;
    }, e.prototype.killFace_ = function(e2, t) {
      var i = e2.anEdge, r = i;
      do {
        r.Lface = t, r = r.Lnext;
      } while (r !== i);
      var n = e2.prev, o = e2.next;
      o.prev = n, n.next = o;
    }, e.prototype.makeEdge = function() {
      var e2 = new TESSvertex(), t = new TESSvertex(), i = new TESSface(), r = this.makeEdge_(this.eHead);
      return this.makeVertex_(e2, r, this.vHead), this.makeVertex_(t, r.Sym, this.vHead), this.makeFace_(i, r, this.fHead), r;
    }, e.prototype.splice = function(e2, t) {
      var i = false, r = false;
      if (e2 !== t) {
        if (t.Org !== e2.Org && (r = true, this.killVertex_(t.Org, e2.Org)), t.Lface !== e2.Lface && (i = true, this.killFace_(t.Lface, e2.Lface)), this.splice_(t, e2), !r) {
          var n = new TESSvertex();
          this.makeVertex_(n, t, e2.Org), e2.Org.anEdge = e2;
        }
        if (!i) {
          var o = new TESSface();
          this.makeFace_(o, t, e2.Lface), e2.Lface.anEdge = e2;
        }
      }
    }, e.prototype.delete = function(e2) {
      var t = e2.Sym, i = false;
      if (e2.Lface !== e2.Rface && (i = true, this.killFace_(e2.Lface, e2.Rface)), e2.Onext === e2)
        this.killVertex_(e2.Org, null);
      else if (e2.Rface.anEdge = e2.Oprev, e2.Org.anEdge = e2.Onext, this.splice_(e2, e2.Oprev), !i) {
        var r = new TESSface();
        this.makeFace_(r, e2, e2.Lface);
      }
      t.Onext === t ? (this.killVertex_(t.Org, null), this.killFace_(t.Lface, null)) : (e2.Lface.anEdge = t.Oprev, t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), this.killEdge_(e2);
    }, e.prototype.addEdgeVertex = function(e2) {
      var t = this.makeEdge_(e2), i = t.Sym;
      this.splice_(t, e2.Lnext), t.Org = e2.Dst;
      var r = new TESSvertex();
      return this.makeVertex_(r, i, t.Org), t.Lface = i.Lface = e2.Lface, t;
    }, e.prototype.splitEdge = function(e2) {
      var t = this.addEdgeVertex(e2).Sym;
      return this.splice_(e2.Sym, e2.Sym.Oprev), this.splice_(e2.Sym, t), e2.Dst = t.Org, t.Dst.anEdge = t.Sym, t.Rface = e2.Rface, t.winding = e2.winding, t.Sym.winding = e2.Sym.winding, t;
    }, e.prototype.connect = function(e2, t) {
      var i = false, r = this.makeEdge_(e2), n = r.Sym;
      if (t.Lface !== e2.Lface && (i = true, this.killFace_(t.Lface, e2.Lface)), this.splice_(r, e2.Lnext), this.splice_(n, t), r.Org = e2.Dst, n.Org = t.Org, r.Lface = n.Lface = e2.Lface, e2.Lface.anEdge = n, !i) {
        var o = new TESSface();
        this.makeFace_(o, r, e2.Lface);
      }
      return r;
    }, e.prototype.zapFace = function(e2) {
      var t, i, r, n, o, a = e2.anEdge;
      i = a.Lnext;
      do {
        i = (t = i).Lnext, t.Lface = null, null === t.Rface && (t.Onext === t ? this.killVertex_(t.Org, null) : (t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev)), (r = t.Sym).Onext === r ? this.killVertex_(r.Org, null) : (r.Org.anEdge = r.Onext, this.splice_(r, r.Oprev)), this.killEdge_(t));
      } while (t != a);
      n = e2.prev, (o = e2.next).prev = n, n.next = o;
    }, e.prototype.countFaceVerts_ = function(e2) {
      var t = e2.anEdge, i = 0;
      do {
        i++, t = t.Lnext;
      } while (t !== e2.anEdge);
      return i;
    }, e.prototype.mergeConvexFaces = function(e2) {
      var t, i, r, n, o;
      for (t = this.fHead.next; t !== this.fHead; t = t.next)
        if (t.inside)
          for (o = (i = t.anEdge).Org; r = i.Lnext, (n = i.Sym) && n.Lface && n.Lface.inside && this.countFaceVerts_(t) + this.countFaceVerts_(n.Lface) - 2 <= e2 && Geom.vertCCW(i.Lprev.Org, i.Org, n.Lnext.Lnext.Org) && Geom.vertCCW(n.Lprev.Org, n.Org, i.Lnext.Lnext.Org) && (r = n.Lnext, this.delete(n), i = null, n = null), !i || i.Lnext.Org !== o; )
            i = r;
      return true;
    }, e.prototype.check = function() {
      var e2, t, i, r, n, o, a = this.fHead, s = this.vHead, l = this.eHead;
      for (t = a, t = a; (e2 = t.next) !== a; t = e2) {
        assert(e2.prev === t), n = e2.anEdge;
        do {
          assert(n.Sym !== n), assert(n.Sym.Sym === n), assert(n.Lnext.Onext.Sym === n), assert(n.Onext.Sym.Lnext === n), assert(n.Lface === e2), n = n.Lnext;
        } while (n !== e2.anEdge);
      }
      for (assert(e2.prev === t && null === e2.anEdge), r = s, r = s; (i = r.next) !== s; r = i) {
        assert(i.prev === r), n = i.anEdge;
        do {
          assert(n.Sym !== n), assert(n.Sym.Sym === n), assert(n.Lnext.Onext.Sym === n), assert(n.Onext.Sym.Lnext === n), assert(n.Org === i), n = n.Onext;
        } while (n !== i.anEdge);
      }
      for (assert(i.prev === r && null === i.anEdge), o = l, o = l; (n = o.next) !== l; o = n)
        assert(n.Sym.next === o.Sym), assert(n.Sym !== n), assert(n.Sym.Sym === n), assert(null !== n.Org), assert(null !== n.Dst), assert(n.Lnext.Onext.Sym === n), assert(n.Onext.Sym.Lnext === n);
      assert(
        n.Sym.next === o.Sym && n.Sym === this.eHeadSym && n.Sym.Sym === n && null === n.Org && null === n.Dst && null === n.Lface && null === n.Rface
      );
    }, e;
  }(), PQnode = function() {
    this.handle = null;
  }, PQhandleElem = function() {
    this.key = null, this.node = 0;
  }, PriorityQ = function() {
    function e(e2, t) {
      this.leq = t, this.max = 0, this.nodes = [], this.handles = [], this.initialized = false, this.freeList = 0, this.size = 0, this.max = e2, this.nodes = [], this.handles = [];
      for (var i = 0; i < e2 + 1; i++)
        this.nodes[i] = new PQnode(), this.handles[i] = new PQhandleElem();
      this.initialized = false, this.nodes[1].handle = 1, this.handles[1].key = null;
    }
    return e.prototype.floatDown_ = function(e2) {
      var t, i, r, n = this.nodes, o = this.handles;
      for (t = n[e2].handle; ; ) {
        if ((r = e2 << 1) < this.size && this.leq(o[n[r + 1].handle].key, o[n[r].handle].key) && ++r, assert(r <= this.max), i = n[r].handle, r > this.size || this.leq(o[t].key, o[i].key)) {
          n[e2].handle = t, o[t].node = e2;
          break;
        }
        n[e2].handle = i, o[i].node = e2, e2 = r;
      }
    }, e.prototype.floatUp_ = function(e2) {
      var t, i, r, n = this.nodes, o = this.handles;
      for (t = n[e2].handle; ; ) {
        if (i = n[r = e2 >> 1].handle, 0 === r || this.leq(o[i].key, o[t].key)) {
          n[e2].handle = t, o[t].node = e2;
          break;
        }
        n[e2].handle = i, o[i].node = e2, e2 = r;
      }
    }, e.prototype.init = function() {
      for (var e2 = this.size; e2 >= 1; --e2) this.floatDown_(e2);
      this.initialized = true;
    }, e.prototype.min = function() {
      return this.handles[this.nodes[1].handle].key;
    }, e.prototype.insert = function(e2) {
      var t, i;
      if (2 * (t = ++this.size) > this.max) {
        var r, n;
        for (this.max *= 2, n = this.nodes.length, this.nodes.length = this.max + 1, r = n; r < this.nodes.length; r++)
          this.nodes[r] = new PQnode();
        for (n = this.handles.length, this.handles.length = this.max + 1, r = n; r < this.handles.length; r++)
          this.handles[r] = new PQhandleElem();
      }
      return 0 === this.freeList ? i = t : (i = this.freeList, this.freeList = this.handles[i].node), this.nodes[t].handle = i, this.handles[i].node = t, this.handles[i].key = e2, this.initialized && this.floatUp_(t), i;
    }, e.prototype.extractMin = function() {
      var e2 = this.nodes, t = this.handles, i = e2[1].handle, r = t[i].key;
      return this.size > 0 && (e2[1].handle = e2[this.size].handle, t[e2[1].handle].node = 1, t[i].key = null, t[i].node = this.freeList, this.freeList = i, --this.size, this.size > 0 && this.floatDown_(1)), r;
    }, e.prototype.delete = function(e2) {
      var t, i = this.nodes, r = this.handles;
      assert(e2 >= 1 && e2 <= this.max && null !== r[e2].key), i[t = r[e2].node].handle = i[this.size].handle, r[i[t].handle].node = t, --this.size, t <= this.size && (t <= 1 || this.leq(r[i[t >> 1].handle].key, r[i[t].handle].key) ? this.floatDown_(t) : this.floatUp_(t)), r[e2].key = null, r[e2].node = this.freeList, this.freeList = e2;
    }, e;
  }(), ActiveRegion = function() {
    this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = false, this.sentinel = false, this.dirty = false, this.fixUpperEdge = false;
  }, DictNode = function() {
    this.key = null, this.next = null, this.prev = null;
  }, Dict = function() {
    function e(e2, t) {
      this.frame = e2, this.leq = t, this.head = new DictNode(), this.head.next = this.head, this.head.prev = this.head;
    }
    return e.prototype.min = function() {
      return this.head.next;
    }, e.prototype.max = function() {
      return this.head.prev;
    }, e.prototype.insert = function(e2) {
      return this.insertBefore(this.head, e2);
    }, e.prototype.search = function(e2) {
      var t = this.head;
      do {
        t = t.next;
      } while (null !== t.key && !this.leq(this.frame, e2, t.key));
      return t;
    }, e.prototype.insertBefore = function(e2, t) {
      do {
        e2 = e2.prev;
      } while (null !== e2.key && !this.leq(this.frame, e2.key, t));
      var i = new DictNode();
      return i.key = t, i.next = e2.next, e2.next.prev = i, i.prev = e2, e2.next = i, i;
    }, e.prototype.delete = function(e2) {
      e2.next.prev = e2.prev, e2.prev.next = e2.next;
    }, e;
  }(), Sweep = function() {
    function e() {
    }
    return e.regionBelow = function(e2) {
      return e2.nodeUp.prev.key;
    }, e.regionAbove = function(e2) {
      return e2.nodeUp.next.key;
    }, e.debugEvent = function(e2) {
    }, e.addWinding = function(e2, t) {
      e2.winding += t.winding, e2.Sym.winding += t.Sym.winding;
    }, e.edgeLeq = function(e2, t, i) {
      var r = e2.event, n = t.eUp, o = i.eUp;
      return n.Dst === r ? o.Dst === r ? Geom.vertLeq(n.Org, o.Org) ? Geom.edgeSign(o.Dst, n.Org, o.Org) <= 0 : Geom.edgeSign(n.Dst, o.Org, n.Org) >= 0 : Geom.edgeSign(o.Dst, r, o.Org) <= 0 : o.Dst === r ? Geom.edgeSign(n.Dst, r, n.Org) >= 0 : Geom.edgeEval(n.Dst, r, n.Org) >= Geom.edgeEval(o.Dst, r, o.Org);
    }, e.deleteRegion = function(e2, t) {
      t.fixUpperEdge && assert(0 === t.eUp.winding), t.eUp.activeRegion = null, e2.dict.delete(t.nodeUp);
    }, e.fixUpperEdge = function(e2, t, i) {
      assert(t.fixUpperEdge), e2.mesh.delete(t.eUp), t.fixUpperEdge = false, t.eUp = i, i.activeRegion = t;
    }, e.topLeftRegion = function(t, i) {
      var r, n = i.eUp.Org;
      do {
        i = e.regionAbove(i);
      } while (i.eUp.Org === n);
      if (i.fixUpperEdge) {
        if (null === (r = t.mesh.connect(e.regionBelow(i).eUp.Sym, i.eUp.Lnext)))
          return null;
        e.fixUpperEdge(t, i, r), i = e.regionAbove(i);
      }
      return i;
    }, e.topRightRegion = function(t) {
      var i = t.eUp.Dst;
      do {
        t = e.regionAbove(t);
      } while (t.eUp.Dst === i);
      return t;
    }, e.addRegionBelow = function(e2, t, i) {
      var r = new ActiveRegion();
      return r.eUp = i, r.nodeUp = e2.dict.insertBefore(t.nodeUp, r), r.fixUpperEdge = false, r.sentinel = false, r.dirty = false, i.activeRegion = r, r;
    }, e.isWindingInside = function(e2, t) {
      switch (e2.windingRule) {
        case WINDING.ODD:
          return 0 != (1 & t);
        case WINDING.NONZERO:
          return 0 !== t;
        case WINDING.POSITIVE:
          return t > 0;
        case WINDING.NEGATIVE:
          return t < 0;
        case WINDING.ABS_GEQ_TWO:
          return t >= 2 || t <= -2;
      }
      throw new Error("Invalid winding rulle");
    }, e.computeWinding = function(t, i) {
      i.windingNumber = e.regionAbove(i).windingNumber + i.eUp.winding, i.inside = e.isWindingInside(t, i.windingNumber);
    }, e.finishRegion = function(t, i) {
      var r = i.eUp, n = r.Lface;
      n.inside = i.inside, n.anEdge = r, e.deleteRegion(t, i);
    }, e.finishLeftRegions = function(t, i, r) {
      for (var n, o = null, a = i, s = i.eUp; a !== r; ) {
        if (a.fixUpperEdge = false, (n = (o = e.regionBelow(a)).eUp).Org != s.Org) {
          if (!o.fixUpperEdge) {
            e.finishRegion(t, a);
            break;
          }
          n = t.mesh.connect(s.Lprev, n.Sym), e.fixUpperEdge(t, o, n);
        }
        s.Onext !== n && (t.mesh.splice(n.Oprev, n), t.mesh.splice(s, n)), e.finishRegion(t, a), s = o.eUp, a = o;
      }
      return s;
    }, e.addRightEdges = function(t, i, r, n, o, a) {
      var s, l, c, u, h = true;
      c = r;
      do {
        assert(Geom.vertLeq(c.Org, c.Dst)), e.addRegionBelow(t, i, c.Sym), c = c.Onext;
      } while (c !== n);
      for (null === o && (o = e.regionBelow(i).eUp.Rprev), l = i, u = o; (c = (s = e.regionBelow(l)).eUp.Sym).Org === u.Org; )
        c.Onext !== u && (t.mesh.splice(c.Oprev, c), t.mesh.splice(u.Oprev, c)), s.windingNumber = l.windingNumber - c.winding, s.inside = e.isWindingInside(t, s.windingNumber), l.dirty = true, !h && e.checkForRightSplice(t, l) && (e.addWinding(c, u), e.deleteRegion(t, l), t.mesh.delete(u)), h = false, l = s, u = c;
      l.dirty = true, assert(l.windingNumber - c.winding === s.windingNumber), a && e.walkDirtyRegions(t, l);
    }, e.spliceMergeVertices = function(e2, t, i) {
      e2.mesh.splice(t, i);
    }, e.vertexWeights = function(e2, t, i) {
      var r = Geom.vertL1dist(t, e2), n = Geom.vertL1dist(i, e2), o = 0.5 * n / (r + n), a = 0.5 * r / (r + n);
      e2.coords[0] += o * t.coords[0] + a * i.coords[0], e2.coords[1] += o * t.coords[1] + a * i.coords[1], e2.coords[2] += o * t.coords[2] + a * i.coords[2];
    }, e.getIntersectData = function(t, i, r, n, o, a) {
      i.coords[0] = i.coords[1] = i.coords[2] = 0, i.idx = -1, e.vertexWeights(i, r, n), e.vertexWeights(i, o, a);
    }, e.checkForRightSplice = function(t, i) {
      var r = e.regionBelow(i), n = i.eUp, o = r.eUp;
      if (Geom.vertLeq(n.Org, o.Org)) {
        if (Geom.edgeSign(o.Dst, n.Org, o.Org) > 0) return false;
        Geom.vertEq(n.Org, o.Org) ? n.Org !== o.Org && (t.pq.delete(n.Org.pqHandle), e.spliceMergeVertices(t, o.Oprev, n)) : (t.mesh.splitEdge(o.Sym), t.mesh.splice(n, o.Oprev), i.dirty = r.dirty = true);
      } else {
        if (Geom.edgeSign(n.Dst, o.Org, n.Org) < 0) return false;
        e.regionAbove(i).dirty = i.dirty = true, t.mesh.splitEdge(n.Sym), t.mesh.splice(o.Oprev, n);
      }
      return true;
    }, e.checkForLeftSplice = function(t, i) {
      var r, n = e.regionBelow(i), o = i.eUp, a = n.eUp;
      if (assert(!Geom.vertEq(o.Dst, a.Dst)), Geom.vertLeq(o.Dst, a.Dst)) {
        if (Geom.edgeSign(o.Dst, a.Dst, o.Org) < 0) return false;
        e.regionAbove(i).dirty = i.dirty = true, r = t.mesh.splitEdge(o), t.mesh.splice(a.Sym, r), r.Lface.inside = i.inside;
      } else {
        if (Geom.edgeSign(a.Dst, o.Dst, a.Org) > 0) return false;
        i.dirty = n.dirty = true, r = t.mesh.splitEdge(a), t.mesh.splice(o.Lnext, a.Sym), r.Rface.inside = i.inside;
      }
      return true;
    }, e.checkForIntersect = function(t, i) {
      var r, n, o = e.regionBelow(i), a = i.eUp, s = o.eUp, l = a.Org, c = s.Org, u = a.Dst, h = s.Dst, d = new TESSvertex();
      if (assert(!Geom.vertEq(h, u)), assert(Geom.edgeSign(u, t.event, l) <= 0), assert(Geom.edgeSign(h, t.event, c) >= 0), assert(l !== t.event && c !== t.event), assert(!i.fixUpperEdge && !o.fixUpperEdge), l === c)
        return false;
      if (Math.min(l.t, u.t) > Math.max(c.t, h.t)) return false;
      if (Geom.vertLeq(l, c)) {
        if (Geom.edgeSign(h, l, c) > 0) return false;
      } else if (Geom.edgeSign(u, c, l) < 0) return false;
      return e.debugEvent(t), Geom.intersect(u, l, h, c, d), assert(Math.min(l.t, u.t) <= d.t), assert(d.t <= Math.max(c.t, h.t)), assert(Math.min(h.s, u.s) <= d.s), assert(d.s <= Math.max(c.s, l.s)), Geom.vertLeq(d, t.event) && (d.s = t.event.s, d.t = t.event.t), r = Geom.vertLeq(l, c) ? l : c, Geom.vertLeq(r, d) && (d.s = r.s, d.t = r.t), Geom.vertEq(d, l) || Geom.vertEq(d, c) ? (e.checkForRightSplice(t, i), false) : !Geom.vertEq(u, t.event) && Geom.edgeSign(u, t.event, d) >= 0 || !Geom.vertEq(h, t.event) && Geom.edgeSign(h, t.event, d) <= 0 ? h === t.event ? (t.mesh.splitEdge(a.Sym), t.mesh.splice(s.Sym, a), i = e.topLeftRegion(t, i), a = e.regionBelow(i).eUp, e.finishLeftRegions(t, e.regionBelow(i), o), e.addRightEdges(t, i, a.Oprev, a, a, true), true) : u === t.event ? (t.mesh.splitEdge(s.Sym), t.mesh.splice(a.Lnext, s.Oprev), o = i, i = e.topRightRegion(i), n = e.regionBelow(i).eUp.Rprev, o.eUp = s.Oprev, s = e.finishLeftRegions(t, o, null), e.addRightEdges(t, i, s.Onext, a.Rprev, n, true), true) : (Geom.edgeSign(u, t.event, d) >= 0 && (e.regionAbove(i).dirty = i.dirty = true, t.mesh.splitEdge(a.Sym), a.Org.s = t.event.s, a.Org.t = t.event.t), Geom.edgeSign(h, t.event, d) <= 0 && (i.dirty = o.dirty = true, t.mesh.splitEdge(s.Sym), s.Org.s = t.event.s, s.Org.t = t.event.t), false) : (t.mesh.splitEdge(a.Sym), t.mesh.splitEdge(s.Sym), t.mesh.splice(s.Oprev, a), a.Org.s = d.s, a.Org.t = d.t, a.Org.pqHandle = t.pq.insert(a.Org), e.getIntersectData(t, a.Org, l, u, c, h), e.regionAbove(i).dirty = i.dirty = o.dirty = true, false);
    }, e.walkDirtyRegions = function(t, i) {
      for (var r, n, o = e.regionBelow(i); ; ) {
        for (; o.dirty; ) i = o, o = e.regionBelow(o);
        if (!i.dirty && (o = i, null === (i = e.regionAbove(i)) || !i.dirty))
          return;
        if (i.dirty = false, r = i.eUp, n = o.eUp, r.Dst !== n.Dst && e.checkForLeftSplice(t, i) && (o.fixUpperEdge ? (e.deleteRegion(t, o), t.mesh.delete(n), n = (o = e.regionBelow(i)).eUp) : i.fixUpperEdge && (e.deleteRegion(t, i), t.mesh.delete(r), r = (i = e.regionAbove(o)).eUp)), r.Org !== n.Org) {
          if (r.Dst === n.Dst || i.fixUpperEdge || o.fixUpperEdge || r.Dst !== t.event && n.Dst !== t.event)
            e.checkForRightSplice(t, i);
          else if (e.checkForIntersect(t, i)) return;
        }
        r.Org === n.Org && r.Dst === n.Dst && (e.addWinding(n, r), e.deleteRegion(t, i), t.mesh.delete(r), i = e.regionAbove(o));
      }
    }, e.connectRightVertex = function(t, i, r) {
      var n, o = r.Onext, a = e.regionBelow(i), s = i.eUp, l = a.eUp, c = false;
      s.Dst !== l.Dst && e.checkForIntersect(t, i), Geom.vertEq(s.Org, t.event) && (t.mesh.splice(o.Oprev, s), i = e.topLeftRegion(t, i), o = e.regionBelow(i).eUp, e.finishLeftRegions(t, e.regionBelow(i), a), c = true), Geom.vertEq(l.Org, t.event) && (t.mesh.splice(r, l.Oprev), r = e.finishLeftRegions(t, a, null), c = true), c ? e.addRightEdges(t, i, r.Onext, o, o, true) : (n = Geom.vertLeq(l.Org, s.Org) ? l.Oprev : s, n = t.mesh.connect(r.Lprev, n), e.addRightEdges(t, i, n, n.Onext, n.Onext, false), n.Sym.activeRegion.fixUpperEdge = true, e.walkDirtyRegions(t, i));
    }, e.connectLeftDegenerate = function(t, i, r) {
      var n, o, a, s, l;
      return n = i.eUp, Geom.vertEq(n.Org, r) ? (assert(false), void e.spliceMergeVertices(t, n, r.anEdge)) : Geom.vertEq(n.Dst, r) ? (assert(false), i = e.topRightRegion(i), o = s = (a = (l = e.regionBelow(i)).eUp.Sym).Onext, l.fixUpperEdge && (assert(o !== a), e.deleteRegion(t, l), t.mesh.delete(a), a = o.Oprev), t.mesh.splice(r.anEdge, a), Geom.edgeGoesLeft(o) || (o = null), void e.addRightEdges(t, i, a.Onext, s, o, true)) : (t.mesh.splitEdge(n.Sym), i.fixUpperEdge && (t.mesh.delete(n.Onext), i.fixUpperEdge = false), t.mesh.splice(r.anEdge, n), void e.sweepEvent(t, r));
    }, e.connectLeftVertex = function(t, i) {
      var r, n, o, a, s, l, c = new ActiveRegion();
      if (c.eUp = i.anEdge.Sym, r = t.dict.search(c).key, n = e.regionBelow(r))
        if (a = r.eUp, s = n.eUp, 0 !== Geom.edgeSign(a.Dst, i, a.Org))
          if (o = Geom.vertLeq(s.Dst, a.Dst) ? r : n, r.inside || o.fixUpperEdge) {
            if (o === r) l = t.mesh.connect(i.anEdge.Sym, a.Lnext);
            else l = t.mesh.connect(s.Dnext, i.anEdge).Sym;
            o.fixUpperEdge ? e.fixUpperEdge(t, o, l) : e.computeWinding(t, e.addRegionBelow(t, r, l)), e.sweepEvent(t, i);
          } else e.addRightEdges(t, r, i.anEdge, i.anEdge, null, true);
        else e.connectLeftDegenerate(t, r, i);
    }, e.sweepEvent = function(t, i) {
      t.event = i, e.debugEvent(t);
      for (var r = i.anEdge; null === r.activeRegion; )
        if ((r = r.Onext) === i.anEdge)
          return void e.connectLeftVertex(t, i);
      var n = e.topLeftRegion(t, r.activeRegion);
      assert(null !== n);
      var o = e.regionBelow(n), a = o.eUp, s = e.finishLeftRegions(t, o, null);
      s.Onext === a ? e.connectRightVertex(t, n, s) : e.addRightEdges(t, n, s.Onext, a, a, true);
    }, e.addSentinel = function(e2, t, i, r) {
      var n = new ActiveRegion(), o = e2.mesh.makeEdge();
      o.Org.s = i, o.Org.t = r, o.Dst.s = t, o.Dst.t = r, e2.event = o.Dst, n.eUp = o, n.windingNumber = 0, n.inside = false, n.fixUpperEdge = false, n.sentinel = true, n.dirty = false, n.nodeUp = e2.dict.insert(n);
    }, e.initEdgeDict = function(t) {
      t.dict = new Dict(t, e.edgeLeq);
      var i = t.bmax[0] - t.bmin[0], r = t.bmax[1] - t.bmin[1], n = t.bmin[0] - i, o = t.bmax[0] + i, a = t.bmin[1] - r, s = t.bmax[1] + r;
      e.addSentinel(t, n, o, a), e.addSentinel(t, n, o, s);
    }, e.doneEdgeDict = function(t) {
      for (var i, r = 0; null !== (i = t.dict.min().key); )
        i.sentinel || (assert(i.fixUpperEdge), assert(1 == ++r)), assert(0 === i.windingNumber), e.deleteRegion(t, i);
    }, e.removeDegenerateEdges = function(t) {
      var i, r, n, o = t.mesh.eHead;
      for (i = o.next; i !== o; i = r)
        r = i.next, n = i.Lnext, Geom.vertEq(i.Org, i.Dst) && i.Lnext.Lnext !== i && (e.spliceMergeVertices(t, n, i), t.mesh.delete(i), n = (i = n).Lnext), n.Lnext === i && (n !== i && (n !== r && n !== r.Sym || (r = r.next), t.mesh.delete(n)), i !== r && i !== r.Sym || (r = r.next), t.mesh.delete(i));
    }, e.initPriorityQ = function(e2) {
      var t, i, r, n = 0;
      for (i = (r = e2.mesh.vHead).next; i !== r; i = i.next) n++;
      for (n += 8, t = e2.pq = new PriorityQ(n, Geom.vertLeq), i = (r = e2.mesh.vHead).next; i !== r; i = i.next)
        i.pqHandle = t.insert(i);
      return i === r && (t.init(), true);
    }, e.donePriorityQ = function(e2) {
      e2.pq = null;
    }, e.removeDegenerateFaces = function(t, i) {
      var r, n, o;
      for (r = i.fHead.next; r !== i.fHead; r = n)
        n = r.next, assert((o = r.anEdge).Lnext !== o), o.Lnext.Lnext === o && (e.addWinding(o.Onext, o), t.mesh.delete(o));
      return true;
    }, e.computeInterior = function(t, i) {
      var r, n;
      if (void 0 === i && (i = true), e.removeDegenerateEdges(t), !e.initPriorityQ(t))
        return false;
      for (e.initEdgeDict(t); null !== (r = t.pq.extractMin()); ) {
        for (; null !== (n = t.pq.min()) && Geom.vertEq(n, r); )
          n = t.pq.extractMin(), e.spliceMergeVertices(t, r.anEdge, n.anEdge);
        e.sweepEvent(t, r);
      }
      return t.event = t.dict.min().key.eUp.Org, e.debugEvent(t), e.doneEdgeDict(t), e.donePriorityQ(t), !!e.removeDegenerateFaces(t, t.mesh) && (i && t.mesh.check(), true);
    }, e;
  }(), Tesselator = function() {
    function e() {
      this.mesh = new TESSmesh(), this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = WINDING.ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0;
    }
    return e.prototype.dot_ = function(e2, t) {
      return e2[0] * t[0] + e2[1] * t[1] + e2[2] * t[2];
    }, e.prototype.normalize_ = function(e2) {
      var t = e2[0] * e2[0] + e2[1] * e2[1] + e2[2] * e2[2];
      if (!t) throw "Zero-size vector!";
      t = Math.sqrt(t), e2[0] /= t, e2[1] /= t, e2[2] /= t;
    }, e.prototype.longAxis_ = function(e2) {
      var t = 0;
      return Math.abs(e2[1]) > Math.abs(e2[0]) && (t = 1), Math.abs(e2[2]) > Math.abs(e2[t]) && (t = 2), t;
    }, e.prototype.computeNormal_ = function(e2) {
      var t, i, r, n, o, a, s = [0, 0, 0], l = [0, 0, 0], c = [0, 0, 0], u = [0, 0, 0], h = [0, 0, 0], d = [null, null, null], f = [null, null, null], p = this.mesh.vHead;
      t = p.next;
      for (var v = 0; v < 3; ++v)
        n = t.coords[v], l[v] = n, f[v] = t, s[v] = n, d[v] = t;
      for (t = p.next; t !== p; t = t.next)
        for (var m = 0; m < 3; ++m)
          (n = t.coords[m]) < l[m] && (l[m] = n, f[m] = t), n > s[m] && (s[m] = n, d[m] = t);
      var g = 0;
      if (s[1] - l[1] > s[0] - l[0] && (g = 1), s[2] - l[2] > s[g] - l[g] && (g = 2), l[g] >= s[g])
        return e2[0] = 0, e2[1] = 0, void (e2[2] = 1);
      for (a = 0, i = f[g], r = d[g], c[0] = i.coords[0] - r.coords[0], c[1] = i.coords[1] - r.coords[1], c[2] = i.coords[2] - r.coords[2], t = p.next; t !== p; t = t.next)
        u[0] = t.coords[0] - r.coords[0], u[1] = t.coords[1] - r.coords[1], u[2] = t.coords[2] - r.coords[2], h[0] = c[1] * u[2] - c[2] * u[1], h[1] = c[2] * u[0] - c[0] * u[2], h[2] = c[0] * u[1] - c[1] * u[0], (o = h[0] * h[0] + h[1] * h[1] + h[2] * h[2]) > a && (a = o, e2[0] = h[0], e2[1] = h[1], e2[2] = h[2]);
      a <= 0 && (e2[0] = e2[1] = e2[2] = 0, e2[this.longAxis_(c)] = 1);
    }, e.prototype.checkOrientation_ = function() {
      for (var e2, t, i = this.mesh.fHead, r = this.mesh.vHead, n = 0, o = i.next; o !== i; o = o.next)
        if (!((t = o.anEdge).winding <= 0))
          do {
            n += (t.Org.s - t.Dst.s) * (t.Org.t + t.Dst.t), t = t.Lnext;
          } while (t !== o.anEdge);
      if (n < 0) {
        for (e2 = r.next; e2 !== r; e2 = e2.next) e2.t = -e2.t;
        this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2];
      }
    }, e.prototype.projectPolygon_ = function() {
      var e2, t, i = this.mesh.vHead, r = [0, 0, 0], n = false;
      r[0] = this.normal[0], r[1] = this.normal[1], r[2] = this.normal[2], r[0] || r[1] || r[2] || (this.computeNormal_(r), n = true), e2 = this.sUnit, t = this.tUnit;
      var o = this.longAxis_(r);
      e2[o] = 0, e2[(o + 1) % 3] = 1, e2[(o + 2) % 3] = 0, t[o] = 0, t[(o + 1) % 3] = 0, t[(o + 2) % 3] = r[o] > 0 ? 1 : -1;
      for (var a = i.next; a !== i; a = a.next)
        a.s = this.dot_(a.coords, e2), a.t = this.dot_(a.coords, t);
      n && this.checkOrientation_();
      for (var s = true, l = i.next; l !== i; l = l.next)
        s ? (this.bmin[0] = this.bmax[0] = l.s, this.bmin[1] = this.bmax[1] = l.t, s = false) : (l.s < this.bmin[0] && (this.bmin[0] = l.s), l.s > this.bmax[0] && (this.bmax[0] = l.s), l.t < this.bmin[1] && (this.bmin[1] = l.t), l.t > this.bmax[1] && (this.bmax[1] = l.t));
    }, e.prototype.addWinding_ = function(e2, t) {
      e2.winding += t.winding, e2.Sym.winding += t.Sym.winding;
    }, e.prototype.tessellateMonoRegion_ = function(e2, t) {
      var i, r;
      if ((i = t.anEdge).Lnext === i || i.Lnext.Lnext === i)
        throw "Mono region invalid";
      for (; Geom.vertLeq(i.Dst, i.Org); i = i.Lprev) ;
      for (; Geom.vertLeq(i.Org, i.Dst); i = i.Lnext) ;
      r = i.Lprev;
      for (; i.Lnext !== r; )
        if (Geom.vertLeq(i.Dst, r.Org)) {
          for (; r.Lnext !== i && (Geom.edgeGoesLeft(r.Lnext) || Geom.edgeSign(r.Org, r.Dst, r.Lnext.Dst) <= 0); )
            r = e2.connect(r.Lnext, r).Sym;
          r = r.Lprev;
        } else {
          for (; r.Lnext !== i && (Geom.edgeGoesRight(i.Lprev) || Geom.edgeSign(i.Dst, i.Org, i.Lprev.Org) >= 0); )
            i = e2.connect(i, i.Lprev).Sym;
          i = i.Lnext;
        }
      if (r.Lnext === i) throw "Mono region invalid";
      for (; r.Lnext.Lnext !== i; ) r = e2.connect(r.Lnext, r).Sym;
      return true;
    }, e.prototype.tessellateInterior_ = function(e2) {
      for (var t, i = e2.fHead.next; i !== e2.fHead; i = t)
        if (t = i.next, i.inside && !this.tessellateMonoRegion_(e2, i))
          return false;
      return true;
    }, e.prototype.discardExterior_ = function(e2) {
      for (var t, i = e2.fHead.next; i !== e2.fHead; i = t)
        t = i.next, i.inside || e2.zapFace(i);
    }, e.prototype.setWindingNumber_ = function(e2, t, i) {
      for (var r, n = e2.eHead.next; n !== e2.eHead; n = r)
        r = n.next, n.Rface.inside !== n.Lface.inside ? n.winding = n.Lface.inside ? t : -t : i ? e2.delete(n) : n.winding = 0;
    }, e.prototype.getNeighbourFace_ = function(e2) {
      return e2.Rface && e2.Rface.inside ? e2.Rface.n : -1;
    }, e.prototype.outputPolymesh_ = function(e2, t, i, r) {
      var n, o, a = 0, s = 0;
      i > 3 && e2.mergeConvexFaces(i);
      for (var l = e2.vHead.next; l !== e2.vHead; l = l.next) l.n = -1;
      for (var c = e2.fHead.next; c !== e2.fHead; c = c.next)
        if (c.n = -1, c.inside) {
          n = c.anEdge, o = 0;
          do {
            -1 === (l = n.Org).n && (l.n = s, s++), o++, n = n.Lnext;
          } while (n !== c.anEdge);
          if (o > i) throw "Face vertex greater that support polygon";
          c.n = a, ++a;
        }
      this.elementCount = a, t === ELEMENT.CONNECTED_POLYGONS && (a *= 2), this.elements = [], this.elements.length = a * i, this.vertexCount = s, this.vertices = [], this.vertices.length = s * r, this.vertexIndices = [], this.vertexIndices.length = s;
      for (l = e2.vHead.next; l !== e2.vHead; l = l.next)
        if (-1 !== l.n) {
          var u = l.n * r;
          this.vertices[u + 0] = l.coords[0], this.vertices[u + 1] = l.coords[1], r > 2 && (this.vertices[u + 2] = l.coords[2]), this.vertexIndices[l.n] = l.idx;
        }
      var h = 0;
      for (c = e2.fHead.next; c !== e2.fHead; c = c.next)
        if (c.inside) {
          n = c.anEdge, o = 0;
          do {
            l = n.Org;
            this.elements[h++] = l.n, o++, n = n.Lnext;
          } while (n !== c.anEdge);
          for (var d = o; d < i; ++d) this.elements[h++] = -1;
          if (t === ELEMENT.CONNECTED_POLYGONS) {
            n = c.anEdge;
            do {
              this.elements[h++] = this.getNeighbourFace_(n), n = n.Lnext;
            } while (n !== c.anEdge);
            for (var f = o; f < i; ++f) this.elements[h++] = -1;
          }
        }
    }, e.prototype.outputContours_ = function(e2, t) {
      var i, r, n = 0, o = 0;
      this.vertexCount = 0, this.elementCount = 0;
      for (var a = e2.fHead.next; a !== e2.fHead; a = a.next)
        if (a.inside) {
          r = i = a.anEdge;
          do {
            this.vertexCount++, i = i.Lnext;
          } while (i !== r);
          this.elementCount++;
        }
      this.elements = [], this.elements.length = 2 * this.elementCount, this.vertices = [], this.vertices.length = this.vertexCount * t, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount;
      var s = 0, l = 0, c = 0;
      n = 0;
      for (a = e2.fHead.next; a !== e2.fHead; a = a.next)
        if (a.inside) {
          o = 0, r = i = a.anEdge;
          do {
            this.vertices[s++] = i.Org.coords[0], this.vertices[s++] = i.Org.coords[1], t > 2 && (this.vertices[s++] = i.Org.coords[2]), this.vertexIndices[l++] = i.Org.idx, o++, i = i.Lnext;
          } while (i !== r);
          this.elements[c++] = n, this.elements[c++] = o, n += o;
        }
    }, e.prototype.addContour = function(e2, t) {
      null === this.mesh && (this.mesh = new TESSmesh()), e2 < 2 && (e2 = 2), e2 > 3 && (e2 = 3);
      for (var i = null, r = 0; r < t.length; r += e2)
        null === i ? (i = this.mesh.makeEdge(), this.mesh.splice(i, i.Sym)) : (this.mesh.splitEdge(i), i = i.Lnext), i.Org.coords[0] = t[r + 0], i.Org.coords[1] = t[r + 1], i.Org.coords[2] = e2 > 2 ? t[r + 2] : 0, i.Org.idx = this.vertexIndexCounter++, i.winding = 1, i.Sym.winding = -1;
    }, e.prototype.tesselate = function(e2, t, i, r, n, o) {
      if (void 0 === e2 && (e2 = WINDING.ODD), void 0 === t && (t = ELEMENT.POLYGONS), void 0 === o && (o = true), this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, n && (this.normal[0] = n[0], this.normal[1] = n[1], this.normal[2] = n[2]), this.windingRule = e2, r < 2 && (r = 2), r > 3 && (r = 3), !this.mesh)
        return false;
      this.projectPolygon_(), Sweep.computeInterior(this, o);
      var a = this.mesh;
      return t === ELEMENT.BOUNDARY_CONTOURS ? this.setWindingNumber_(a, 1, true) : this.tessellateInterior_(a), o && a.check(), t === ELEMENT.BOUNDARY_CONTOURS ? this.outputContours_(a, r) : this.outputPolymesh_(a, t, i, r), true;
    }, e;
  }();
  function tesselate(e) {
    var t = e.windingRule, i = void 0 === t ? WINDING.ODD : t, r = e.elementType, n = void 0 === r ? ELEMENT.POLYGONS : r, o = e.polySize, a = void 0 === o ? 3 : o, s = e.vertexSize, l = void 0 === s ? 2 : s, c = e.normal, u = void 0 === c ? [0, 0, 1] : c, h = e.contours, d = void 0 === h ? [] : h, f = e.strict, p = void 0 === f || f, v = e.debug, m = void 0 !== v && v;
    if (!d && p) throw new Error("Contours can't be empty");
    if (d) {
      for (var g = new Tesselator(), E = 0; E < d.length; E++)
        g.addContour(l || 2, d[E]);
      return g.tesselate(i, n, a, l, u, p), {
        vertices: g.vertices,
        vertexIndices: g.vertexIndices,
        vertexCount: g.vertexCount,
        elements: g.elements,
        elementCount: g.elementCount,
        mesh: m ? g.mesh : void 0
      };
    }
  }
  WINDING.ODD;
  WINDING.NONZERO;
  WINDING.POSITIVE;
  WINDING.NEGATIVE;
  WINDING.ABS_GEQ_TWO;
  ELEMENT.POLYGONS;
  ELEMENT.CONNECTED_POLYGONS;
  ELEMENT.BOUNDARY_CONTOURS;
  var VectorSurfaceGeometry = function(e) {
    function t(t2, i, r, n) {
      void 0 === i && (i = 12), void 0 === r && (r = 100), void 0 === n && (n = {});
      var o = e.call(this) || this;
      return o.type = "ShapeGeometry", o.windingRule = WINDING.ODD, o.elementType = ELEMENT.POLYGONS, o.polySize = 3, o.vertexSize = 2, o.strict = true, o._drawCount = 0, o._shape = t2, o._curveSegments = i, o._maxCount = r, o._maxDrawCount = 3 * r, o._triangulationOptions = Object.assign(
        {
          windingRule: WINDING.ODD,
          elementType: ELEMENT.POLYGONS,
          polySize: 3,
          vertexSize: 2,
          strict: true
        },
        n
      ), o._positionAttribute = new THREE.BufferAttribute(
        new Float32Array(3 * r),
        3
      ), o._normalAttribute = new THREE.BufferAttribute(
        new Float32Array(3 * r),
        3
      ), o._uvAttribute = new THREE.BufferAttribute(
        new Float32Array(2 * r),
        2
      ), o._indexAttribute = new THREE.BufferAttribute(
        new Uint32Array(3 * r),
        1
      ), o.setAttribute("position", o._positionAttribute), o.setAttribute("normal", o._normalAttribute), o.setAttribute("uv", o._uvAttribute), o.setIndex(o._indexAttribute), o.updateFromShape(), o;
    }
    return __extends(t, e), t.prototype.copy = function(t2) {
      return this._drawCount = t2.drawCount, this._maxDrawCount = t2._maxDrawCount, this._maxCount = t2.maxCount, e.prototype.copy.call(this, t2);
    }, Object.defineProperty(t.prototype, "curveSegments", {
      get: function() {
        return this._curveSegments;
      },
      set: function(e2) {
        this._curveSegments = e2, this.updateFromShape();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "drawCount", {
      get: function() {
        return this._drawCount;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "maxDrawCount", {
      get: function() {
        return this._maxDrawCount;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "maxCount", {
      get: function() {
        return this._maxCount;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.updateFromShape = function() {
      var e2 = tesselate({
        contours: [
          this._shape.extractShapePointsToFlatArray([], this._curveSegments)
        ],
        windingRule: this._triangulationOptions.windingRule,
        elementType: this._triangulationOptions.elementType,
        polySize: this._triangulationOptions.polySize,
        vertexSize: this._triangulationOptions.vertexSize,
        strict: this._triangulationOptions.strict
      });
      if (e2) {
        this._drawCount = 0;
        for (var t2 = 1 / 0, i = -1 / 0, r = 1 / 0, n = -1 / 0, o = 0, a = e2.vertexCount; o < a; o++) {
          var s = 2 * o;
          (u = e2.vertices[s + 0]) < t2 && (t2 = u), u > i && (i = u), (h = e2.vertices[s + 1]) < r && (r = h), h > n && (n = h);
        }
        var l = i - t2, c = n - r;
        for (o = 0, a = e2.vertexCount; o < a; o++) {
          s = 2 * o;
          var u, h, d = ((u = e2.vertices[s + 0]) - t2) / l, f = ((h = e2.vertices[s + 1]) - r) / c;
          this._positionAttribute.setXYZ(o, u, h, 0), this._normalAttribute.setXYZ(o, 0, 0, 1), this._uvAttribute.setXY(o, d, f);
        }
        for (o = 0, a = e2.elementCount; o < a; o++) {
          var p = 3 * o, v = e2.elements[p + 0], m = e2.elements[p + 1], g = e2.elements[p + 2];
          this._indexAttribute.setX(p + 0, v), this._indexAttribute.setX(p + 1, m), this._indexAttribute.setX(p + 2, g), this._drawCount += 3;
        }
        this._positionAttribute.needsUpdate = true, this._normalAttribute.needsUpdate = true, this._uvAttribute.needsUpdate = true, this._indexAttribute.needsUpdate = true, this.setDrawRange(0, this._drawCount);
      }
      return this._drawCount > this._maxDrawCount;
    }, t;
  }(THREE.BufferGeometry), isCW = function(e) {
    for (var t = 0, i = e.length / 2, r = i - 1, n = 0; n < i; r = n++)
      t += e[2 * r + 0] * e[2 * n + 1] - e[2 * n + 0] * e[2 * r + 1];
    return t < 0;
  }, VectorExtrusionGeometry = function(e) {
    function t(t2, i, r) {
      var n;
      void 0 === r && (r = 12);
      var o = e.call(this) || this;
      o.type = "ShapeGeometry", o._vertCount = 0, o.vertCache = {}, o._shape = t2, o._depth = i;
      var a = o._shape.extractShapePointsToFlatArray([], r), s = tesselate({
        windingRule: WINDING.ODD,
        elementType: ELEMENT.POLYGONS,
        polySize: 3,
        vertexSize: 2,
        strict: true,
        contours: [a]
      });
      if (!s) throw new Error("error generating geometry");
      for (var l = 1 / 0, c = -1 / 0, u = 1 / 0, h = -1 / 0, d = 0, f = s.vertexCount; d < f; d++) {
        var p = 2 * d;
        (E = s.vertices[p + 0]) < l && (l = E), E > c && (c = E), (y = s.vertices[p + 1]) < u && (u = y), y > h && (h = y);
      }
      o._minX = l, o._minY = u, o._width = c - l, o._height = h - u;
      var v = 2 * s.vertexCount + 4 * s.vertexCount + 4 * s.vertexCount;
      o._positions = new Float32Array(3 * v), o._normals = new Float32Array(3 * v), o._uvs = new Float32Array(2 * v), o._indices = new Uint32Array(3 * v);
      var m = 0, g = [];
      for (d = 0, f = s.vertexCount; d < f; d++) {
        var E = s.vertices[2 * d + 0], y = s.vertices[2 * d + 1], A = 3 * (o._vertCount + 0), T = 3 * (o._vertCount + 1), x = 2 * (o._vertCount + 0), _ = 2 * (o._vertCount + 1);
        o._positions[A + 0] = E, o._positions[A + 1] = y, o._positions[A + 2] = i, o._normals[A + 0] = 0, o._normals[A + 1] = 0, o._normals[A + 2] = 1, o._uvs[x + 0] = (E - l) / o._width, o._uvs[x + 1] = (y - u) / o._height, o._positions[T + 0] = E, o._positions[T + 1] = y, o._positions[T + 2] = 0, o._normals[T + 0] = 0, o._normals[T + 1] = 0, o._normals[T + 2] = -1, o._uvs[_ + 0] = (E - l) / o._width, o._uvs[_ + 1] = (y - u) / o._height, g[d] = o._vertCount, o._vertCount += 2;
      }
      for (d = 0, f = s.elementCount; d < f; d++) {
        var w = 3 * d, S = s.elements[w + 0], b = s.elements[w + 1], R = s.elements[w + 2];
        o._indices[m + 0] = g[S] + 0, o._indices[m + 1] = g[b] + 0, o._indices[m + 2] = g[R] + 0, o._indices[m + 3] = g[R] + 1, o._indices[m + 4] = g[b] + 1, o._indices[m + 5] = g[S] + 1, m += 6;
      }
      var C = tesselate({
        windingRule: WINDING.ODD,
        elementType: ELEMENT.BOUNDARY_CONTOURS,
        vertexSize: 2,
        strict: true,
        contours: [a]
      });
      if (!C) throw new Error("error generating geometry");
      var O = false;
      O = 1 === C.elementCount ? !isCW(a) : C.elementCount % 2 == 1;
      for (d = 0, f = C.elementCount; d < f; d++) {
        p = 2 * d;
        var D = C.elements[p + 0], M = C.elements[p + 1], L = D + M, I = L - 2, P = L - 1, B = D, H = D + 1;
        do {
          var N = o.buildVert(C, [I, P, B], "pre", O), F = o.buildVert(C, [P, B, H], "post", O);
          o._indices[m + 0] = F.bottom, o._indices[m + 1] = F.top, o._indices[m + 2] = N.bottom, o._indices[m + 3] = F.top, o._indices[m + 4] = N.top, o._indices[m + 5] = N.bottom, m += 6, I = (n = __read([P, B, H, H + 1], 4))[0], P = n[1], B = n[2], (H = n[3]) >= L && (H -= M);
        } while (B !== D);
        O = !O;
      }
      var G = new THREE.BufferAttribute(
        o._positions.slice(0, 3 * o._vertCount),
        3
      ), U = new THREE.BufferAttribute(
        o._normals.slice(0, 3 * o._vertCount),
        3
      ), z = new THREE.BufferAttribute(o._uvs.slice(0, 2 * o._vertCount), 2), V = new THREE.BufferAttribute(o._indices.slice(0, m), 1);
      return G.needsUpdate = true, U.needsUpdate = true, z.needsUpdate = true, V.needsUpdate = true, o.setAttribute("position", G), o.setAttribute("normal", U), o.setAttribute("uv", z), o.setIndex(V), o;
    }
    return __extends(t, e), t.prototype.buildVert = function(e2, t2, i, r) {
      var n = 1;
      r && (t2.reverse(), i = "pre" === i ? "post" : "pre", n = -1);
      var o, a = __read(t2, 3), s = a[0], l = a[1], c = a[2], u = e2.vertexIndices[l], h = e2.vertices[2 * l + 0], d = e2.vertices[2 * l + 1];
      if (u < 0)
        if ("post" === i) {
          var f = e2.vertices[2 * s + 0], p = e2.vertices[2 * s + 1];
          o = new THREE.Vector2(f - h, p - d).normalize();
        } else {
          var v = e2.vertices[2 * c + 0], m = e2.vertices[2 * c + 1];
          o = new THREE.Vector2(h - v, d - m).normalize();
        }
      else {
        var g = __read(this._shape.getCurveIndexFromVertexId(u - 1), 2), E = g[0], y = g[1], A = this._shape.curves.length, T = y > 0 && y < 1;
        0 === y && "pre" === i ? (E = (E - 1 + A) % A, y = 1) : 1 === y && "post" === i && (E = (E + 1) % A, y = 0);
        var x = "pre" === i ? "post" : "pre", _ = this.vertCache["" + l + x];
        if (_ && T) return _;
        if (o = this._shape.curves[E].getTangent(y), _ && o.dot(_.tangent) > 0.9)
          return _;
      }
      var w = {
        top: this._vertCount + 0,
        bottom: this._vertCount + 1,
        tangent: o
      }, S = 3 * (this._vertCount + 0), b = 3 * (this._vertCount + 1), R = 2 * (this._vertCount + 0), C = 2 * (this._vertCount + 1);
      return this._positions[S + 0] = h, this._positions[S + 1] = d, this._positions[S + 2] = this._depth, this._normals[S + 0] = -o.y * n, this._normals[S + 1] = o.x * n, this._normals[S + 2] = 0, this._uvs[R + 0] = (h - this._minX) / this._width, this._uvs[R + 1] = (d - this._minY) / this._height, this._positions[b + 0] = h, this._positions[b + 1] = d, this._positions[b + 2] = 0, this._normals[b + 0] = -o.y * n, this._normals[b + 1] = o.x * n, this._normals[b + 2] = 0, this._uvs[C + 0] = (h - this._minX) / this._width, this._uvs[C + 1] = (d - this._minY) / this._height, this._vertCount += 2, this.vertCache["" + l + i] = w, w;
    }, t;
  }(THREE.BufferGeometry), VectorGeometry = function() {
    function e() {
    }
    return e.create = function(e2) {
      return this.build(this.normalizeInputs(e2));
    }, e.normalizeInputs = function(e2, t) {
      var i, r, n, o = Object.assign(
        {},
        null !== (i = null == t ? void 0 : t.parameters) && void 0 !== i ? i : {
          width: 100,
          depth: 0,
          subdivisions: 40,
          extrudeDepth: 0,
          surfaceMaxCount: 100
        },
        e2.parameters
      ), a = Math.abs(o.width), s = Math.abs(null !== (r = o.height) && void 0 !== r ? r : o.width), l = null !== (n = e2.shape) && void 0 !== n ? n : null == t ? void 0 : t.shape;
      void 0 !== l && (l instanceof VectorShape ? l.width === a && l.height === s || l.applySize(a, s) : l = new VectorShape(a, s).fromJSON(l));
      var c = null != l ? l : new VectorShape(a, s);
      return {
        parameters: Object.assign(o, { width: a, height: s }),
        shape: c
      };
    }, e.build = function(e2) {
      var t, i = e2.parameters, r = i.extrudeDepth, n = i.subdivisions, o = i.surfaceMaxCount;
      return t = r <= 0 ? new VectorSurfaceGeometry(e2.shape, n, o) : new VectorExtrusionGeometry(e2.shape, r, n), Object.assign(t, {
        userData: __assign(__assign({}, e2), { type: "VectorGeometry" })
      });
    }, e;
  }();
  new THREE.Sphere();
  new THREE.Matrix4();
  new THREE.Ray();
  new THREE.Vector3();
  new THREE.Vector3();
  new THREE.Vector3();
  new THREE.Vector3();
  var VectorLineGeometry = function(e) {
    function t(t2) {
      void 0 === t2 && (t2 = 500);
      var i = e.call(this) || this;
      return i._drawCount = 0, i.positions = new THREE.BufferAttribute(
        new Float32Array(3 * t2),
        3
      ), i.setAttribute("position", i.positions), i;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "drawCount", {
      get: function() {
        return this._drawCount;
      },
      set: function(e2) {
        this._drawCount = e2, this.setDrawRange(0, e2);
      },
      enumerable: false,
      configurable: true
    }), t;
  }(THREE.BufferGeometry), geometries = {
    ConeGeometry,
    CubeGeometry,
    CylinderGeometry,
    DodecahedronGeometry,
    EllipseGeometry,
    HelixGeometry,
    IcosahedronGeometry,
    LatheGeometry,
    NonParametricGeometry,
    PolygonGeometry,
    PyramidGeometry,
    RectangleGeometry,
    SphereGeometry,
    StarGeometry,
    TextFrameGeometry,
    TorusGeometry,
    TorusKnotGeometry,
    TriangleGeometry,
    VectorGeometry
  }, createGeometry = function(e) {
    return geometries[e.type].create(e);
  }, isEntity = function(e) {
    return "isEntity" in e;
  }, isMeshEntity = function(e) {
    return "isAbstractMesh" in e;
  }, isHelperableEntity = function(e) {
    return "objectHelper" in e;
  }, _box3 = new THREE.Box3(), _center = new THREE.Vector3(), _halfSize = new THREE.Vector3(), _matrix = new THREE.Matrix4(), _traverseSetFromObjectSize = function(e, t, i, r) {
    if (isMeshEntity(e)) {
      var n = e.geometry.userData.parameters, o = e.geometry.getAttribute("position");
      _box3.setFromArray(o.array), _box3.getCenter(_center), e.forceComputeSize ? _box3.getSize(_halfSize).multiplyScalar(0.5) : _halfSize.set(n.width, n.height, n.depth).multiplyScalar(0.5);
    } else if (isHelperableEntity(e) && true === r) {
      o = e.geometryHelper.getAttribute("position");
      _box3.setFromArray(o.array), _box3.getCenter(_center), _box3.getSize(_halfSize).multiplyScalar(0.5);
    } else _center.setScalar(0), _halfSize.setScalar(0);
    _matrix.copy(t).multiply(e.matrixWorld), 0 === _halfSize.x && 0 === _halfSize.y && 0 === _halfSize.z ? i.push(
      new THREE.Vector3(_center.x, _center.y, _center.z).applyMatrix4(
        _matrix
      )
    ) : i.push(
      new THREE.Vector3(-_halfSize.x, _halfSize.y, _halfSize.z).add(_center).applyMatrix4(_matrix),
      new THREE.Vector3(-_halfSize.x, -_halfSize.y, _halfSize.z).add(_center).applyMatrix4(_matrix),
      new THREE.Vector3(_halfSize.x, -_halfSize.y, _halfSize.z).add(_center).applyMatrix4(_matrix),
      new THREE.Vector3(_halfSize.x, _halfSize.y, _halfSize.z).add(_center).applyMatrix4(_matrix),
      new THREE.Vector3(-_halfSize.x, _halfSize.y, -_halfSize.z).add(_center).applyMatrix4(_matrix),
      new THREE.Vector3(-_halfSize.x, -_halfSize.y, -_halfSize.z).add(_center).applyMatrix4(_matrix),
      new THREE.Vector3(_halfSize.x, -_halfSize.y, -_halfSize.z).add(_center).applyMatrix4(_matrix),
      new THREE.Vector3(_halfSize.x, _halfSize.y, -_halfSize.z).add(_center).applyMatrix4(_matrix)
    );
  }, Box3 = function(e) {
    function t(t2, i) {
      var r = e.call(this, t2, i) || this;
      return r.transform = new THREE.Matrix4(), r.vertices = [], r.faces = [], r.edges = [], r.centerEdges = [], r;
    }
    return __extends(t, e), t.prototype.setFromObjectSize = function(e2, t2) {
      void 0 === t2 && (t2 = false), e2.updateWorldMatrix(false, false), this.makeEmpty(), this.transform = e2.matrixWorld;
      var i = new THREE.Matrix4().getInverse(e2.matrixWorld);
      return this.expandByObjectSize(e2, i, t2);
    }, t.prototype.expandByObjectSize = function(e2, t2, i) {
      void 0 === i && (i = false);
      var r = [];
      return true === i ? e2.traverseEntity(function(i2) {
        return _traverseSetFromObjectSize(
          i2,
          t2,
          r,
          "enableHelper" in e2 && e2.enableHelper
        );
      }) : _traverseSetFromObjectSize(
        e2,
        t2,
        r,
        "enableHelper" in e2 && e2.enableHelper
      ), this.setFromPoints(r);
    }, t.prototype.getCenter = function(t2) {
      return (t2 = e.prototype.getCenter.call(this, t2)).applyMatrix4(
        this.transform
      ), t2;
    }, t.prototype.getPositionToCenter = function(t2) {
      return t2 = e.prototype.getCenter.call(this, t2);
    }, t.prototype.computeVertices = function() {
      this.getSize(_halfSize).multiplyScalar(0.5), this.getCenter(_center), _matrix.copy(this.transform).setPosition(_center), this.vertices = [
        new THREE.Vector3(
          -_halfSize.x,
          _halfSize.y,
          _halfSize.z
        ).applyMatrix4(_matrix),
        new THREE.Vector3(
          -_halfSize.x,
          -_halfSize.y,
          _halfSize.z
        ).applyMatrix4(_matrix),
        new THREE.Vector3(
          _halfSize.x,
          -_halfSize.y,
          _halfSize.z
        ).applyMatrix4(_matrix),
        new THREE.Vector3(
          _halfSize.x,
          _halfSize.y,
          _halfSize.z
        ).applyMatrix4(_matrix),
        new THREE.Vector3(
          -_halfSize.x,
          _halfSize.y,
          -_halfSize.z
        ).applyMatrix4(_matrix),
        new THREE.Vector3(
          -_halfSize.x,
          -_halfSize.y,
          -_halfSize.z
        ).applyMatrix4(_matrix),
        new THREE.Vector3(
          _halfSize.x,
          -_halfSize.y,
          -_halfSize.z
        ).applyMatrix4(_matrix),
        new THREE.Vector3(
          _halfSize.x,
          _halfSize.y,
          -_halfSize.z
        ).applyMatrix4(_matrix)
      ];
    }, t.prototype.computeEdges = function() {
      this.vertices.length > 0 && this.computeVertices(), this.edges = [
        new THREE.Line3(this.vertices[0], this.vertices[3]),
        new THREE.Line3(this.vertices[1], this.vertices[2]),
        new THREE.Line3(this.vertices[5], this.vertices[6]),
        new THREE.Line3(this.vertices[4], this.vertices[7]),
        new THREE.Line3(this.vertices[0], this.vertices[1]),
        new THREE.Line3(this.vertices[3], this.vertices[2]),
        new THREE.Line3(this.vertices[7], this.vertices[6]),
        new THREE.Line3(this.vertices[4], this.vertices[5]),
        new THREE.Line3(this.vertices[0], this.vertices[4]),
        new THREE.Line3(this.vertices[1], this.vertices[5]),
        new THREE.Line3(this.vertices[2], this.vertices[6]),
        new THREE.Line3(this.vertices[3], this.vertices[7])
      ], this.centerEdges = this.edges.map(function(e2) {
        return e2.getCenter(new THREE.Vector3());
      });
    }, t.prototype.computeFaces = function() {
      this.vertices.length > 0 && this.computeVertices(), this.faces = [
        new THREE.Vector3().copy(this.vertices[0]).sub(this.vertices[2]).multiplyScalar(0.5).add(this.vertices[2]),
        new THREE.Vector3().copy(this.vertices[7]).sub(this.vertices[5]).multiplyScalar(0.5).add(this.vertices[5]),
        new THREE.Vector3().copy(this.vertices[4]).sub(this.vertices[1]).multiplyScalar(0.5).add(this.vertices[1]),
        new THREE.Vector3().copy(this.vertices[3]).sub(this.vertices[6]).multiplyScalar(0.5).add(this.vertices[6]),
        new THREE.Vector3().copy(this.vertices[4]).sub(this.vertices[3]).multiplyScalar(0.5).add(this.vertices[3]),
        new THREE.Vector3().copy(this.vertices[1]).sub(this.vertices[6]).multiplyScalar(0.5).add(this.vertices[6])
      ];
    }, t;
  }(THREE.Box3);
  function slerp(e, t, i, r) {
    if (0 === r) return i.copy(e);
    if (1 === r) return i.copy(t);
    var n = e.w * t.w + e.x * t.x + e.y * t.y + e.z * t.z;
    if (n >= 1) return i.copy(e);
    var o = 1 - n * n;
    if (o <= Number.EPSILON) {
      var a = 1 - r;
      return i.w = a * e.w + r * t.w, i.x = a * e.x + r * t.x, i.y = a * e.y + r * t.y, i.z = a * e.z + r * t.z, i.normalize(), i;
    }
    var s = Math.sqrt(o), l = Math.atan2(s, n), c = Math.sin((1 - r) * l) / s, u = Math.sin(r * l) / s;
    return i.w = e.w * c + t.w * u, i.x = e.x * c + t.x * u, i.y = e.y * c + t.y * u, i.z = e.z * c + t.z * u, i;
  }
  var interactionTargets = /* @__PURE__ */ new Set(), INTERACTION_EASING;
  !function(e) {
    e[e.LINEAR = 0] = "LINEAR", e[e.EASE = 1] = "EASE", e[e.EASE_IN = 2] = "EASE_IN", e[e.EASE_OUT = 3] = "EASE_OUT", e[e.EASE_IN_OUT = 4] = "EASE_IN_OUT", e[e.CUBIC = 5] = "CUBIC", e[e.SPRING = 6] = "SPRING";
  }(INTERACTION_EASING || (INTERACTION_EASING = {}));
  var InteractionTarget = function() {
    function e() {
      this.easing = INTERACTION_EASING.EASE_IN_OUT, this.duration = 1e3, this.delay = 0, this.cubicControls = [0.5, 0.05, 0.1, 0.3], this.springParameters = {
        mass: 1,
        stiffness: 80,
        damping: 10,
        velocity: 0
      }, this.repeat = false, this.cycle = false, this.rewind = false;
    }
    return Object.defineProperty(e.prototype, "sp_mass", {
      get: function() {
        return this.springParameters.mass;
      },
      set: function(e2) {
        this.springParameters.mass = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "sp_stiffness", {
      get: function() {
        return this.springParameters.stiffness;
      },
      set: function(e2) {
        this.springParameters.stiffness = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "sp_damping", {
      get: function() {
        return this.springParameters.damping;
      },
      set: function(e2) {
        this.springParameters.damping = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "sp_velocity", {
      get: function() {
        return this.springParameters.velocity;
      },
      set: function(e2) {
        this.springParameters.velocity = e2;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.copy = function(e2) {
      return this.easing = e2.easing, this.duration = e2.duration, this.delay = e2.delay, this.cubicControls = __spread(e2.cubicControls), this.springParameters = __assign({}, e2.springParameters), this.repeat = e2.repeat, this.cycle = e2.cycle, this.rewind = e2.rewind, this;
    }, e.prototype.clone = function() {
      return new e().copy(this);
    }, e.prototype.toJSON = function() {
      var e2 = {
        easing: this.easing,
        duration: this.duration,
        delay: this.delay,
        cubicControls: this.cubicControls,
        springParameters: __assign({}, this.springParameters)
      };
      return true === this.repeat && (e2.repeat = true), true === this.cycle && (e2.cycle = true), true === this.rewind && (e2.rewind = true), void 0 !== this.object && (e2.object = this.object.uuid), void 0 !== this.state && (e2.state = this.state.uuid), e2;
    }, e.prototype.fromJSON = function(e2, t, i) {
      return this.easing = e2.easing, this.duration = e2.duration, this.delay = e2.delay, this.cubicControls = __spread(e2.cubicControls), this.springParameters.mass = e2.springParameters.mass, this.springParameters.stiffness = e2.springParameters.stiffness, this.springParameters.damping = e2.springParameters.damping, this.springParameters.velocity = e2.springParameters.velocity, void 0 !== e2.repeat && (this.repeat = e2.repeat), void 0 !== e2.cycle && (this.cycle = e2.cycle), void 0 !== e2.rewind && (this.rewind = e2.rewind), void 0 !== e2.object && (this.object = t[e2.object]), void 0 !== e2.state && (this.state = i[e2.state]), this;
    }, e;
  }(), INTERACTION_EVENT;
  function isIOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  !function(e) {
    e[e.MOUSE_DOWN = 0] = "MOUSE_DOWN", e[e.MOUSE_UP = 1] = "MOUSE_UP", e[e.MOUSE_HOVER = 2] = "MOUSE_HOVER", e[e.MOUSE_ENTER = 3] = "MOUSE_ENTER", e[e.MOUSE_LEAVE = 4] = "MOUSE_LEAVE", e[e.KEY_DOWN = 5] = "KEY_DOWN", e[e.KEY_UP = 6] = "KEY_UP", e[e.START = 7] = "START", e[e.OPEN_LINK = 8] = "OPEN_LINK", e[e.LOOK_AT = 9] = "LOOK_AT", e[e.FOLLOW = 10] = "FOLLOW";
  }(INTERACTION_EVENT || (INTERACTION_EVENT = {}));
  var InteractionEvent = function() {
    function e(e2, t) {
      this.targets = [], this.ui = { isCollapsed: false }, this._type = e2, this.key = t;
    }
    return Object.defineProperty(e.prototype, "type", {
      get: function() {
        return this._type;
      },
      set: function(e2) {
        this._type = e2, e2 === INTERACTION_EVENT.LOOK_AT ? this.distance = 1e3 : this.distance = void 0, e2 !== INTERACTION_EVENT.KEY_DOWN && e2 !== INTERACTION_EVENT.KEY_UP && (this.key = void 0);
      },
      enumerable: false,
      configurable: true
    }), e.prototype.newTarget = function(e2) {
      var t = new InteractionTarget();
      if (t.object = e2, void 0 !== e2) {
        var i = e2.interaction.states;
        i.length > 0 && (t.state = i[i.length - 1]);
      }
      return this.targets.push(t), interactionTargets.add(t), t;
    }, e.prototype.addTarget = function(e2, t) {
      void 0 === t && (t = 0), this.targets.splice(t, 0, e2), interactionTargets.add(e2);
    }, e.prototype.removeTarget = function(e2) {
      interactionTargets.delete(this.targets[e2]), this.targets.splice(e2, 1);
    }, e.prototype.dispatchReverse = function() {
      for (var e2 = 0, t = this.targets.length; e2 < t; ++e2) {
        var i = this.targets[e2];
        void 0 !== i.state && void 0 !== i.object && i.object.interaction.reverse(i);
      }
    }, e.prototype.dispatch = function() {
      if (void 0 === this.url || this._type !== INTERACTION_EVENT.OPEN_LINK && this._type !== INTERACTION_EVENT.MOUSE_DOWN && this._type !== INTERACTION_EVENT.MOUSE_UP && this._type !== INTERACTION_EVENT.KEY_DOWN && this._type !== INTERACTION_EVENT.KEY_UP)
        for (var e2 = 0, t = this.targets.length; e2 < t; ++e2) {
          var i = this.targets[e2];
          void 0 !== i.state && void 0 !== i.object && i.object.interaction.play(i);
        }
      else
        isIOS() ? window.location.assign(this.url) : window.open(this.url, "_blank");
    }, e.prototype.copy = function(e2) {
      return this._type = e2.type, this.key = e2.key, this.url = e2.url, this.distance = e2.distance, this.ui.isCollapsed = e2.ui.isCollapsed, this;
    }, e.prototype.clone = function() {
      return new e().copy(this);
    }, e.prototype.toJSON = function() {
      var e2 = {
        type: this._type,
        key: this.key,
        ui: { isCollapsed: this.ui.isCollapsed }
      };
      if (void 0 !== this.url && (e2.url = this.url), void 0 !== this.distance && (e2.distance = this.distance), this.targets.length > 0) {
        e2.targets = [];
        for (var t = 0, i = this.targets.length; t < i; ++t)
          e2.targets.push(this.targets[t].toJSON());
      }
      return e2;
    }, e.prototype.fromJSON = function(e2, t, i) {
      if (this._type = e2.type, this.key = e2.key, this.targets = [], this.ui = { isCollapsed: e2.ui.isCollapsed }, this.url = e2.url, void 0 !== e2.distance && (this.distance = e2.distance), void 0 !== e2.targets)
        for (var r = 0, n = e2.targets.length; r < n; ++r)
          this.addTarget(
            new InteractionTarget().fromJSON(e2.targets[r], t, i),
            r
          );
      return this;
    }, e;
  }();
  const Layer = function(e, t) {
    this.id = e, this.next = void 0, this.setValues(t);
  };
  Layer.prototype = {
    constructor: Layer,
    setValues: function(e) {
      if (void 0 === e) return;
      const t = this.id;
      switch (this.type = e.type, this.uniforms = {}, this.defines = {}, this.uniforms[`f${t}_alpha`] = {
        value: void 0 !== e.alpha ? e.alpha : 1
      }, this.uniforms[`f${t}_mode`] = {
        value: void 0 !== e.mode ? e.mode : 0
      }, this.varProgram = `
			// SPE: Default uniforms ********************
			uniform float f${t}_alpha;
			uniform int f${t}_mode;
			// ******************************************
			`, e.type) {
        case "light":
          this.paramNames = ["alpha", "mode"], this.getProgram = function() {
            return `
						// SPE: Light base layer shader-code *****************************************************************************
						// @todo: instead of == use absolute distance for vector comparison
						if ( outgoingLight != diffuseColor.rgb ) {
							float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
							accumAlpha += ( 1.0 - accumAlpha ) * f${this.id}_alpha * lightAccu;
							outgoingLight = spe_blend( diffuseColor.rgb, outgoingLight, f${this.id}_alpha, f${this.id}_mode );
						}
						// ***************************************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            return this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, this;
          };
          break;
        case "color":
          this.paramNames = ["alpha", "mode", "color"], this.uniforms[`f${t}_color`] = {
            value: e.color ? e.color : new THREE.Color(5855577)
          }, this.varProgram += `
					// SPE: Color layer uniforms *******
					uniform vec3 f${t}_color;
					// *********************************
					`, this.getProgram = function(e2) {
            return `
						// SPE: Color layer shader-code *********************************************************************
						float f${this.id}_calpha = f${this.id}_alpha / clamp( f${this.id}_alpha + accumAlpha, 0.00001, 1.0 );
						accumAlpha += ( 1.0 - accumAlpha ) * f${this.id}_alpha;
						${e2} = spe_blend( ${e2}, f${this.id}_color, f${this.id}_calpha, f${this.id}_mode );
						// **************************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            return this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, this.uniforms[`f${this.id}_color`].value.set(
              e2.uniforms[`f${this.id}_color`].value
            ), this;
          };
          break;
        case "texture":
          this.paramNames = ["alpha", "mode", "texture", "crop"], e.texture = e.texture || new THREE.Texture(), this.defines.USE_UV = "", this.uniforms[`f${t}_texture`] = { value: e.texture }, this.uniforms[`f${t}_mat`] = { value: e.texture.matrix }, this.uniforms[`f${t}_crop`] = { value: e.crop ? e.crop : 0 }, this.varProgram += `
					// SPE: Texture layer uniforms ******************
					uniform sampler2D f${t}_texture;
					uniform mat3 f${t}_mat;
					uniform float f${t}_crop;
					// **********************************************
					`, this.getProgram = function(e2) {
            return `
						// SPE: Texture layer shader-code ************************************************************************
						vec2 f${this.id}_vUv = ( f${this.id}_mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
						vec4 f${this.id}_tmp = texture2D( f${this.id}_texture, f${this.id}_vUv );
						vec3 f${this.id}_col = f${this.id}_tmp.rgb;
						float f${this.id}_lalpha = f${this.id}_alpha * f${this.id}_tmp.a;
						if ( f${this.id}_crop > 0.5 ) {
							if ( f${this.id}_vUv.x < 0.0 || f${this.id}_vUv.x > 1.0 ||
								 f${this.id}_vUv.y < 0.0 || f${this.id}_vUv.y > 1.0 ) 
								f${this.id}_lalpha = 0.;
						}
						float f${this.id}_calpha =  f${this.id}_lalpha / clamp( f${this.id}_lalpha + accumAlpha, 0.00001, 1.0 );
						accumAlpha += ( 1.0 - accumAlpha ) * f${this.id}_lalpha;
						${e2} = spe_blend( ${e2}, f${this.id}_col, f${this.id}_calpha, f${this.id}_mode );
						// *******************************************************************************************************
					`;
          }, this.fromJSON = function(e2, t2) {
            let i2;
            return this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, i2 = e2.uniforms[`f${this.id}_texture`] ? t2[e2.uniforms[`f${this.id}_texture`].value] : t2[e2.uniforms[`f${this.id}_tex`].value], this.uniforms[`f${this.id}_texture`].value = i2, this.uniforms[`f${this.id}_mat`].value = i2.matrix.fromArray(
              e2.uniforms[`f${this.id}_mat`].value.elements
            ), this.uniforms[`f${this.id}_crop`].value = e2.uniforms[`f${this.id}_crop`].value, this;
          }, this.dispose = function() {
            this.uniforms[`f${this.id}_texture`].value instanceof THREE.VideoTexture && this.uniforms[`f${this.id}_texture`].value.image.pause(), this.uniforms[`f${this.id}_texture`].value.dispose();
          };
          break;
        case "normal":
          this.paramNames = ["alpha", "mode", "cnormal"], this.defines.USE_LAYER_NORMAL = "", this.uniforms[`f${t}_cnormal`] = {
            value: e.cnormal ? e.cnormal : new THREE.Vector3(1, 1, 1)
          }, this.varProgram += `
					// SPE: Normal layer uniforms ************
					uniform vec3 f${t}_cnormal;
					// ***************************************
					`, this.getProgram = function(e2) {
            return `
						// SPE: Normal layer shader-code *******************************************************************
						vec3 f${this.id}_normal = packNormalToRGB( normal ).rgb;
						f${this.id}_normal *= step( vec3(0.5), f${t}_cnormal );
						float f${this.id}_calpha = f${this.id}_alpha / clamp( f${this.id}_alpha + accumAlpha, 0.00001, 1.0 );
						accumAlpha += ( 1.0 - accumAlpha ) * f${this.id}_alpha;
						${e2} = spe_blend( ${e2}, f${this.id}_normal, f${this.id}_calpha, f${this.id}_mode );
						// *************************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value;
            let t2 = e2.uniforms[`f${this.id}_cnormal`].value;
            return this.uniforms[`f${this.id}_cnormal`].value.set(t2.x, t2.y, t2.z), this;
          };
          break;
        case "depth":
          this.paramNames = [
            "alpha",
            "mode",
            "near",
            "far",
            "origin",
            "isVector",
            "colorA",
            "colorB"
          ], this.defines.USE_LAYER_DEPTH = "", this.uniforms[`f${t}_near`] = { value: e.near ? e.near : 700 }, this.uniforms[`f${t}_far`] = { value: e.far ? e.far : 1e3 }, this.uniforms[`f${t}_origin`] = {
            value: e.origin ? e.origin : new THREE.Vector3()
          }, this.uniforms[`f${t}_isVector`] = {
            value: e.isVector ? e.isVector : 0
          }, this.uniforms[`f${t}_colorA`] = {
            value: e.colorA ? e.colorA : new THREE.Color()
          }, this.uniforms[`f${t}_colorB`] = {
            value: e.colorB ? e.colorB : new THREE.Color(0, 0, 0)
          }, this.varProgram += `
					// SPE: Depth layer uniforms ******************************
					uniform float f${t}_near;
					uniform float f${t}_far;
					uniform float f${t}_isVector;
					uniform vec3 f${t}_origin;
					uniform vec3 f${t}_colorA;
					uniform vec3 f${t}_colorB;
					// ********************************************************
					`, this.getProgram = function(e2) {
            return `
						// SPE: Depth layer shader-code ******************************************************************************
						vec3 base${this.id} = ( f${this.id}_isVector > 0.5 ) ?  f${this.id}_origin : cameraPosition;
						float dist${this.id} = length( dWorldPosition.xyz - base${this.id} );

						float dep${this.id} = ( dist${this.id} - f${this.id}_near ) / ( f${this.id}_far - f${this.id}_near );
						vec3 f${this.id}_depth =  mix( f${this.id}_colorB, f${this.id}_colorA, 1.0 - clamp( dep${this.id}, 0., 1. ) );

						float f${this.id}_calpha = f${this.id}_alpha / clamp( f${this.id}_alpha + accumAlpha, 0.001, 1.0 );
						accumAlpha += ( 1.0 - accumAlpha ) * f${this.id}_alpha;

						${e2} = spe_blend( ${e2}, f${this.id}_depth, f${this.id}_calpha, f${this.id}_mode );
						// ***********************************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, this.uniforms[`f${this.id}_near`].value = e2.uniforms[`f${this.id}_near`].value, this.uniforms[`f${this.id}_far`].value = e2.uniforms[`f${this.id}_far`].value, this.uniforms[`f${this.id}_isVector`].value = e2.uniforms[`f${this.id}_isVector`].value;
            let t2 = e2.uniforms[`f${this.id}_colorA`].value;
            this.uniforms[`f${this.id}_colorA`].value.set(t2);
            let i2 = e2.uniforms[`f${this.id}_colorB`].value;
            this.uniforms[`f${this.id}_colorB`].value.set(i2);
            let r2 = e2.uniforms[`f${this.id}_origin`].value;
            return this.uniforms[`f${this.id}_origin`].value.set(r2.x, r2.y, r2.z), this;
          };
          break;
        case "noise":
          this.paramNames = [
            "alpha",
            "mode",
            "scale",
            "move",
            "distortion",
            "fA",
            "fB",
            "colorA",
            "colorB",
            "colorC",
            "colorD",
            "intA",
            "intB",
            "intC",
            "intD"
          ], this.defines.NUM_OCTAVES = 5, this.defines.USE_UV = "", this.defines.USE_LAYER_NOISE = "", this.uniforms[`f${t}_scale`] = {
            value: e.scale ? e.scale : 2,
            type: "f"
          }, this.uniforms[`f${t}_move`] = {
            value: e.move ? e.move : 1,
            type: "f"
          }, this.uniforms[`f${t}_distortion`] = {
            value: e.distortion ? e.distortion : new THREE.Vector2(1, 1),
            type: "v2"
          }, this.uniforms[`f${t}_fA`] = {
            value: e.fA ? e.fA : new THREE.Vector2(1.7, 9.2),
            type: "v2"
          }, this.uniforms[`f${t}_fB`] = {
            value: e.fB ? e.fB : new THREE.Vector2(8.3, 2.8),
            type: "v2"
          }, this.uniforms[`f${t}_colorA`] = {
            value: e.colorA ? e.colorA : new THREE.Color(0.4, 0.4, 0.4),
            type: "v3"
          }, this.uniforms[`f${t}_colorB`] = {
            value: e.colorB ? e.colorB : new THREE.Color(0.4, 0.4, 0.4),
            type: "v3"
          }, this.uniforms[`f${t}_colorC`] = {
            value: e.colorC ? e.colorC : new THREE.Color(1, 1, 1),
            type: "v3"
          }, this.uniforms[`f${t}_colorD`] = {
            value: e.colorD ? e.colorD : new THREE.Color(1, 1, 1),
            type: "v3"
          }, this.uniforms[`f${t}_intA`] = { value: e.intA ? e.intA : 10 }, this.uniforms[`f${t}_intB`] = { value: e.intB ? e.intB : 10 }, this.uniforms[`f${t}_intC`] = { value: e.intC ? e.intC : 10 }, this.uniforms[`f${t}_intD`] = { value: e.intD ? e.intD : 10 }, this.varProgram += `
					// SPE: Noise layer uniforms *******************
					uniform float f${t}_scale;
					uniform float f${t}_move;
					uniform vec2 f${t}_fA;
					uniform vec2 f${t}_fB;
					uniform vec2 f${t}_distortion;
					uniform vec3 f${t}_colorA;
					uniform vec3 f${t}_colorB;
					uniform vec3 f${t}_colorC;
					uniform vec3 f${t}_colorD;
					uniform float f${t}_intA;
					uniform float f${t}_intB;
					uniform float f${t}_intC;
					uniform float f${t}_intD;
					// *********************************************
				`, this.getProgram = function(e2) {
            let t2 = `f${this.id}_`;
            return `
						// SPE: Noise layer shader-code **************************************************************
						vec2 ${t2}st = vUv * ${t2}scale;
						vec3 ${t2}color;

						vec2 ${t2}q = vec2( fbm( ${t2}st ), fbm( ${t2}st + vec2(1.0) ) );

						vec2 ${t2}r = vec2( fbm( ${t2}st + ${t2}distortion * ${t2}q + ${t2}fA + ${t2}move ),
									   		 fbm( ${t2}st + ${t2}distortion * ${t2}q + ${t2}fB + ${t2}move ) );

						float ${t2}f = fbm( ${t2}st + ${t2}r );

						${t2}color = mix( ${t2}colorA * ${t2}intA, ${t2}colorB * ${t2}intB,
									 clamp((${t2}f*${t2}f)*4.0,0.0,1.0) );

						${t2}color = mix( ${t2}color, ${t2}colorC * ${t2}intC,
									 clamp( length(${t2}q), 0.0, 1.0 ) );

						${t2}color = mix( ${t2}color, ${t2}colorD * ${t2}intD,
									 clamp( length(${t2}r.x), 0.0, 1.0 ) );

						vec3 ${t2}noise = clamp( vec3( ${t2}f * ${t2}color ), 0.0, 1.0 );

						float ${t2}calpha = ${t2}alpha / clamp( ${t2}alpha + accumAlpha, 0.001, 1.0 );
						accumAlpha += ( 1.0 - accumAlpha ) * ${t2}alpha;

						${e2} = spe_blend( ${e2}, ${t2}noise, ${t2}calpha, ${t2}mode );
						// *******************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, this.uniforms[`f${this.id}_scale`].value = e2.uniforms[`f${this.id}_scale`].value, this.uniforms[`f${this.id}_move`].value = e2.uniforms[`f${this.id}_move`].value, this.uniforms[`f${this.id}_intA`].value = e2.uniforms[`f${this.id}_intA`].value, this.uniforms[`f${this.id}_intB`].value = e2.uniforms[`f${this.id}_intB`].value, this.uniforms[`f${this.id}_intC`].value = e2.uniforms[`f${this.id}_intC`].value, this.uniforms[`f${this.id}_intD`].value = e2.uniforms[`f${this.id}_intD`].value;
            let t2 = e2.uniforms[`f${this.id}_colorA`].value;
            this.uniforms[`f${this.id}_colorA`].value.set(t2);
            let i2 = e2.uniforms[`f${this.id}_colorB`].value;
            this.uniforms[`f${this.id}_colorB`].value.set(i2);
            let r2 = e2.uniforms[`f${this.id}_colorC`].value;
            this.uniforms[`f${this.id}_colorC`].value.set(r2);
            let n = e2.uniforms[`f${this.id}_colorD`].value;
            this.uniforms[`f${this.id}_colorD`].value.set(n);
            let o = e2.uniforms[`f${this.id}_distortion`].value;
            this.uniforms[`f${this.id}_distortion`].value.set(o.x, o.y);
            let a = e2.uniforms[`f${this.id}_fA`].value;
            this.uniforms[`f${this.id}_fA`].value.set(a.x, a.y);
            let s = e2.uniforms[`f${this.id}_fB`].value;
            return this.uniforms[`f${this.id}_fB`].value.set(s.x, s.y), this;
          };
          break;
        case "fresnel":
          this.paramNames = [
            "alpha",
            "mode",
            "bias",
            "scale",
            "intensity",
            "factor",
            "color"
          ], this.defines.USE_LAYER_FRESNEL = "", this.uniforms[`f${t}_bias`] = { value: e.bias ? e.bias : 0.1 }, this.uniforms[`f${t}_scale`] = { value: e.scale ? e.scale : 1 }, this.uniforms[`f${t}_intensity`] = {
            value: e.intensity ? e.intensity : 2
          }, this.uniforms[`f${t}_factor`] = {
            value: e.factor ? e.factor : 1
          }, this.uniforms[`f${t}_color`] = {
            value: e.color ? e.color : new THREE.Color()
          }, this.varProgram += `
					// SPE: Fresnel layer uniforms **************************************************
					uniform float f${t}_bias;
					uniform float f${t}_scale;
					uniform float f${t}_intensity;
					uniform float f${t}_factor;
					uniform vec3 f${t}_color;
					// ******************************************************************************
					`, this.getProgram = function(e2) {
            let t2 = `f${this.id}_`;
            return `
						// SPE: Fresnel layer shader-code *******************************************************************************************************************
						float ${t2}fresnel = ${t2}bias + ${t2}scale * pow( ${t2}factor + dot( normalize( vWorldViewDir ), normalize( vWorldNormal ) ), ${t2}intensity );
						float ${t2}lalpha = clamp( ${t2}fresnel, 0.0, 1.0 ) * ${t2}alpha;
						float ${t2}calpha = ${t2}lalpha / clamp( ${t2}lalpha + accumAlpha, 0.001, 1.0 );
						accumAlpha += ( 1.0 - accumAlpha ) * ${t2}lalpha;
						${e2} = spe_blend( ${e2}, ${t2}color, ${t2}calpha, ${t2}mode );
						// **************************************************************************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, this.uniforms[`f${this.id}_bias`].value = e2.uniforms[`f${this.id}_bias`].value, this.uniforms[`f${this.id}_scale`].value = e2.uniforms[`f${this.id}_scale`].value, this.uniforms[`f${this.id}_intensity`].value = e2.uniforms[`f${this.id}_intensity`].value, this.uniforms[`f${this.id}_factor`].value = e2.uniforms[`f${this.id}_factor`].value;
            let t2 = e2.uniforms[`f${this.id}_color`].value;
            return this.uniforms[`f${this.id}_color`].value.set(t2), this;
          };
          break;
        case "gradient":
          let i, r;
          this.paramNames = [
            "alpha",
            "mode",
            "gl_type",
            "num",
            "smooth",
            "colors",
            "steps",
            "offset",
            "morph",
            "angle"
          ], this.defines.USE_UV = "", this.defines.GRAD_MAX = "10", void 0 === e.colors ? (i = new Array(10).fill().map((e2) => new THREE.Vector4(0, 0, 0, 1)), i[1].set(1, 1, 1, 1)) : i = e.colors, void 0 === e.steps ? (r = new Array(10).fill(1), r[0] = 0) : r = e.steps, this.uniforms[`f${t}_gl_type`] = {
            value: e.gl_type ? e.gl_type : 0
          }, this.uniforms[`f${t}_num`] = { value: e.num ? e.num : 2 }, this.uniforms[`f${t}_smooth`] = { value: !!e.smooth && e.smooth }, this.uniforms[`f${t}_colors`] = { value: i }, this.uniforms[`f${t}_steps`] = { value: r }, this.uniforms[`f${t}_offset`] = {
            value: e.offset ? e.offset : new THREE.Vector2(0, 0)
          }, this.uniforms[`f${t}_morph`] = {
            value: e.morph ? e.morph : new THREE.Vector2(0, 0)
          }, this.uniforms[`f${t}_angle`] = { value: e.angle ? e.angle : 0 }, this.varProgram += `
					// SPE: Gradient layer uniforms ****************
					uniform int f${t}_gl_type;
					uniform int f${t}_num;
					uniform bool f${t}_smooth;
					uniform vec4 f${t}_colors[GRAD_MAX];
					uniform float f${t}_steps[GRAD_MAX];
					uniform vec2 f${t}_offset;
					uniform vec2 f${t}_morph;
					uniform float f${t}_angle;
					// *********************************************
					`, this.getProgram = function(e2) {
            let t2 = `f${this.id}_`;
            return `
						// SPE: Gradient layer shader-code **************************************************************************
						vec4 ${t2}color = ${t2}colors[0];

						vec2 ${t2}m = ${t2}morph / vUv.xy;

						vec2 ${t2}rot = vec2( 0.5 + ${t2}m.x, ${t2}m.y );

						vec2 ${t2}dt = vec2(
							cos( ${t2}angle ) * ${t2}rot.x - sin( ${t2}angle ) * ${t2}rot.y,
							sin( ${t2}angle ) * ${t2}rot.x + cos( ${t2}angle ) * ${t2}rot.y
						);

						vec2 ${t2}pt = ( vUv - 0.5 + ${t2}offset ) / 2.0 + ${t2}dt / 2.0;
						float ${t2}t = dot( ${t2}pt, ${t2}dt ) / dot( ${t2}dt, ${t2}dt );

						if ( ${t2}gl_type == 1 ) {

							${t2}t = distance (
								( vUv + ${t2}morph ) * 3.0,
								( vUv + ${t2}offset ) + 1.0
							) + ${t2}angle;

						} else if ( ${t2}gl_type == 2 ) {

							float ${t2}polar = atan(
								vUv.x + ${t2}morph.x - 0.5 + ${t2}offset.x,
								vUv.y + ${t2}morph.y - 0.5 + ${t2}offset.y
							) * -1.0;
							${t2}t = fract( ( ${t2}angle / PI / -2.0 ) + 0.5 * ( ${t2}polar / PI ) );

						}

						float ${t2}p;

						for ( int i = 1; i < GRAD_MAX; i++ ) {

							if ( i < ${t2}num ) {

								${t2}p = clamp( ( ${t2}t - ${t2}steps[i-1] ) / ( ${t2}steps[i] - ${t2}steps[i-1] ), 0.0, 1.0 );

								${t2}color = mix( ${t2}color, ${t2}colors[i],
									( ${t2}smooth ) ? smoothstep( 0.0, 1.0, ${t2}p ) : ${t2}p
								);

							} else {

								break;

							}

						}

						float ${t2}lalpha = ${t2}alpha * ${t2}color.a;

						float ${t2}calpha =  ${t2}lalpha / clamp( ${t2}lalpha + accumAlpha, 0.00001, 1.0 );
						accumAlpha += ( 1.0 - accumAlpha ) * ${t2}lalpha;

						${e2} = spe_blend( ${e2}, ${t2}color.xyz, ${t2}calpha, ${t2}mode );
						// **********************************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, e2.uniforms[`f${this.id}_gl_type`] ? this.uniforms[`f${this.id}_gl_type`].value = e2.uniforms[`f${this.id}_gl_type`].value : this.uniforms[`f${this.id}_gl_type`].value = e2.uniforms[`f${this.id}_type`].value, this.uniforms[`f${this.id}_num`].value = e2.uniforms[`f${this.id}_num`].value, this.uniforms[`f${this.id}_smooth`].value = e2.uniforms[`f${this.id}_smooth`].value, this.uniforms[`f${this.id}_angle`].value = e2.uniforms[`f${this.id}_angle`].value;
            let i2 = e2.uniforms[`f${this.id}_offset`].value;
            this.uniforms[`f${this.id}_offset`].value.set(i2.x, i2.y);
            let r2 = e2.uniforms[`f${this.id}_morph`].value;
            this.uniforms[`f${this.id}_morph`].value.set(r2.x, r2.y);
            let n = e2.uniforms[`f${t}_colors`].value, o = this.uniforms[`f${t}_colors`].value;
            for (let e3 = 0; e3 < n.length; e3++) {
              let t2 = n[e3];
              o[e3].set(t2.x, t2.y, t2.z, t2.w);
            }
            let a = e2.uniforms[`f${t}_steps`].value, s = this.uniforms[`f${t}_steps`].value;
            for (let e3 = 0; e3 < a.length; e3++) s[e3] = a[e3];
            return this;
          };
          break;
        case "points":
          this.paramNames = [
            "alpha",
            "mode",
            "pl_color",
            "pl_useBack",
            "pl_threshold"
          ], this.defines.USE_LAYER_POINTS = "", this.uniforms[`f${t}_pl_color`] = {
            value: e.pl_color ? e.pl_color : new THREE.Color(12237498)
          }, this.uniforms[`f${t}_pl_useBack`] = {
            value: !e.pl_useBack || e.pl_useBack
          }, this.uniforms[`f${t}_pl_threshold`] = {
            value: e.pl_threshold ? e.pl_threshold : 0.9
          }, this.varProgram += `
					// SPE: Points layer uniforms **************
					uniform vec3 f${t}_pl_color;
					uniform bool f${t}_pl_useBack;
					uniform float f${t}_pl_threshold;
					// *****************************************
				`, this.getProgram = function(e2) {
            return `
						// SPE: Points layer shader-code *********************************************************************************
						float f${this.id}_dist = length( vBarycentric );
						float f${this.id}_edge = aastep( f${this.id}_pl_threshold, f${this.id}_dist, 0.00 );
						float f${this.id}_factor = gl_FrontFacing ? 1.0 : ( f${this.id}_pl_useBack ? 0.5 : 0.0 );
						${e2} = spe_blend( ${e2}, f${this.id}_factor * f${this.id}_pl_color, f${this.id}_alpha * f${this.id}_edge, f${this.id}_mode );
						accumAlpha += ( 1.0 - accumAlpha ) * f${this.id}_alpha * f${this.id}_edge;
						// ***************************************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            return this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, this.uniforms[`f${this.id}_pl_color`].value.set(
              e2.uniforms[`f${this.id}_pl_color`].value
            ), this.uniforms[`f${this.id}_pl_useBack`].value.set(
              e2.uniforms[`f${this.id}_pl_useBack`].value
            ), this;
          };
          break;
        case "lines":
          this.paramNames = [
            "alpha",
            "mode",
            "ll_color",
            "ll_thickeness",
            "ll_useBack",
            "ll_smoothOffset"
          ], this.defines.USE_LAYER_LINES = "", this.uniforms[`f${t}_ll_color`] = {
            value: e.ll_color ? e.ll_color : new THREE.Color(12237498)
          }, this.uniforms[`f${t}_ll_thickness`] = {
            value: e.ll_thickness ? e.ll_thickness : 0.01
          }, this.uniforms[`f${t}_ll_useBack`] = {
            value: !e.ll_useBack || e.ll_useBack
          }, this.uniforms[`f${t}_ll_smoothOffset`] = {
            value: e.ll_smoothOffset ? e.ll_smoothOffset : 0.03
          }, this.varProgram += `
					// SPE: Lines layer uniforms *************************
					uniform vec3 f${t}_ll_color;
					uniform float f${t}_ll_thickness;
					uniform bool f${t}_ll_useBack;
					uniform float f${t}_ll_smoothOffset;
					// **************************************************
				`, this.getProgram = function(e2) {
            return `
						// SPE: Lines layer shader-code **********************************************************************************************
						float f${this.id}_dist = min( vBarycentric.x, min( vBarycentric.y, vBarycentric.z ) );
						float f${this.id}_comp_thickness = f${this.id}_ll_thickness;
						float f${this.id}_edge = 1.0 - aastep( f${this.id}_comp_thickness, f${this.id}_dist, f${this.id}_ll_smoothOffset );
						float f${this.id}_factor = gl_FrontFacing ? 1.0 : ( f${this.id}_ll_useBack ? 0.5 : 0.0 );
						${e2} = spe_blend( ${e2}, f${this.id}_factor * f${this.id}_ll_color, f${this.id}_alpha * f${this.id}_edge, f${this.id}_mode );
						accumAlpha += ( 1.0 - accumAlpha ) * f${this.id}_alpha * f${this.id}_edge;
						// ***************************************************************************************************************************
					`;
          }, this.fromJSON = function(e2) {
            return this.uniforms[`f${this.id}_alpha`].value = e2.uniforms[`f${this.id}_alpha`].value, this.uniforms[`f${this.id}_mode`].value = e2.uniforms[`f${this.id}_mode`].value, this.uniforms[`f${this.id}_ll_color`].value.set(
              e2.uniforms[`f${this.id}_ll_color`].value
            ), this.uniforms[`f${this.id}_ll_thickness`].value.set(
              e2.uniforms[`f${this.id}_ll_thickness`].value
            ), this.uniforms[`f${this.id}_ll_useBack`].value.set(
              e2.uniforms[`f${this.id}_ll_useBack`].value
            ), this.uniforms[`f${this.id}_ll_smoothOffset`].value.set(
              e2.uniforms[`f${this.id}_ll_smoothOffset`].value
            ), this;
          };
      }
    },
    getValues: function() {
      const e = { type: this.type };
      for (let t = 0, i = this.paramNames.length; t < i; ++t) {
        const i2 = this.paramNames[t], r = this.uniforms[`f${this.id}_` + i2];
        if (e[i2] = {}, Array.isArray(r.value)) {
          const t2 = r.value.length;
          e[i2] = new Array(t2);
          for (let n = 0, o = t2; n < o; n++) {
            const t3 = r.value[n];
            e[i2][n] = void 0 !== t3.clone ? t3.clone() : t3;
          }
        } else r.value.clone ? e[i2] = r.value.clone() : e[i2] = r.value;
      }
      return e;
    },
    copyUniforms: function(e) {
      if ("texture" === this.type) {
        const t = e.uniforms[`f${e.id}_texture`].value.clone();
        this.uniforms[`f${this.id}_alpha`] = {
          value: e.uniforms[`f${e.id}_alpha`].value
        }, this.uniforms[`f${this.id}_mode`] = {
          value: e.uniforms[`f${e.id}_mode`].value
        }, this.uniforms[`f${this.id}_texture`] = { value: t }, this.uniforms[`f${this.id}_mat`] = { value: t.matrix }, this.uniforms[`f${this.id}_crop`] = {
          value: e.uniforms[`f${e.id}_crop`].value
        };
      } else
        for (let t = 0, i = e.paramNames.length; t < i; ++t) {
          const i2 = `f${this.id}_${e.paramNames[t]}`, r = `f${e.id}_${e.paramNames[t]}`;
          if (this.uniforms[i2] = {}, void 0 !== e.uniforms[r].type && (this.uniforms[i2].type = e.uniforms[r].type), Array.isArray(e.uniforms[r].value)) {
            const t2 = e.uniforms[r].value.length;
            this.uniforms[i2].value = new Array(t2);
            let n = this.uniforms[i2].value;
            for (let i3 = 0, o = t2; i3 < o; i3++) {
              const t3 = e.uniforms[r].value[i3];
              n[i3] = void 0 !== t3.clone ? t3.clone() : t3;
            }
          } else
            e.uniforms[r].value.clone ? this.uniforms[i2].value = e.uniforms[r].value.clone() : this.uniforms[i2].value = e.uniforms[r].value;
        }
      return this;
    },
    copy: function(e) {
      if (this.id = e.id, this.type = e.type, this.paramNames = e.paramNames, this.varProgram = e.varProgram, this.getProgram = e.getProgram, this.uniforms = {}, this.defines = { ...e.defines }, "texture" === this.type) {
        const t = e.uniforms[`f${e.id}_texture`].value.clone();
        this.uniforms[`f${this.id}_alpha`] = {
          value: e.uniforms[`f${e.id}_alpha`].value
        }, this.uniforms[`f${this.id}_mode`] = {
          value: e.uniforms[`f${e.id}_mode`].value
        }, this.uniforms[`f${this.id}_texture`] = { value: t }, this.uniforms[`f${this.id}_mat`] = { value: t.matrix }, this.uniforms[`f${this.id}_crop`] = {
          value: e.uniforms[`f${e.id}_crop`].value
        };
      } else
        for (let [t, i] of Object.entries(e.uniforms))
          if (this.uniforms[t] = {}, void 0 !== i.type && (this.uniforms[t].type = i.type), Array.isArray(i.value)) {
            const e2 = i.value.length;
            this.uniforms[t].value = new Array(e2);
            const r = this.uniforms[t].value;
            for (let t2 = 0, n = e2; t2 < n; t2++) {
              const e3 = i.value[t2];
              r[t2] = e3.clone ? e3.clone() : e3;
            }
          } else
            i.value.clone ? this.uniforms[t].value = i.value.clone() : this.uniforms[t].value = i.value;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON(e) {
      let t = {};
      if (t.id = this.id, t.type = this.type, t.defines = JSON.parse(JSON.stringify(this.defines)), "texture" === this.type) {
        const i = this.uniforms[`f${this.id}_texture`];
        t.uniforms = {}, t.uniforms[`f${this.id}_alpha`] = {
          value: this.uniforms[`f${this.id}_alpha`].value
        }, t.uniforms[`f${this.id}_mode`] = {
          value: this.uniforms[`f${this.id}_mode`].value
        }, t.uniforms[`f${this.id}_texture`] = {
          value: i.value.toJSON(e).uuid
        }, t.uniforms[`f${this.id}_mat`] = {
          value: JSON.parse(
            JSON.stringify(this.uniforms[`f${this.id}_mat`].value)
          )
        }, t.uniforms[`f${this.id}_crop`] = {
          value: this.uniforms[`f${this.id}_crop`].value
        };
      } else t.uniforms = JSON.parse(JSON.stringify(this.uniforms));
      return t.next = null == this.next ? void 0 : this.next.toJSON(e), t;
    }
  };
  const CreateLayerFromJSON = function(e, t) {
    const i = e.id, r = e.type;
    return new Layer(i, { type: r }).fromJSON(e, t);
  }, LayerStack = function(e, t, i) {
    this.id = 2, this.shader = void 0, this.needsUpdate = false, this.head = new Layer(0, { type: "color", color: e, alpha: t }), this.head.next = new Layer(1, { type: "light" }), this.uuid = void 0 !== i ? i : THREE.Math.generateUUID();
  };
  LayerStack.prototype = {
    constructor: LayerStack,
    addLayer: function(e) {
      let t = this.head;
      const i = new Layer(e.id ? e.id : ++this.id, e);
      for (; null != t.next; ) t = t.next;
      return t.next = i, this.uuid = THREE.Math.generateUUID(), i;
    },
    addLayerBeforeAt: function(e, t) {
      let i = this.head;
      const r = new Layer(e.id ? e.id : ++this.id, e);
      if (r.next = t, i === t) this.head = r;
      else {
        for (; i.next !== t; ) i = i.next;
        i.next = r;
      }
      return this.uuid = THREE.Math.generateUUID(), r;
    },
    addLayerAt: function(e, t) {
      let i, r = this.head;
      const n = new Layer(t.id, t);
      if (0 == e) return n.next = this.head, this.head = n, n;
      i = this.head, r = this.head.next;
      for (let t2 = 0; t2 < e - 1; t2++) i = r, r = r.next;
      return n.next = r, i.next = n, this.uuid = THREE.Math.generateUUID(), n;
    },
    removeLayer: function(e) {
      let t, i = this.head, r = 0;
      if (i.id == e) this.head = i.next;
      else
        for (r = 1, t = i, i = i.next; null != i; ) {
          if (i.id == e) {
            t.next = i.next;
            break;
          }
          r++, t = i, i = i.next;
        }
      return this.uuid = THREE.Math.generateUUID(), r;
    },
    changeLayer: function(e, t) {
      let i, r = this.head, n = new Layer(e, t);
      if (r.id == e)
        n.next = r.next, this.head = n, n.uniforms[`f${e}_mode`].value = r.uniforms[`f${e}_mode`].value, n.uniforms[`f${e}_alpha`].value = r.uniforms[`f${e}_alpha`].value;
      else
        for (i = r, r = r.next; null != r; ) {
          if (r.id == e) {
            i.next = n, n.next = r.next, n.uniforms[`f${e}_mode`].value = r.uniforms[`f${e}_mode`].value, n.uniforms[`f${e}_alpha`].value = r.uniforms[`f${e}_alpha`].value;
            break;
          }
          i = r, r = r.next;
        }
      return this.uuid = THREE.Math.generateUUID(), n;
    },
    getLayer: function(e) {
      let t = this.head;
      for (; null != t && t.id != e; ) t = t.next;
      return t;
    },
    getLayers: function() {
      let e = [], t = this.head;
      for (; null != t; ) e.push(t), t = t.next;
      return e;
    },
    getLayerPosition: function(e) {
      let t = this.head, i = 0;
      for (; void 0 !== t && t.id != e; ) i++, t = t.next;
      return i;
    },
    getDefines: function() {
      let e = "";
      const t = {};
      let i = this.head;
      for (; null != i; ) {
        for (let [e2, r] of Object.entries(i.defines)) t[e2] = r;
        i = i.next;
      }
      for (let [i2, r] of Object.entries(t)) e += `#define ${i2} ${r}
`;
      return e;
    },
    getBeforeProgram: function() {
      let e = "", t = this.head;
      for (; "light" != t.type; ) e += t.getProgram("bef"), t = t.next;
      return e;
    },
    getLightingProgram: function() {
      let e = this.head;
      for (; "light" != e.type; ) e = e.next;
      return e.getProgram();
    },
    getAfterProgram: function() {
      let e = "", t = this.head;
      for (; "light" != t.type; ) t = t.next;
      for (t = t.next; null != t; ) e += t.getProgram("aft"), t = t.next;
      return e;
    },
    getVarPrograms: function() {
      let e = "", t = this.head;
      for (; null != t; ) e += t.varProgram, t = t.next;
      return e;
    },
    getUniforms: function() {
      const e = {};
      let t = this.head;
      for (; null != t; ) {
        for (let [i, r] of Object.entries(t.uniforms)) e[i] = r;
        t = t.next;
      }
      return e;
    },
    moveLayer: function(e, t) {
      let i, r, n = this.head;
      if (0 == e) i = this.head, this.head = i.next;
      else {
        for (let t2 = 0; t2 < e; t2++) r = n, n = n.next;
        r.next = n.next, i = n;
      }
      if (n = this.head, r = void 0, 0 == t)
        i.next = this.head, this.head = i;
      else {
        for (let e2 = 0; e2 < t - 1; e2++) n = n.next;
        i.next = n.next, n.next = i;
      }
      this.uuid = THREE.Math.generateUUID();
    },
    updateLayerUniform: function(e, t) {
      const i = this.getLayer(e);
      i && this.updateLayerUniformByLayer(i, t);
    },
    updateLayerUniformByLayer: function(e, t) {
      this.shader.uniforms[t] ? this.shader.uniforms[t].value = e.uniforms[t].value : this.shader.uniforms[t] = { value: e.uniforms[t].value }, this.uuid = THREE.Math.generateUUID();
    },
    copy: function(e) {
      this.id = e.id, this.uuid = e.uuid, this.shader = e.shader, this.needsUpdate = false, this.head = e.head.clone();
      let t = this.head, i = e.head;
      for (; null != i.next; )
        t.next = i.next.clone(), t = t.next, i = i.next;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function(e) {
      let t = {};
      return t.id = this.id, t.uuid = this.uuid, t.head = this.head.toJSON(e), t;
    },
    fromJSON: function(e, t) {
      this.id = e.id, this.uuid = e.uuid, this.head = new Layer(e.head.id, { type: e.head.type }).fromJSON(
        e.head,
        t
      );
      let i = e.head.next, r = this.head;
      for (; null != i; )
        r.next = new Layer(i.id, { type: i.type }).fromJSON(i, t), i = i.next, r = r.next;
      return this;
    },
    dispose: function() {
      let e = this.head;
      for (; void 0 !== e; )
        true === e.hasOwnProperty("dispose") && e.dispose(), e = e.next;
    }
  };
  const ShaderLib = {
    setup: function(e, t) {
      t.userData && t.userData.category || ShaderLib.setCategory(t);
      let i = t.userData.category;
      return e.fragmentShader = "\n			/* SPE-Blending helper functions */\n			#define SPE_BLENDING_NORMAL 0\n			#define SPE_BLENDING_MULTIPLY 1\n			#define SPE_BLENDING_SCREEN 2\n			#define SPE_BLENDING_OVERLAY 3\n\n			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {\n				return mix( a, b, alpha );\n			}\n			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {\n				return mix( a, a * b, alpha );\n			}\n			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {\n				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );\n				return mix( a, tmp, alpha );\n			}\n			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {\n				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );\n				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );\n			}\n			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {\n				/**/ if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );\n				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );\n				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );\n				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );\n				return vec3( 1.0 );\n			}\n			" + e.fragmentShader, e.vertexShader = "\n			#ifdef USE_LAYER_FRESNEL\n				varying vec3 vWorldViewDir;\n				varying vec3 vWorldNormal;\n			#endif /* USE_LAYER_FRESNEL */\n			" + e.vertexShader, e.fragmentShader = "\n			#ifdef USE_LAYER_FRESNEL\n				varying vec3 vWorldViewDir;\n				varying vec3 vWorldNormal;\n			#endif /* USE_LAYER_FRESNEL */\n			" + e.fragmentShader, e.vertexShader = e.vertexShader.replace(
        "#include <project_vertex>",
        "\n			#include <project_vertex>\n			#ifdef USE_LAYER_FRESNEL\n				vec4 fWorldPosition = modelMatrix * vec4( position, 1.0 );\n				vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ? \n									( fWorldPosition.xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );\n				vWorldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n			#endif /* USE_LAYER_FRESNEL */\n			"
      ), e.vertexShader = "\n			#if defined( USE_LAYER_POINTS ) || defined( USE_LAYER_LINES )\n				attribute vec3 barycentric;\n				varying vec3 vBarycentric;\n			#endif /* USE_LAYER_POINTS || USE_LAYER_LINES */\n		" + e.vertexShader, e.vertexShader = e.vertexShader.replace(
        "#include <begin_vertex>",
        "\n			#include <begin_vertex>\n			#if defined( USE_LAYER_POINTS ) || defined( USE_LAYER_LINES )\n				vBarycentric = barycentric;\n			#endif /* USE_LAYER_POINTS || USE_LAYER_LINES */\n			"
      ), e.fragmentShader = "\n			#if defined( USE_LAYER_POINTS ) || defined( USE_LAYER_LINES )\n				varying vec3 vBarycentric;\n\n				float aastep( float threshold, float dist, float smoothOffset ) {\n					float afwidth = fwidth( dist ) * 0.5;\n					return smoothstep( threshold - afwidth - smoothOffset, threshold + afwidth + smoothOffset, dist );\n				}\n			#endif /* USE_LAYER_POINTS || USE_LAYER_LINES */\n		" + e.fragmentShader, e.fragmentShader = "\n			#ifdef USE_LAYER_NOISE\n\n				float random ( in vec2 _st ) {\n					return sin(sin(dot(_st.xy, vec2(12.834,77.212))) * 320.3456); // Ale: I am usin sin() instead of fract() to create a different noise.\n				}\n\n				float noise ( in vec2 _st ) {\n					vec2 i = floor(_st);\n					vec2 f = fract(_st);\n\n					// Four corners in 2D of a tile\n					float a = random(i);\n					float b = random(i + vec2(1.0, 0.0)); // Ale: By incrementing disproportionally these values. You get a geometrical distortion.\n					float c = random(i + vec2(0.0, 1.0));\n					float d = random(i + vec2(1.0, 1.0));\n\n					vec2 u = f * f * (3.0 - 2.0 * f);\n\n					return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n				}\n\n				float fbm ( in vec2 _st ) {\n					float v = 0.0;\n					float a = 0.5;\n					vec2 shift = vec2(100.0);\n\n					// Rotate to reduce axial bias\n					mat2 rot = mat2(cos(0.5), sin(0.5),\n									-sin(0.5), cos(0.50));\n					for (int i = 0; i < NUM_OCTAVES; ++i) {\n						v += a * noise(_st);\n						_st = rot * _st * 2.0 + shift;\n						a *= 0.5;\n					}\n					return v;\n				}\n			#endif /* USE_LAYER_NOISE */\n			" + e.fragmentShader, e.fragmentShader = e.fragmentShader.replace(
        "#include <normal_fragment_begin>",
        ""
      ), e.fragmentShader = e.fragmentShader.replace(
        "#include <normal_fragment_maps>",
        ""
      ), "Basic" == i && (e.fragmentShader = e.fragmentShader.replace(
        "#include <lights_phong_fragment>\n				#include <lights_fragment_begin>\n				#include <lights_fragment_maps>\n				#include <lights_fragment_end>",
        ""
      ), e.fragmentShader = e.fragmentShader.replace(
        "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;",
        "vec3 outgoingLight = diffuseColor.rgb;"
      )), "Lambert" == i && (e.vertexShader = "\n				#ifdef USE_LAYER_NORMAL\n					varying vec3 vNormal;\n				#endif /* USE_LAYER_NORMAL */\n				" + e.vertexShader, e.vertexShader = e.vertexShader.replace(
        "#include <defaultnormal_vertex>",
        "\n				#include <defaultnormal_vertex>\n				#ifdef USE_LAYER_NORMAL\n					vNormal = normalize( transformedNormal );\n				#endif /* USE_LAYER_NORMAL */\n				"
      ), e.fragmentShader = "\n				#ifdef USE_LAYER_NORMAL\n					varying vec3 vNormal;\n				#endif /* USE_LAYER_NORMAL */\n				" + e.fragmentShader, e.fragmentShader = e.fragmentShader.replace(
        "vec4 diffuseColor = vec4( diffuse, opacity );",
        "\n				#ifdef USE_LAYER_NORMAL\n					#include <normal_fragment_begin>\n					#include <normal_fragment_maps>\n				#endif /* USE_LAYER_NORMAL */\n\n					float accumAlpha = 0.0;\n					vec3 bef = vec3( 1.0 );\n					#before\n					vec4 diffuseColor = vec4( bef, 1.0 );\n				"
      )), "Basic" != i && "Lambert" != i && "Phong" != i && "Physical" != i && "Toon" != i || (e.vertexShader = e.vertexShader.replace(
        "#include <common>",
        "\n				#include <common>\n\n				#ifdef USE_LAYER_DEPTH\n					varying vec4 dWorldPosition;\n				#endif /* USE_LAYER_DEPTH */\n				"
      ), e.vertexShader = e.vertexShader.replace(
        "#include <worldpos_vertex>",
        "\n				#include <worldpos_vertex>\n				#ifdef USE_LAYER_DEPTH\n					dWorldPosition = modelMatrix * vec4( transformed, 1.0 );\n				#endif\n				"
      ), e.fragmentShader = "\n				#ifdef USE_LAYER_DEPTH\n					varying vec4 dWorldPosition;\n				#endif /* USE_LAYER_DEPTH */\n				" + e.fragmentShader, e.fragmentShader = e.fragmentShader.replace(
        "vec4 diffuseColor = vec4( diffuse, opacity );",
        "\n					#include <normal_fragment_begin>\n					#include <normal_fragment_maps>\n					float accumAlpha = 0.0;\n					vec3 bef = vec3( 1.0 );\n					#before\n					vec4 diffuseColor = vec4( bef, 1.0 );\n				"
      ), e.fragmentShader = e.fragmentShader.replace(
        "gl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        "\n					#lighting\n					vec3 aft = outgoingLight;\n					#after\n					gl_FragColor = vec4( aft, accumAlpha * opacity );\n				"
      )), e;
    },
    createCallback: function(material) {
      let string = "";
      for (let e = 0; e < material.uuid.length; ++e) {
        const t = material.uuid[e];
        "-" != t && (string += t);
      }
      return eval(
        `shader => {
			const __hash___${string} = true;
			const layers = material.userData.layers;

			ShaderLib.setup( shader, material );

			// uniforms
			shader.uniforms = THREE.UniformsUtils.merge( [
				shader.uniforms, layers.getUniforms()
			] );

			// UPDATE WITH CORE FUNCTION - !IMPORTANT!
			for ( let [key, uniform] of Object.entries( shader.uniforms ) ) {

				if ( uniform.value && uniform.value.isTexture ) {
					uniform.value.needsUpdate = true;
				}

			}

			// uniform program
			shader.fragmentShader = layers.getVarPrograms() + shader.fragmentShader;

			// before lighting
			shader.fragmentShader = shader.fragmentShader.replace(
				'#before', layers.getBeforeProgram()
			);

			// lighting
			shader.fragmentShader = shader.fragmentShader.replace(
				'#lighting', layers.getLightingProgram()
			);

			// after lighting
			shader.fragmentShader = shader.fragmentShader.replace(
				'#after', layers.getAfterProgram()
			);

			// defines
			const defs = layers.getDefines();
			shader.vertexShader = defs + shader.vertexShader;
			shader.fragmentShader = defs + shader.fragmentShader;

			// reference
			layers.shader = shader;
		}`
      );
    },
    setCategory: function(e) {
      let t;
      switch (e.type) {
        case "MeshBasicMaterial":
          t = "Basic";
          break;
        case "MeshLambertMaterial":
          t = "Lambert";
          break;
        case "MeshPhongMaterial":
          t = "Phong";
          break;
        case "MeshPhysicalMaterial":
          t = "Physical";
          break;
        case "MeshToonMaterial":
          t = "Toon";
      }
      e.userData = e.userData || {}, e.userData.category = t;
    }
  };
  var InteractionState = function() {
    function e() {
      this.uuid = THREE.MathUtils.generateUUID(), this.name = "", this.position = new THREE.Vector3(), this.rotation = new THREE.Euler(), this.scale = new THREE.Vector3(), this.hiddenMatrix = new THREE.Matrix4();
    }
    return e.prototype.update = function(e2) {
      this.updateMatrix(e2), "geometry" in e2 && this.updateGeometry(e2), "material" in e2 && this.updateMaterial(e2), "CombinedCamera" === e2.objectType && this.updateCamera(e2);
    }, e.prototype.updateCamera = function(e2) {
      this.camera = {
        zoomPersp: e2.perspCamera.zoom,
        zoomOrtho: e2.orthoCamera.zoom
      };
    }, e.prototype.updateMatrix = function(e2) {
      this.position.copy(e2.position), this.rotation.copy(e2.rotation), this.scale.copy(e2.scale), "hiddenMatrix" in e2 && this.hiddenMatrix.copy(e2.hiddenMatrix);
    }, e.prototype.updateGeometry = function(e2) {
      if ("geometry" in e2) {
        var t = e2.geometry.userData.parameters, i = t.width, r = t.height, n = t.depth;
        this.geometry = { width: i, height: r, depth: n };
      }
    }, e.prototype.updateMaterial = function(e2) {
      if ("material" in e2)
        if (e2.material instanceof Array) {
          this.material = [];
          for (var t = 0, i = e2.material.length; t < i; ++t) {
            for (var r = [], n = e2.material[t].layersList.head; n; )
              r.push(n.clone()), n = n.next;
            this.material.push({ layersList: r });
          }
        } else {
          for (r = [], n = e2.material.layersList.head; n; )
            r.push(n.clone()), n = n.next;
          this.material = { layersList: r };
        }
    }, e.prototype.execute = function(e2) {
      if (e2.position.copy(this.position), e2.rotation.copy(this.rotation), e2.scale.copy(this.scale), "hiddenMatrix" in e2 && e2.hiddenMatrix.copy(this.hiddenMatrix), "geometry" in e2 && void 0 !== this.geometry) {
        var t = e2.geometry.userData.parameters, i = this.geometry;
        i.width === t.width && i.height === t.height && i.depth === t.depth || e2.updateGeometry({
          parameters: { width: i.width, height: i.height, depth: i.depth }
        });
      }
      if ("material" in e2) {
        var r = e2.material;
        if (r instanceof Array)
          for (var n = 0, o = (c = this.material).length; n < o; ++n) {
            for (var a = r[n].layersList.head, s = c[n].layersList, l = 0; a; )
              a.copy(s[l++]), a = a.next;
            r[n].dispose();
          }
        else {
          var c;
          for (n = 0, a = r.layersList.head, s = (c = this.material).layersList; a; )
            a.copyUniforms(s[n++]), a = a.next;
          r.dispose();
        }
      }
      this.camera && "CombinedCamera" === e2.objectType && (e2.zoom = "OrthographicCamera" === e2.cameraType ? this.camera.zoomOrtho : this.camera.zoomPersp, e2.updateProjectionMatrix());
    }, e.prototype.copy = function(e2) {
      if (this.name = e2.name, this.position.copy(e2.position), this.rotation.copy(e2.rotation), this.scale.copy(e2.scale), this.hiddenMatrix.copy(e2.hiddenMatrix), void 0 !== e2.geometry && (this.geometry = {
        width: e2.geometry.width,
        height: e2.geometry.height,
        depth: e2.geometry.depth
      }), void 0 !== e2.material)
        if (e2.material instanceof Array) {
          this.material = [];
          for (var t = 0, i = e2.material.length; t < i; ++t)
            this.material.push({
              layersList: e2.material[t].layersList.map(function(e3) {
                return e3.clone();
              })
            });
        } else
          this.material = {
            layersList: e2.material.layersList.map(function(e3) {
              return e3.clone();
            })
          };
      return void 0 !== e2.camera && (this.camera = {
        zoomPersp: e2.camera.zoomPersp,
        zoomOrtho: e2.camera.zoomOrtho
      }), this;
    }, e.prototype.clone = function() {
      return new e().copy(this);
    }, e.prototype.toJSON = function(e2) {
      var t = {
        uuid: this.uuid,
        name: this.name,
        position: this.position.toArray(),
        rotation: this.rotation.toArray(),
        scale: this.scale.toArray(),
        hiddenMatrix: this.hiddenMatrix.toArray()
      };
      if (void 0 !== this.geometry && (t.geometry = {
        width: this.geometry.width,
        height: this.geometry.height,
        depth: this.geometry.depth
      }), void 0 !== this.material)
        if (this.material instanceof Array) {
          t.material = [];
          for (var i = 0, r = this.material.length; i < r; ++i)
            t.material.push({
              layersList: this.material[i].layersList.map(function(t2) {
                return t2.toJSON(e2);
              })
            });
        } else
          t.material = {
            layersList: this.material.layersList.map(function(t2) {
              return t2.toJSON(e2);
            })
          };
      return void 0 !== this.camera && (t.camera = {
        zoomPersp: this.camera.zoomPersp,
        zoomOrtho: this.camera.zoomOrtho
      }), t;
    }, e.prototype.fromJSON = function(e2, t) {
      if (this.uuid = e2.uuid, this.name = e2.name, this.position.fromArray(e2.position), this.rotation.fromArray(e2.rotation), this.scale.fromArray(e2.scale), this.hiddenMatrix.fromArray(e2.hiddenMatrix), void 0 !== e2.geometry && (this.geometry = {
        width: e2.geometry.width,
        height: e2.geometry.height,
        depth: e2.geometry.depth
      }), void 0 !== e2.material)
        if (e2.material instanceof Array) {
          this.material = [];
          for (var i = 0, r = e2.material.length; i < r; ++i)
            this.material.push({
              layersList: e2.material[i].layersList.map(function(e3) {
                return CreateLayerFromJSON(e3, t);
              })
            });
        } else
          this.material = {
            layersList: e2.material.layersList.map(function(e3) {
              return CreateLayerFromJSON(e3, t);
            })
          };
      return void 0 !== e2.camera && (this.camera = {
        zoomPersp: e2.camera.zoomPersp,
        zoomOrtho: e2.camera.zoomOrtho
      }), this;
    }, e;
  }(), defaultInstanceSettings = {
    update: null,
    begin: null,
    loopBegin: null,
    changeBegin: null,
    change: null,
    changeComplete: null,
    loopComplete: null,
    complete: null,
    loop: 1,
    direction: "normal",
    autoplay: true,
    timelineOffset: 0,
    rewind: true
  }, defaultTweenSettings = {
    duration: 1e3,
    delay: 0,
    endDelay: 0,
    easing: "easeOutElastic(1, .5)",
    round: 0
  }, validTransforms = [
    "translateX",
    "translateY",
    "translateZ",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "scale",
    "scaleX",
    "scaleY",
    "scaleZ",
    "skew",
    "skewX",
    "skewY",
    "perspective",
    "matrix",
    "matrix3d"
  ], cache = { CSS: {}, springs: {} };
  function minMax(e, t, i) {
    return Math.min(Math.max(e, t), i);
  }
  function stringContains(e, t) {
    return e.indexOf(t) > -1;
  }
  function applyArguments(e, t) {
    return e.apply(null, t);
  }
  var is = {
    arr: function(e) {
      return Array.isArray(e);
    },
    obj: function(e) {
      return stringContains(Object.prototype.toString.call(e), "Object");
    },
    pth: function(e) {
      return is.obj(e) && e.hasOwnProperty("totalLength");
    },
    svg: function(e) {
      return e instanceof SVGElement;
    },
    inp: function(e) {
      return e instanceof HTMLInputElement;
    },
    dom: function(e) {
      return e.nodeType || is.svg(e);
    },
    str: function(e) {
      return "string" == typeof e;
    },
    fnc: function(e) {
      return "function" == typeof e;
    },
    und: function(e) {
      return void 0 === e;
    },
    hex: function(e) {
      return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(e);
    },
    rgb: function(e) {
      return /^rgb/.test(e);
    },
    hsl: function(e) {
      return /^hsl/.test(e);
    },
    col: function(e) {
      return is.hex(e) || is.rgb(e) || is.hsl(e);
    },
    key: function(e) {
      return !defaultInstanceSettings.hasOwnProperty(e) && !defaultTweenSettings.hasOwnProperty(e) && "targets" !== e && "keyframes" !== e;
    }
  };
  function parseEasingParameters(e) {
    var t = /\(([^)]+)\)/.exec(e);
    return t ? t[1].split(",").map(function(e2) {
      return parseFloat(e2);
    }) : [];
  }
  function spring(e, t) {
    var i = parseEasingParameters(e), r = minMax(is.und(i[0]) ? 1 : i[0], 0.1, 100), n = minMax(is.und(i[1]) ? 100 : i[1], 0.1, 100), o = minMax(is.und(i[2]) ? 10 : i[2], 0.1, 100), a = minMax(is.und(i[3]) ? 0 : i[3], 0.1, 100), s = Math.sqrt(n / r), l = o / (2 * Math.sqrt(n * r)), c = l < 1 ? s * Math.sqrt(1 - l * l) : 0, u = l < 1 ? (l * s - a) / c : -a + s;
    function h(e2) {
      var i2 = t ? t * e2 / 1e3 : e2;
      return i2 = l < 1 ? Math.exp(-i2 * l * s) * (1 * Math.cos(c * i2) + u * Math.sin(c * i2)) : (1 + u * i2) * Math.exp(-i2 * s), 0 === e2 || 1 === e2 ? e2 : 1 - i2;
    }
    return t ? h : function() {
      var t2 = cache.springs[e];
      if (t2) return t2;
      for (var i2 = 1 / 6, r2 = 0, n2 = 0; ; )
        if (1 === h(r2 += i2)) {
          if (++n2 >= 16) break;
        } else n2 = 0;
      var o2 = r2 * i2 * 1e3;
      return cache.springs[e] = o2, o2;
    };
  }
  function steps(e) {
    return void 0 === e && (e = 10), function(t) {
      return Math.ceil(minMax(t, 1e-6, 1) * e) * (1 / e);
    };
  }
  var bezier = /* @__PURE__ */ function() {
    var e = 0.1;
    function t(e2, t2) {
      return 1 - 3 * t2 + 3 * e2;
    }
    function i(e2, t2) {
      return 3 * t2 - 6 * e2;
    }
    function r(e2) {
      return 3 * e2;
    }
    function n(e2, n2, o2) {
      return ((t(n2, o2) * e2 + i(n2, o2)) * e2 + r(n2)) * e2;
    }
    function o(e2, n2, o2) {
      return 3 * t(n2, o2) * e2 * e2 + 2 * i(n2, o2) * e2 + r(n2);
    }
    return function(t2, i2, r2, a) {
      if (0 <= t2 && t2 <= 1 && 0 <= r2 && r2 <= 1) {
        var s = new Float32Array(11);
        if (t2 !== i2 || r2 !== a)
          for (var l = 0; l < 11; ++l) s[l] = n(l * e, t2, r2);
        return function(e2) {
          return t2 === i2 && r2 === a || 0 === e2 || 1 === e2 ? e2 : n(c(e2), i2, a);
        };
      }
      function c(i3) {
        for (var a2 = 0, l2 = 1; 10 !== l2 && s[l2] <= i3; ++l2) a2 += e;
        --l2;
        var c2 = a2 + (i3 - s[l2]) / (s[l2 + 1] - s[l2]) * e, u = o(c2, t2, r2);
        return u >= 1e-3 ? function(e2, t3, i4, r3) {
          for (var a3 = 0; a3 < 4; ++a3) {
            var s2 = o(t3, i4, r3);
            if (0 === s2) return t3;
            t3 -= (n(t3, i4, r3) - e2) / s2;
          }
          return t3;
        }(i3, c2, t2, r2) : 0 === u ? c2 : function(e2, t3, i4, r3, o2) {
          var a3, s2, l3 = 0;
          do {
            (a3 = n(s2 = t3 + (i4 - t3) / 2, r3, o2) - e2) > 0 ? i4 = s2 : t3 = s2;
          } while (Math.abs(a3) > 1e-7 && ++l3 < 10);
          return s2;
        }(i3, a2, a2 + e, t2, r2);
      }
    };
  }(), penner = (eases = {
    linear: function() {
      return function(e) {
        return e;
      };
    }
  }, functionEasings = {
    Sine: function() {
      return function(e) {
        return 1 - Math.cos(e * Math.PI / 2);
      };
    },
    Circ: function() {
      return function(e) {
        return 1 - Math.sqrt(1 - e * e);
      };
    },
    Back: function() {
      return function(e) {
        return e * e * (3 * e - 2);
      };
    },
    Bounce: function() {
      return function(e) {
        for (var t, i = 4; e < ((t = Math.pow(2, --i)) - 1) / 11; ) ;
        return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((3 * t - 2) / 22 - e, 2);
      };
    },
    Elastic: function(e, t) {
      void 0 === e && (e = 1), void 0 === t && (t = 0.5);
      var i = minMax(e, 1, 10), r = minMax(t, 0.1, 2);
      return function(e2) {
        return 0 === e2 || 1 === e2 ? e2 : -i * Math.pow(2, 10 * (e2 - 1)) * Math.sin(
          (e2 - 1 - r / (2 * Math.PI) * Math.asin(1 / i)) * (2 * Math.PI) / r
        );
      };
    }
  }, ["Quad", "Cubic", "Quart", "Quint", "Expo"].forEach(function(e, t) {
    functionEasings[e] = function() {
      return function(e2) {
        return Math.pow(e2, t + 2);
      };
    };
  }), Object.keys(functionEasings).forEach(function(e) {
    var t = functionEasings[e];
    eases["easeIn" + e] = t, eases["easeOut" + e] = function(e2, i) {
      return function(r) {
        return 1 - t(e2, i)(1 - r);
      };
    }, eases["easeInOut" + e] = function(e2, i) {
      return function(r) {
        return r < 0.5 ? t(e2, i)(2 * r) / 2 : 1 - t(e2, i)(-2 * r + 2) / 2;
      };
    };
  }), eases), eases, functionEasings;
  function parseEasings(e, t) {
    if (is.fnc(e)) return e;
    var i = e.split("(")[0], r = penner[i], n = parseEasingParameters(e);
    switch (i) {
      case "spring":
        return spring(e, t);
      case "cubicBezier":
        return applyArguments(bezier, n);
      case "steps":
        return applyArguments(steps, n);
      default:
        return applyArguments(r, n);
    }
  }
  function selectString(e) {
    try {
      return document.querySelectorAll(e);
    } catch (e2) {
      return;
    }
  }
  function filterArray(e, t) {
    for (var i = e.length, r = arguments.length >= 2 ? arguments[1] : void 0, n = [], o = 0; o < i; o++)
      if (o in e) {
        var a = e[o];
        t.call(r, a, o, e) && n.push(a);
      }
    return n;
  }
  function flattenArray(e) {
    return e.reduce(function(e2, t) {
      return e2.concat(is.arr(t) ? flattenArray(t) : t);
    }, []);
  }
  function toArray(e) {
    return is.arr(e) ? e : (is.str(e) && (e = selectString(e) || e), e instanceof NodeList || e instanceof HTMLCollection ? [].slice.call(e) : [e]);
  }
  function arrayContains(e, t) {
    return e.some(function(e2) {
      return e2 === t;
    });
  }
  function cloneObject(e) {
    var t = {};
    for (var i in e) t[i] = e[i];
    return t;
  }
  function replaceObjectProps(e, t) {
    var i = cloneObject(e);
    for (var r in e) i[r] = t.hasOwnProperty(r) ? t[r] : e[r];
    return i;
  }
  function mergeObjects(e, t) {
    var i = cloneObject(e);
    for (var r in t) i[r] = is.und(e[r]) ? t[r] : e[r];
    return i;
  }
  function rgbToRgba(e) {
    var t = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(e);
    return t ? "rgba(" + t[1] + ",1)" : e;
  }
  function hexToRgba(e) {
    var t = e.replace(
      /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
      function(e2, t2, i2, r) {
        return t2 + t2 + i2 + i2 + r + r;
      }
    ), i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
    return "rgba(" + parseInt(i[1], 16) + "," + parseInt(i[2], 16) + "," + parseInt(i[3], 16) + ",1)";
  }
  function hslToRgba(e) {
    var t, i, r, n = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(e) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(e), o = parseInt(n[1], 10) / 360, a = parseInt(n[2], 10) / 100, s = parseInt(n[3], 10) / 100, l = n[4] || 1;
    function c(e2, t2, i2) {
      return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? e2 + 6 * (t2 - e2) * i2 : i2 < 0.5 ? t2 : i2 < 2 / 3 ? e2 + (t2 - e2) * (2 / 3 - i2) * 6 : e2;
    }
    if (0 == a) t = i = r = s;
    else {
      var u = s < 0.5 ? s * (1 + a) : s + a - s * a, h = 2 * s - u;
      t = c(h, u, o + 1 / 3), i = c(h, u, o), r = c(h, u, o - 1 / 3);
    }
    return "rgba(" + 255 * t + "," + 255 * i + "," + 255 * r + "," + l + ")";
  }
  function colorToRgb(e) {
    return is.rgb(e) ? rgbToRgba(e) : is.hex(e) ? hexToRgba(e) : is.hsl(e) ? hslToRgba(e) : void 0;
  }
  function getUnit(e) {
    var t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(
      e
    );
    if (t) return t[1];
  }
  function getTransformUnit(e) {
    return stringContains(e, "translate") || "perspective" === e ? "px" : stringContains(e, "rotate") || stringContains(e, "skew") ? "deg" : void 0;
  }
  function getFunctionValue(e, t) {
    return is.fnc(e) ? e(t.target, t.id, t.total) : e;
  }
  function getAttribute(e, t) {
    return e.getAttribute(t);
  }
  function convertPxToUnit(e, t, i) {
    if (arrayContains([i, "deg", "rad", "turn"], getUnit(t))) return t;
    var r = cache.CSS[t + i];
    if (!is.und(r)) return r;
    var n = document.createElement(e.tagName), o = e.parentNode && e.parentNode !== document ? e.parentNode : document.body;
    o.appendChild(n), n.style.position = "absolute", n.style.width = 100 + i;
    var a = 100 / n.offsetWidth;
    o.removeChild(n);
    var s = a * parseFloat(t);
    return cache.CSS[t + i] = s, s;
  }
  function getCSSValue(e, t, i) {
    if (t in e.style) {
      var r = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), n = e.style[t] || getComputedStyle(e).getPropertyValue(r) || "0";
      return i ? convertPxToUnit(e, n, i) : n;
    }
  }
  function getAnimationType(e, t) {
    return is.dom(e) && !is.inp(e) && (getAttribute(e, t) || is.svg(e) && e[t]) ? "attribute" : is.dom(e) && arrayContains(validTransforms, t) ? "transform" : is.dom(e) && "transform" !== t && getCSSValue(e, t) ? "css" : null != e[t] ? "object" : void 0;
  }
  function getElementTransforms(e) {
    if (is.dom(e)) {
      for (var t, i = e.style.transform || "", r = /(\w+)\(([^)]*)\)/g, n = /* @__PURE__ */ new Map(); t = r.exec(i); )
        n.set(t[1], t[2]);
      return n;
    }
  }
  function getTransformValue(e, t, i, r) {
    var n = stringContains(t, "scale") ? 1 : 0 + getTransformUnit(t), o = getElementTransforms(e).get(t) || n;
    return i && (i.transforms.list.set(t, o), i.transforms.last = t), r ? convertPxToUnit(e, o, r) : o;
  }
  function getOriginalTargetValue(e, t, i, r) {
    switch (getAnimationType(e, t)) {
      case "transform":
        return getTransformValue(e, t, r, i);
      case "css":
        return getCSSValue(e, t, i);
      case "attribute":
        return getAttribute(e, t);
      default:
        return e[t] || 0;
    }
  }
  function getRelativeValue(e, t) {
    var i = /^(\*=|\+=|-=)/.exec(e);
    if (!i) return e;
    var r = getUnit(e) || 0, n = parseFloat(t), o = parseFloat(e.replace(i[0], ""));
    switch (i[0][0]) {
      case "+":
        return n + o + r;
      case "-":
        return n - o + r;
      case "*":
        return n * o + r;
    }
  }
  function validateValue(e, t) {
    if (is.col(e)) return colorToRgb(e);
    if (/\s/g.test(e)) return e;
    var i = getUnit(e), r = i ? e.substr(0, e.length - i.length) : e;
    return t ? r + t : r;
  }
  function getDistance(e, t) {
    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
  }
  function getCircleLength(e) {
    return 2 * Math.PI * getAttribute(e, "r");
  }
  function getRectLength(e) {
    return 2 * getAttribute(e, "width") + 2 * getAttribute(e, "height");
  }
  function getLineLength(e) {
    return getDistance(
      { x: getAttribute(e, "x1"), y: getAttribute(e, "y1") },
      { x: getAttribute(e, "x2"), y: getAttribute(e, "y2") }
    );
  }
  function getPolylineLength(e) {
    for (var t, i = e.points, r = 0, n = 0; n < i.numberOfItems; n++) {
      var o = i.getItem(n);
      n > 0 && (r += getDistance(t, o)), t = o;
    }
    return r;
  }
  function getPolygonLength(e) {
    var t = e.points;
    return getPolylineLength(e) + getDistance(t.getItem(t.numberOfItems - 1), t.getItem(0));
  }
  function getTotalLength(e) {
    if (e.getTotalLength) return e.getTotalLength();
    switch (e.tagName.toLowerCase()) {
      case "circle":
        return getCircleLength(e);
      case "rect":
        return getRectLength(e);
      case "line":
        return getLineLength(e);
      case "polyline":
        return getPolylineLength(e);
      case "polygon":
        return getPolygonLength(e);
    }
  }
  function setDashoffset(e) {
    var t = getTotalLength(e);
    return e.setAttribute("stroke-dasharray", t), t;
  }
  function getParentSvgEl(e) {
    for (var t = e.parentNode; is.svg(t) && is.svg(t.parentNode); )
      t = t.parentNode;
    return t;
  }
  function getParentSvg(e, t) {
    var i = t || {}, r = i.el || getParentSvgEl(e), n = r.getBoundingClientRect(), o = getAttribute(r, "viewBox"), a = n.width, s = n.height, l = i.viewBox || (o ? o.split(" ") : [0, 0, a, s]);
    return {
      el: r,
      viewBox: l,
      x: l[0] / 1,
      y: l[1] / 1,
      w: a / l[2],
      h: s / l[3]
    };
  }
  function getPath(e, t) {
    var i = is.str(e) ? selectString(e)[0] : e, r = t || 100;
    return function(e2) {
      return {
        property: e2,
        el: i,
        svg: getParentSvg(i),
        totalLength: getTotalLength(i) * (r / 100)
      };
    };
  }
  function getPathProgress(e, t) {
    function i(i2) {
      void 0 === i2 && (i2 = 0);
      var r2 = t + i2 >= 1 ? t + i2 : 0;
      return e.el.getPointAtLength(r2);
    }
    var r = getParentSvg(e.el, e.svg), n = i(), o = i(-1), a = i(1);
    switch (e.property) {
      case "x":
        return (n.x - r.x) * r.w;
      case "y":
        return (n.y - r.y) * r.h;
      case "angle":
        return 180 * Math.atan2(a.y - o.y, a.x - o.x) / Math.PI;
    }
  }
  function decomposeValue(e, t) {
    var i = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g, r = validateValue(is.pth(e) ? e.totalLength : e, t) + "";
    return {
      original: r,
      numbers: r.match(i) ? r.match(i).map(Number) : [0],
      strings: is.str(e) || t ? r.split(i) : []
    };
  }
  function parseTargets(e) {
    return filterArray(
      e ? flattenArray(is.arr(e) ? e.map(toArray) : toArray(e)) : [],
      function(e2, t, i) {
        return i.indexOf(e2) === t;
      }
    );
  }
  function getAnimatables(e) {
    var t = parseTargets(e);
    return t.map(function(e2, i) {
      return {
        target: e2,
        id: i,
        total: t.length,
        transforms: { list: getElementTransforms(e2) }
      };
    });
  }
  function normalizePropertyTweens(e, t) {
    var i = cloneObject(t);
    if (/^spring/.test(i.easing) && (i.duration = spring(i.easing)), is.arr(e)) {
      var r = e.length;
      2 === r && !is.obj(e[0]) ? e = { value: e } : is.fnc(t.duration) || (i.duration = t.duration / r);
    }
    var n = is.arr(e) ? e : [e];
    return n.map(function(e2, i2) {
      var r2 = is.obj(e2) && !is.pth(e2) ? e2 : { value: e2 };
      return is.und(r2.delay) && (r2.delay = i2 ? 0 : t.delay), is.und(r2.endDelay) && (r2.endDelay = i2 === n.length - 1 ? t.endDelay : 0), r2;
    }).map(function(e2) {
      return mergeObjects(e2, i);
    });
  }
  function flattenKeyframes(e) {
    for (var t = filterArray(
      flattenArray(
        e.map(function(e2) {
          return Object.keys(e2);
        })
      ),
      function(e2) {
        return is.key(e2);
      }
    ).reduce(function(e2, t2) {
      return e2.indexOf(t2) < 0 && e2.push(t2), e2;
    }, []), i = {}, r = function(r2) {
      var n2 = t[r2];
      i[n2] = e.map(function(e2) {
        var t2 = {};
        for (var i2 in e2)
          is.key(i2) ? i2 == n2 && (t2.value = e2[i2]) : t2[i2] = e2[i2];
        return t2;
      });
    }, n = 0; n < t.length; n++)
      r(n);
    return i;
  }
  function getProperties(e, t) {
    var i = [], r = t.keyframes;
    for (var n in r && (t = mergeObjects(flattenKeyframes(r), t)), t)
      is.key(n) && i.push({ name: n, tweens: normalizePropertyTweens(t[n], e) });
    return i;
  }
  function normalizeTweenValues(e, t) {
    var i = {};
    for (var r in e) {
      var n = getFunctionValue(e[r], t);
      is.arr(n) && 1 === (n = n.map(function(e2) {
        return getFunctionValue(e2, t);
      })).length && (n = n[0]), i[r] = n;
    }
    return i.duration = parseFloat(i.duration), i.delay = parseFloat(i.delay), i;
  }
  function normalizeTweens(e, t) {
    var i;
    return e.tweens.map(function(r) {
      var n = normalizeTweenValues(r, t), o = n.value, a = is.arr(o) ? o[1] : o, s = getUnit(a), l = getOriginalTargetValue(t.target, e.name, s, t), c = i ? i.to.original : l, u = is.arr(o) ? o[0] : c, h = getUnit(u) || getUnit(l), d = s || h;
      return is.und(a) && (a = c), n.from = decomposeValue(u, d), n.to = decomposeValue(getRelativeValue(a, u), d), n.start = i ? i.end : 0, n.end = n.start + n.delay + n.duration + n.endDelay, n.easing = parseEasings(n.easing, n.duration), n.isPath = is.pth(o), n.isColor = is.col(n.from.original), n.isColor && (n.round = 1), i = n, n;
    });
  }
  var setProgressValue = {
    css: function(e, t, i) {
      return e.style[t] = i;
    },
    attribute: function(e, t, i) {
      return e.setAttribute(t, i);
    },
    object: function(e, t, i) {
      return e[t] = i;
    },
    transform: function(e, t, i, r, n) {
      if (r.list.set(t, i), t === r.last || n) {
        var o = "";
        r.list.forEach(function(e2, t2) {
          o += t2 + "(" + e2 + ") ";
        }), e.style.transform = o;
      }
    }
  };
  function setTargetsValue(e, t) {
    getAnimatables(e).forEach(function(e2) {
      for (var i in t) {
        var r = getFunctionValue(t[i], e2), n = e2.target, o = getUnit(r), a = getOriginalTargetValue(n, i, o, e2), s = getRelativeValue(validateValue(r, o || getUnit(a)), a), l = getAnimationType(n, i);
        setProgressValue[l](n, i, s, e2.transforms, true);
      }
    });
  }
  function createAnimation(e, t) {
    var i = getAnimationType(e.target, t.name);
    if (i) {
      var r = normalizeTweens(t, e), n = r[r.length - 1];
      return {
        type: i,
        property: t.name,
        animatable: e,
        tweens: r,
        duration: n.end,
        delay: r[0].delay,
        endDelay: n.endDelay
      };
    }
  }
  function getAnimations(e, t) {
    return filterArray(
      flattenArray(
        e.map(function(e2) {
          return t.map(function(t2) {
            return createAnimation(e2, t2);
          });
        })
      ),
      function(e2) {
        return !is.und(e2);
      }
    );
  }
  function getInstanceTimings(e, t) {
    var i = e.length, r = function(e2) {
      return e2.timelineOffset ? e2.timelineOffset : 0;
    }, n = {};
    return n.duration = i ? Math.max.apply(
      Math,
      e.map(function(e2) {
        return r(e2) + e2.duration;
      })
    ) : t.duration, n.delay = i ? Math.min.apply(
      Math,
      e.map(function(e2) {
        return r(e2) + e2.delay;
      })
    ) : t.delay, n.endDelay = i ? n.duration - Math.max.apply(
      Math,
      e.map(function(e2) {
        return r(e2) + e2.duration - e2.endDelay;
      })
    ) : t.endDelay, n;
  }
  var instanceID = 0;
  function createNewInstance(e) {
    var t = replaceObjectProps(defaultInstanceSettings, e), i = replaceObjectProps(defaultTweenSettings, e), r = getProperties(i, e), n = getAnimatables(e.targets), o = getAnimations(n, r), a = getInstanceTimings(o, i), s = instanceID;
    return instanceID++, mergeObjects(t, {
      id: s,
      children: [],
      animatables: n,
      animations: o,
      duration: a.duration,
      delay: a.delay,
      endDelay: a.endDelay
    });
  }
  var activeInstances = [], pausedInstances = [], raf, engine = /* @__PURE__ */ function() {
    function e() {
      raf = requestAnimationFrame(t);
    }
    function t(t2) {
      var i = activeInstances.length;
      if (i) {
        for (var r = 0; r < i; ) {
          var n = activeInstances[r];
          if (n.paused) {
            var o = activeInstances.indexOf(n);
            o > -1 && (activeInstances.splice(o, 1), i = activeInstances.length);
          } else n.tick(t2);
          r++;
        }
        e();
      } else raf = cancelAnimationFrame(raf);
    }
    return e;
  }();
  function handleVisibilityChange() {
    document.hidden ? (activeInstances.forEach(function(e) {
      return e.pause();
    }), pausedInstances = activeInstances.slice(0), anime.running = activeInstances = []) : pausedInstances.forEach(function(e) {
      return e.play();
    });
  }
  function anime(e) {
    void 0 === e && (e = {});
    var t, i = 0, r = 0, n = 0, o = 0, a = null;
    function s(e2) {
      var t2 = window.Promise && new Promise(function(e3) {
        return a = e3;
      });
      return e2.finished = t2, t2;
    }
    var l = createNewInstance(e);
    s(l);
    function c() {
      var e2 = l.direction;
      "alternate" !== e2 && (l.direction = "normal" !== e2 ? "normal" : "reverse"), l.reversed = !l.reversed, t.forEach(function(e3) {
        return e3.reversed = l.reversed;
      });
    }
    function u(e2) {
      return l.reversed ? l.duration - e2 : e2;
    }
    function h() {
      i = 0, r = u(l.currentTime) * (1 / anime.speed);
    }
    function d(e2, t2) {
      t2 && t2.seek(e2 - t2.timelineOffset);
    }
    function f(e2) {
      var t2 = 0, i2 = l.animations, r2 = i2.length;
      for (true === l.reversePlayback && false === l.rewind && (e2 = l.duration - e2); t2 < r2; ) {
        var n2 = i2[t2], o2 = n2.animatable, a2 = n2.tweens, s2 = a2.length - 1, c2 = a2[s2];
        s2 && (c2 = filterArray(a2, function(t3) {
          return e2 < t3.end;
        })[0] || c2);
        for (var u2 = minMax(e2 - c2.start - c2.delay, 0, c2.duration) / c2.duration, h2 = isNaN(u2) ? 1 : c2.easing(u2), d2 = c2.to.strings, f2 = c2.round, p2 = [], v2 = c2.to.numbers.length, m = void 0, g = 0; g < v2; g++) {
          var E = void 0;
          if (true === l.reversePlayback && false === l.rewind)
            var y = c2.to.numbers[g], A = c2.from.numbers[g] || 0;
          else A = c2.to.numbers[g], y = c2.from.numbers[g] || 0;
          E = c2.isPath ? getPathProgress(c2.value, h2 * A) : y + h2 * (A - y), f2 && (c2.isColor && g > 2 || (E = Math.round(E * f2) / f2)), p2.push(E);
        }
        var T = d2.length;
        if (T) {
          m = d2[0];
          for (var x = 0; x < T; x++) {
            d2[x];
            var _ = d2[x + 1], w = p2[x];
            isNaN(w) || (m += _ ? w + _ : w + " ");
          }
        } else m = p2[0];
        setProgressValue[n2.type](o2.target, n2.property, m, o2.transforms), n2.currentValue = m, t2++;
      }
    }
    function p(e2) {
      l[e2] && !l.passThrough && l[e2](l);
    }
    function v(e2) {
      var h2 = l.duration, v2 = l.delay, m = h2 - l.endDelay, g = u(e2);
      l.progress = minMax(g / h2 * 100, 0, 100), l.reversePlayback = g < l.currentTime, t && function(e3) {
        if (l.reversePlayback) for (var i2 = o; i2--; ) d(e3, t[i2]);
        else for (var r2 = 0; r2 < o; r2++) d(e3, t[r2]);
      }(g), !l.began && l.currentTime > 0 && (l.began = true, p("begin")), !l.loopBegan && l.currentTime > 0 && (l.loopBegan = true, p("loopBegin")), g <= v2 && 0 !== l.currentTime && f(0), (g >= m && l.currentTime !== h2 || !h2) && f(h2), g > v2 && g < m ? (l.changeBegan || (l.changeBegan = true, l.changeCompleted = false, p("changeBegin")), p("change"), f(g)) : l.changeBegan && (l.changeCompleted = true, l.changeBegan = false, p("changeComplete")), l.currentTime = minMax(g, 0, h2), l.began && p("update"), e2 >= h2 && (r = 0, l.remaining && true !== l.remaining && l.remaining--, l.remaining ? (i = n, p("loopComplete"), l.loopBegan = false, "alternate" === l.direction && c()) : (l.paused = true, l.completed || (l.completed = true, p("loopComplete"), p("complete"), !l.passThrough && "Promise" in window && (a(), s(l)))));
    }
    return l.reset = function() {
      var e2 = l.direction;
      l.passThrough = false, l.currentTime = 0, l.progress = 0, l.paused = true, l.began = false, l.loopBegan = false, l.changeBegan = false, l.completed = false, l.changeCompleted = false, l.reversePlayback = false, l.reversed = "reverse" === e2, l.remaining = l.loop, t = l.children;
      for (var i2 = o = t.length; i2--; ) l.children[i2].reset();
      (l.reversed && true !== l.loop || "alternate" === e2 && 1 === l.loop) && l.remaining++, f(l.reversed ? l.duration : 0);
    }, l.set = function(e2, t2) {
      return setTargetsValue(e2, t2), l;
    }, l.tick = function(e2) {
      n = e2, i || (i = n), v((n + (r - i)) * anime.speed);
    }, l.seek = function(e2) {
      v(u(e2));
    }, l.pause = function() {
      l.paused = true, h();
    }, l.play = function() {
      l.paused && (l.completed && l.reset(), l.paused = false, activeInstances.push(l), h(), raf || engine());
    }, l.reverse = function() {
      c(), l.completed = !l.reversed, h();
    }, l.restart = function() {
      l.reset(), l.play();
    }, l.reset(), l.autoplay && l.play(), l;
  }
  function removeTargetsFromAnimations(e, t) {
    for (var i = t.length; i--; )
      arrayContains(e, t[i].animatable.target) && t.splice(i, 1);
  }
  function removeTargets(e) {
    for (var t = parseTargets(e), i = activeInstances.length; i--; ) {
      var r = activeInstances[i], n = r.animations, o = r.children;
      removeTargetsFromAnimations(t, n);
      for (var a = o.length; a--; ) {
        var s = o[a], l = s.animations;
        removeTargetsFromAnimations(t, l), l.length || s.children.length || o.splice(a, 1);
      }
      n.length || o.length || r.pause();
    }
  }
  function stagger(e, t) {
    void 0 === t && (t = {});
    var i = t.direction || "normal", r = t.easing ? parseEasings(t.easing) : null, n = t.grid, o = t.axis, a = t.from || 0, s = "first" === a, l = "center" === a, c = "last" === a, u = is.arr(e), h = u ? parseFloat(e[0]) : parseFloat(e), d = u ? parseFloat(e[1]) : 0, f = getUnit(u ? e[1] : e) || 0, p = t.start || 0 + (u ? h : 0), v = [], m = 0;
    return function(e2, t2, g) {
      if (s && (a = 0), l && (a = (g - 1) / 2), c && (a = g - 1), !v.length) {
        for (var E = 0; E < g; E++) {
          if (n) {
            var y = l ? (n[0] - 1) / 2 : a % n[0], A = l ? (n[1] - 1) / 2 : Math.floor(a / n[0]), T = y - E % n[0], x = A - Math.floor(E / n[0]), _ = Math.sqrt(T * T + x * x);
            "x" === o && (_ = -T), "y" === o && (_ = -x), v.push(_);
          } else v.push(Math.abs(a - E));
          m = Math.max.apply(Math, v);
        }
        r && (v = v.map(function(e3) {
          return r(e3 / m) * m;
        })), "reverse" === i && (v = v.map(function(e3) {
          return o ? e3 < 0 ? -1 * e3 : -e3 : Math.abs(m - e3);
        }));
      }
      return p + (u ? (d - h) / m : h) * (Math.round(100 * v[t2]) / 100) + f;
    };
  }
  function timeline(e) {
    void 0 === e && (e = {});
    var t = anime(e);
    return t.duration = 0, t.add = function(i, r) {
      var n = activeInstances.indexOf(t), o = t.children;
      function a(e2) {
        e2.passThrough = true;
      }
      n > -1 && activeInstances.splice(n, 1);
      for (var s = 0; s < o.length; s++) a(o[s]);
      var l = mergeObjects(i, replaceObjectProps(defaultTweenSettings, e));
      l.targets = l.targets || e.targets;
      var c = t.duration;
      l.autoplay = false, l.direction = t.direction, l.timelineOffset = is.und(r) ? c : getRelativeValue(r, c), a(t), l.rewind = t.rewind, t.seek(l.timelineOffset);
      var u = anime(l);
      a(u), o.push(u);
      var h = getInstanceTimings(o, e);
      return t.delay = h.delay, t.endDelay = h.endDelay, t.duration = h.duration, t.seek(0), t.reset(), t.autoplay && t.play(), t;
    }, t;
  }
  "undefined" != typeof document && document.addEventListener("visibilitychange", handleVisibilityChange), anime.version = "3.2.0", anime.speed = 1, anime.running = activeInstances, anime.remove = removeTargets, anime.get = getOriginalTargetValue, anime.set = setTargetsValue, anime.convertPx = convertPxToUnit, anime.path = getPath, anime.setDashoffset = setDashoffset, anime.stagger = stagger, anime.timeline = timeline, anime.easing = parseEasings, anime.penner = penner, anime.random = function(e, t) {
    return Math.floor(Math.random() * (t - e + 1)) + e;
  };
  var InteractionStatesManager = function() {
    function e(e2) {
      this.i = e2;
    }
    return e.prototype.updateObject = function() {
      void 0 !== this.i.selectedState && this.i.states[this.i.selectedState].updateMatrix(this.i.object);
    }, e.prototype.updateCamera = function() {
      void 0 !== this.i.selectedState && "CombinedCamera" === this.i.object.objectType && (this.i.states[this.i.selectedState].updateMatrix(this.i.object), this.i.states[this.i.selectedState].updateCamera(this.i.object));
    }, e.prototype.updateGeometry = function() {
      void 0 !== this.i.selectedState && false !== isMeshEntity(this.i.object) && (this.i.states[this.i.selectedState].updateMatrix(this.i.object), this.i.states[this.i.selectedState].updateGeometry(this.i.object));
    }, e.prototype.updateSceneGraph = function(e2, t) {
      var i = new THREE.Matrix4(), r = new THREE.Matrix4();
      e2.updateWorldMatrix(true, false), r.getInverse(e2.matrixWorld);
      for (var n = 0, o = this.i.states.length; n < o; ++n) {
        var a = this.i.states[n];
        i.copy(r), null !== this.i.object.parent && (this.i.object.parent.updateWorldMatrix(true, false), i.multiply(this.i.object.parent.matrixWorld)), a.hiddenMatrix.premultiply(i);
      }
    }, e.prototype.updateMaterialLayer = function(e2) {
      if (void 0 !== this.i.selectedState && false !== isMeshEntity(this.i.object)) {
        var t = this.i.object.selectedMaterial, i = this.i.states[this.i.selectedState], r = (void 0 !== t ? i.material[t] : i.material).layersList.find(
          function(t2) {
            return t2.id === e2.id;
          }
        );
        null == r || r.copy(e2);
      }
    }, e.prototype.pushMaterialLayer = function(e2) {
      if (0 !== this.i.states.length && false !== isMeshEntity(this.i.object)) {
        var t = this.i.object;
        if (t.material instanceof Array) {
          var i = t.selectedMaterial;
          if (void 0 !== i)
            for (var r = 0, n = this.i.states.length; r < n; ++r) {
              var o = e2.clone();
              this.i.selectedState !== r && (o.uniforms["f" + o.id + "_alpha"].value = 0), this.i.states[r].material[i].layersList.push(o);
            }
        } else
          for (r = 0, n = this.i.states.length; r < n; ++r) {
            o = e2.clone();
            this.i.selectedState !== r && (o.uniforms["f" + o.id + "_alpha"].value = 0), this.i.states[r].material.layersList.push(o);
          }
      }
    }, e.prototype.popMaterialLayer = function() {
      if (0 !== this.i.states.length && false !== isMeshEntity(this.i.object)) {
        var e2 = this.i.object;
        if (e2.material instanceof Array) {
          var t = e2.selectedMaterial;
          if (void 0 !== t)
            for (var i = 0, r = this.i.states.length; i < r; ++i) {
              this.i.states[i].material[t].layersList.pop();
            }
        } else
          for (i = 0, r = this.i.states.length; i < r; ++i) {
            this.i.states[i].material.layersList.pop();
          }
      }
    }, e.prototype.removeMaterialLayer = function(e2) {
      if (0 === this.i.states.length || false === isMeshEntity(this.i.object))
        return null;
      var t = this.i.object, i = [];
      if (t.material instanceof Array)
        for (var r = 0, n = this.i.states.length; r < n; ++r) {
          var o = t.selectedMaterial;
          if (void 0 !== o) {
            var a = this.i.states[r].material[o];
            i.push({ layer: a.layersList[e2] }), a.layersList.splice(e2, 1);
          }
        }
      else
        for (r = 0, n = this.i.states.length; r < n; ++r) {
          a = this.i.states[r].material;
          i.push({ layer: a.layersList[e2] }), a.layersList.splice(e2, 1);
        }
      return { states: i, pos: e2 };
    }, e.prototype.restoreMaterialLayerRemoved = function(e2) {
      if (0 !== this.i.states.length && false !== isMeshEntity(this.i.object)) {
        var t = this.i.object;
        if (t.material instanceof Array)
          for (var i = 0, r = this.i.states.length; i < r; ++i) {
            var n = t.selectedMaterial;
            if (void 0 !== n)
              this.i.states[i].material[n].layersList.splice(
                e2.pos,
                0,
                e2.states[i].layer
              );
          }
        else
          for (i = 0, r = this.i.states.length; i < r; ++i) {
            this.i.states[i].material.layersList.splice(
              e2.pos,
              0,
              e2.states[i].layer
            );
          }
      }
    }, e.prototype.changeMaterialLayer = function(e2) {
      if (0 === this.i.states.length || false === isMeshEntity(this.i.object))
        return null;
      var t = this.i.object, i = [], r = 0;
      if (t.material instanceof Array) {
        var n = t.selectedMaterial;
        if (void 0 !== n) {
          for (var o = 0, a = (c = this.i.states[Number(this.i.selectedState)].material[n].layersList).length; o < a; ++o)
            if (c[o].id === e2.id) {
              r = o;
              break;
            }
          for (o = 0, a = this.i.states.length; o < a; ++o) {
            var s = this.i.states[o].material[n].layersList[r], l = e2.clone();
            this.i.selectedState !== o && (l.uniforms["f" + l.id + "_alpha"].value = Number(
              s.uniforms["f" + s.id + "_alpha"].value
            )), this.i.states[o].material[n].layersList[r] = l, i.push({ layer: s });
          }
        }
      } else {
        var c;
        for (o = 0, a = (c = this.i.states[Number(this.i.selectedState)].material.layersList).length; o < a; ++o)
          if (c[o].id === e2.id) {
            r = o;
            break;
          }
        for (o = 0, a = this.i.states.length; o < a; ++o) {
          s = this.i.states[o].material.layersList[r], l = e2.clone();
          this.i.selectedState !== o && (l.uniforms["f" + l.id + "_alpha"].value = Number(
            s.uniforms["f" + s.id + "_alpha"].value
          )), this.i.states[o].material.layersList[r] = l, i.push({ layer: s });
        }
      }
      return { states: i, pos: r };
    }, e.prototype.restoreMaterialLayerChanged = function(e2) {
      if (0 !== this.i.states.length && false !== isMeshEntity(this.i.object)) {
        var t = this.i.object;
        if (t.material instanceof Array) {
          var i = t.selectedMaterial;
          if (void 0 !== i)
            for (var r = 0, n = this.i.states.length; r < n; ++r)
              this.i.states[r].material[i].layersList[e2.pos] = e2.states[r].layer;
        } else
          for (r = 0, n = this.i.states.length; r < n; ++r)
            this.i.states[r].material.layersList[e2.pos] = e2.states[r].layer;
      }
    }, e.prototype.moveMaterialLayer = function(e2, t) {
      if (0 !== this.i.states.length && false !== isMeshEntity(this.i.object)) {
        var i = this.i.object;
        if (i.material instanceof Array) {
          var r = i.selectedMaterial;
          if (void 0 !== r)
            for (var n = 0, o = this.i.states.length; n < o; ++n) {
              var a = (s = this.i.states[n].material[r].layersList)[e2];
              s[e2] = s[t], s[t] = a;
            }
        } else
          for (n = 0, o = this.i.states.length; n < o; ++n) {
            var s;
            a = (s = this.i.states[n].material.layersList)[e2];
            s[e2] = s[t], s[t] = a;
          }
      }
    }, e.prototype.restoreMaterialLayerMoved = function(e2, t) {
      this.moveMaterialLayer(e2, t);
    }, e.prototype.setMaterialLayers = function(e2) {
      var t = this.i.object, i = [];
      if (t.material instanceof Array) {
        var r = t.selectedMaterial;
        if (void 0 !== r)
          for (var n = 0, o = this.i.states.length; n < o; ++n) {
            var a = this.i.states[n].material[r];
            i.push({ layersList: a.layersList });
            var s = e2.head;
            for (a.layersList = []; void 0 !== s; )
              a.layersList.push(s.clone()), s = s.next;
          }
      } else
        for (n = 0, o = this.i.states.length; n < o; ++n) {
          a = this.i.states[n].material;
          i.push({ layersList: a.layersList });
          s = e2.head;
          for (a.layersList = []; void 0 !== s; )
            a.layersList.push(s.clone()), s = s.next;
        }
      return { states: i };
    }, e.prototype.restoreMaterialLayersSet = function(e2) {
      var t = this.i.object;
      if (t.material instanceof Array) {
        var i = t.selectedMaterial;
        if (void 0 !== i)
          for (var r = 0, n = this.i.states.length; r < n; ++r)
            this.i.states[r].material[i].layersList = e2.states[r].layersList;
      } else
        for (r = 0, n = this.i.states.length; r < n; ++r)
          this.i.states[r].material.layersList = e2.states[r].layersList;
    }, e;
  }();
  function serialize(e, t, i) {
    return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(i)), t.uuid;
  }
  function serializeGeometry(e, t) {
    if (void 0 === e[t.uuid])
      if ("NonParametricGeometry" === t.userData.type) {
        var i = t.originalGeometry;
        if (void 0 !== i) {
          var r = t.userData;
          (t = i).userData = r;
        }
        e[t.uuid] = t.toJSON();
      } else {
        if ("VectorGeometry" === (r = t.userData).type) {
          var n = t.userData.shape;
          r = Object.assign({}, r, { shape: n.toJSON() });
        }
        e[t.uuid] = { uuid: t.uuid, userData: r };
      }
    return t.uuid;
  }
  function extractFromCache(e) {
    var t = [];
    for (var i in e) {
      var r = e[i];
      delete r.metadata, t.push(r);
    }
    return t;
  }
  var Interaction = function() {
    function e(e2) {
      this.object = e2, this.uuid = THREE.MathUtils.generateUUID(), this.states = [], this.events = [], this.statesManager = new InteractionStatesManager(this);
    }
    return e.prototype.computeCache = function() {
      return this.cache = {
        mouseDown: this.events.find(function(e2) {
          return e2.type === INTERACTION_EVENT.MOUSE_DOWN;
        }),
        mouseUp: this.events.find(function(e2) {
          return e2.type === INTERACTION_EVENT.MOUSE_UP;
        }),
        mouseHover: this.events.find(function(e2) {
          return e2.type === INTERACTION_EVENT.MOUSE_HOVER;
        }),
        start: this.events.find(function(e2) {
          return e2.type === INTERACTION_EVENT.START;
        }),
        lookAt: this.events.find(function(e2) {
          return e2.type === INTERACTION_EVENT.LOOK_AT;
        }),
        follow: this.events.find(function(e2) {
          return e2.type === INTERACTION_EVENT.FOLLOW;
        }),
        keyDown: this.events.filter(function(e2) {
          return e2.type === INTERACTION_EVENT.KEY_DOWN;
        }),
        keyUp: this.events.filter(function(e2) {
          return e2.type === INTERACTION_EVENT.KEY_UP;
        })
      }, this.cache;
    }, e.prototype.newState = function(e2) {
      var t = new InteractionState();
      return t.name = e2, t.update(this.object), this.selectedState = this.states.length, this.states.push(t), t;
    }, e.prototype.addState = function(e2, t) {
      this.states.splice(t, 0, e2);
    }, e.prototype.removeState = function(e2) {
      this.selectedState === e2 && (this.selectedState = void 0), this.states.splice(e2, 1);
    }, e.prototype.selectState = function(e2) {
      void 0 !== e2 && this.states[e2].execute(this.object), this.selectedState = e2;
    }, e.prototype.hasEventType = function(e2, t) {
      return e2 === INTERACTION_EVENT.KEY_DOWN || e2 === INTERACTION_EVENT.KEY_UP ? void 0 !== t && this.events.some(function(i) {
        return i.type === e2 && i.key === t;
      }) : this.events.some(function(t2) {
        return t2.type === e2;
      });
    }, e.prototype.newEvent = function() {
      var e2 = this, t = [
        INTERACTION_EVENT.MOUSE_DOWN,
        INTERACTION_EVENT.MOUSE_UP,
        INTERACTION_EVENT.MOUSE_HOVER,
        INTERACTION_EVENT.KEY_DOWN
      ].find(function(t2) {
        return false === e2.hasEventType(t2);
      }), i = new InteractionEvent(t);
      return this.events.push(i), i;
    }, e.prototype.addEvent = function(e2, t) {
      this.events.splice(t, 0, e2);
      for (var i = this.events[t].targets, r = 0, n = i.length; r < n; ++r)
        void 0 !== i[r].object && interactionTargets.add(i[r]);
    }, e.prototype.removeEvent = function(e2) {
      for (var t = this.events[e2].targets, i = 0, r = t.length; i < r; ++i)
        void 0 !== t[i].object && interactionTargets.delete(t[i]);
      this.events.splice(e2, 1);
    }, e.prototype.copy = function(e2) {
      this.selectedState = e2.selectedState;
      for (var t = 0, i = e2.states.length; t < i; ++t)
        this.addState(e2.states[t].clone(), t);
      for (t = 0, i = e2.events.length; t < i; ++t) {
        this.addEvent(e2.events[t].clone(), t);
        for (var r = e2.events[t].targets, n = 0, o = r.length; n < o; ++n) {
          var a = r[n].clone();
          r[n].object === e2.object ? (a.object = this.object, a.state = this.states[e2.states.indexOf(r[n].state)]) : (a.object = r[n].object, a.state = r[n].state), this.events[t].addTarget(a, n);
        }
      }
      return this;
    }, e.prototype.clone = function(t) {
      return new e(t).copy(this);
    }, e.prototype.toJSON = function(e2) {
      void 0 === e2 && (e2 = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        interactionStates: {}
      });
      var t = { uuid: this.uuid };
      if (void 0 !== this.selectedState && (t.selectedState = this.selectedState), this.states.length > 0) {
        t.states = [];
        for (var i = 0, r = this.states.length; i < r; ++i)
          t.states.push(serialize(e2.interactionStates, this.states[i], e2));
      }
      if (this.events.length > 0) {
        t.events = [];
        for (i = 0, r = this.events.length; i < r; ++i)
          t.events.push(this.events[i].toJSON());
      }
      return t;
    }, e.prototype.fromJSON = function(e2, t, i) {
      if (this.uuid = e2.uuid, this.selectedState = e2.selectedState, this.states = [], this.events = [], void 0 !== e2.states)
        for (var r = 0, n = e2.states.length; r < n; ++r)
          this.states.push(i[e2.states[r]]);
      if (void 0 !== e2.events)
        for (r = 0, n = e2.events.length; r < n; ++r)
          this.events.push(
            new InteractionEvent().fromJSON(e2.events[r], t, i)
          );
      return this;
    }, e.prototype.start = function() {
      void 0 !== this._animation && (this._animation.pause(), this._animation = void 0, this._removeBackLayer()), this.states.length > 1 ? (this.states[0].execute(this.object), this._currentState = this.states[0], this._prevState = void 0) : void 0 !== this._state0 ? this._state0.execute(this.object) : this.events.some(function(e2) {
        return e2.type === INTERACTION_EVENT.LOOK_AT || e2.type === INTERACTION_EVENT.FOLLOW;
      }) && (this._state0 = new InteractionState(), this._state0.update(this.object));
    }, e.prototype.end = function() {
      var e2;
      void 0 !== this._animation && (this._animation.pause(), this._animation = void 0, this._removeBackLayer()), this.states.length > 1 ? this.states[null !== (e2 = this.selectedState) && void 0 !== e2 ? e2 : 0].execute(this.object) : void 0 !== this._state0 && (this._state0.execute(this.object), this._state0 = void 0), this._currentState = void 0, this._prevState = void 0;
    }, e.prototype.lookAt = function(e2) {
      this.object.lookAt(e2);
    }, e.prototype.follow = function(e2) {
      this.object.position.copy(e2), null !== this.object.parent && this.object.position.applyMatrix4(
        new THREE.Matrix4().getInverse(this.object.parent.matrixWorld)
      ), this.object.position.applyMatrix4(
        new THREE.Matrix4().getInverse(this.object.hiddenMatrix)
      );
    }, e.prototype.play = function(e2) {
      this.object.visible && void 0 !== e2.state && this.animate(e2.state, e2);
    }, e.prototype.reverse = function(e2) {
      this.object.visible && void 0 !== this._prevState && this.animate(this._prevState, e2);
    }, e.prototype._removeBackLayer = function() {
      if ("material" in this.object) {
        var e2 = this.object.material;
        if (e2 instanceof Array)
          for (var t = 0, i = e2.length; t < i; ++t)
            for (var r = (o = e2[t].layersList).head; r; )
              if (r.backLayer) {
                delete r.backLayer;
                var n = r.next;
                o.removeLayer(r.id), r = n;
              } else
                r.isBack ? (delete r.isBack, r = r.next) : r = r.next;
        else {
          var o;
          for (r = (o = e2.layersList).head; r; )
            for (; r; )
              if (r.backLayer) {
                delete r.backLayer;
                n = r.next;
                o.removeLayer(r.id), r = n;
              } else
                r.isBack ? (delete r.isBack, r = r.next) : r = r.next;
        }
      }
    }, e.prototype.getTimingFunction = function(e2, t, i) {
      switch (e2) {
        case INTERACTION_EASING.LINEAR:
          return "cubicBezier( 0, 0, 1, 1 )";
        case INTERACTION_EASING.EASE:
          return "cubicBezier( .25, .1, .25, 1 )";
        case INTERACTION_EASING.EASE_IN:
          return "cubicBezier( .42, 0, 1, 1 )";
        case INTERACTION_EASING.EASE_OUT:
          return "cubicBezier( 0, 0, .58, 1 )";
        case INTERACTION_EASING.EASE_IN_OUT:
          return "cubicBezier( .42, 0, .58, 1 )";
        case INTERACTION_EASING.CUBIC:
          return "cubicBezier( " + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + " )";
        case INTERACTION_EASING.SPRING:
          return "spring( " + i.mass + ", " + i.stiffness + ", " + i.damping + ", " + i.velocity + " )";
      }
    }, e.prototype.animate = function(e2, t) {
      var i, r, n, o, a, s, l = this;
      if (this._currentState === e2) {
        if (null === (i = this._animation) || void 0 === i ? void 0 : i.reversed) {
          var c = null !== (n = null === (r = this._animation) || void 0 === r ? void 0 : r.currentTime) && void 0 !== n ? n : 0;
          null === (o = this._animation) || void 0 === o || o.reset(), null === (a = this._animation) || void 0 === a || a.seek(c), null === (s = this._animation) || void 0 === s || s.play();
        }
      } else
        this._prevState = this._currentState, this._currentState = e2, void 0 !== this._animation && this._animation.pause(), this._removeBackLayer(), true === t.cycle && true === t.repeat ? this._animation = anime.timeline({
          duration: t.duration,
          delay: t.delay / 2,
          endDelay: t.delay / 2,
          direction: "alternate",
          loop: true,
          rewind: t.rewind,
          easing: this.getTimingFunction(
            t.easing,
            t.cubicControls,
            t.springParameters
          )
        }) : true === t.cycle && false === t.repeat ? this._animation = anime.timeline({
          duration: t.duration,
          delay: t.delay,
          endDelay: t.delay / 2,
          direction: "alternate",
          rewind: t.rewind,
          easing: this.getTimingFunction(
            t.easing,
            t.cubicControls,
            t.springParameters
          )
        }) : false === t.cycle && true === t.repeat ? this._animation = anime.timeline({
          duration: t.duration,
          delay: t.delay,
          direction: "normal",
          loop: true,
          easing: this.getTimingFunction(
            t.easing,
            t.cubicControls,
            t.springParameters
          )
        }) : this._animation = anime.timeline({
          duration: t.duration,
          delay: t.delay,
          direction: "normal",
          easing: this.getTimingFunction(
            t.easing,
            t.cubicControls,
            t.springParameters
          )
        }), this._animation.finished.then(
          function() {
            l._removeBackLayer();
          },
          function() {
          }
        ), this.animateMatrix(e2), this.animateGeometry(e2), this.animateMaterial(e2), this.animateCamera(e2);
    }, e.prototype.animateMatrix = function(e2) {
      var t, i, r, n, o = this;
      if (false === this.object.position.equals(e2.position)) {
        var a = this.object.position.clone(), s = { t: 0 };
        null === (t = this._animation) || void 0 === t || t.add(
          {
            targets: s,
            t: 1,
            update: function() {
              o.object.position.lerpVectors(a, e2.position, s.t);
            }
          },
          0
        );
      }
      if (false === this.object.scale.equals(e2.scale)) {
        var l = this.object.scale.clone(), c = { t: 0 };
        null === (i = this._animation) || void 0 === i || i.add(
          {
            targets: c,
            t: 1,
            update: function() {
              o.object.scale.lerpVectors(l, e2.scale, c.t);
            }
          },
          0
        );
      }
      if (false === this.object.rotation.equals(e2.rotation)) {
        var u = this.object.quaternion.clone(), h = { t: 0 }, d = {
          x: this.object.rotation.x - e2.rotation.x,
          y: this.object.rotation.y - e2.rotation.y,
          z: this.object.rotation.z - e2.rotation.z
        }, f = e2.rotation.clone(), p = 0.01 * THREE.MathUtils.DEG2RAD, v = 359.99 * THREE.MathUtils.DEG2RAD;
        d.x === 2 * Math.PI ? 0 === f.x ? f.x = p : f.x === 2 * Math.PI && (f.x = v) : d.x === 2 * -Math.PI && (0 === f.x ? f.x = -p : f.x === 2 * Math.PI && (f.x = -v)), d.y === 2 * Math.PI ? 0 === f.y ? f.y = p : f.y === 2 * Math.PI && (f.y = v) : d.y === 2 * -Math.PI && (0 === f.y ? f.y = -p : f.y === 2 * Math.PI && (f.y = -v)), d.z === 2 * Math.PI ? 0 === f.z ? f.z = p : f.z === 2 * Math.PI && (f.z = v) : d.z === 2 * -Math.PI && (0 === f.z ? f.z = -p : f.z === 2 * Math.PI && (f.z = -v));
        var m = new THREE.Quaternion().setFromEuler(f);
        null === (r = this._animation) || void 0 === r || r.add(
          {
            targets: h,
            t: 1,
            update: function() {
              slerp(u, m, o.object.quaternion, h.t);
            }
          },
          0
        );
      }
      var g = new THREE.Vector3(), E = new THREE.Quaternion(), y = new THREE.Vector3(), A = new THREE.Vector3(), T = new THREE.Quaternion(), x = new THREE.Vector3(), _ = new THREE.Vector3(), w = new THREE.Quaternion(), S = new THREE.Vector3();
      if (e2.hiddenMatrix.decompose(A, T, x), "hiddenMatrix" in this.object && (this.object.hiddenMatrix.decompose(g, E, y), false === this.object.hiddenMatrix.equals(e2.hiddenMatrix))) {
        var b = { t: 0 }, R = this.object.hiddenMatrix;
        null === (n = this._animation) || void 0 === n || n.add(
          {
            targets: b,
            t: 1,
            update: function() {
              THREE.Quaternion.slerp(E, T, w, b.t), _.lerpVectors(g, A, b.t), S.lerpVectors(y, x, b.t), R.compose(_, w, S);
            }
          },
          0
        );
      }
    }, e.prototype.animateGeometry = function(e2) {
      var t;
      if ("geometry" in this.object && void 0 !== e2.geometry) {
        var i = this.object.geometry.userData.parameters, r = e2.geometry;
        if (r.width !== i.width || r.height !== i.height || r.depth !== i.depth) {
          var n = this.object;
          null === (t = this._animation) || void 0 === t || t.add(
            {
              targets: i,
              width: r.width,
              height: r.height,
              depth: r.depth,
              update: function() {
                n.updateGeometry({
                  parameters: {
                    width: i.width,
                    height: i.height,
                    depth: i.depth
                  }
                });
              }
            },
            0
          );
        }
      }
    }, e.prototype.animateMaterial = function(e2) {
      var t = this;
      if ("material" in this.object) {
        var i = function(e3, i2, r2, n2) {
          var o2, a2, s2, l2, c;
          void 0 === n2 && (n2 = i2.paramNames);
          for (var u = e3.layersList, h = function(e4, c2) {
            var h2 = n2[e4], d2 = "f" + i2.id + "_" + h2, f2 = "f" + r2.id + "_" + h2, p2 = i2.uniforms[d2], v2 = r2.uniforms[f2];
            if ("mode" === h2 || "boolean" == typeof p2.value)
              return p2.value !== v2.value && ("boolean" == typeof p2.value ? p2.value = v2.value : p2.value = Number(v2.value), u.updateLayerUniformByLayer(i2, d2)), "continue";
            if ("number" == typeof p2.value)
              return p2.value !== v2.value && (null === (o2 = t._animation) || void 0 === o2 || o2.add(
                {
                  targets: p2,
                  value: Number(v2.value),
                  update: function() {
                    u.updateLayerUniformByLayer(i2, d2);
                  }
                },
                0
              )), "continue";
            if ("isVector2" in p2.value) {
              var m2 = v2.value;
              return false === (g = p2.value).equals(m2) && (null === (a2 = t._animation) || void 0 === a2 || a2.add(
                {
                  targets: g,
                  x: m2.x,
                  y: m2.y,
                  update: function() {
                    u.updateLayerUniformByLayer(i2, d2);
                  }
                },
                0
              )), "continue";
            }
            if ("isVector3" in p2.value) {
              m2 = v2.value;
              return false === (g = p2.value).equals(m2) && (null === (s2 = t._animation) || void 0 === s2 || s2.add(
                {
                  targets: g,
                  x: m2.x,
                  y: m2.y,
                  z: m2.z,
                  update: function() {
                    u.updateLayerUniformByLayer(i2, d2);
                  }
                },
                0
              )), "continue";
            }
            if ("isColor" in p2.value) {
              var g;
              m2 = v2.value;
              return false === (g = p2.value).equals(m2) && (null === (l2 = t._animation) || void 0 === l2 || l2.add(
                {
                  targets: g,
                  r: m2.r,
                  g: m2.g,
                  b: m2.b,
                  update: function() {
                    u.updateLayerUniformByLayer(i2, d2);
                  }
                },
                0
              )), "continue";
            }
          }, d = 0, f = n2.length; d < f; ++d)
            h(d);
          if (i2.backLayer) {
            var p = i2.backLayer.id, v = "f" + p + "_alpha", m = i2.backLayer.uniforms[v];
            null === (c = t._animation) || void 0 === c || c.add(
              {
                targets: m,
                value: 0,
                update: function() {
                  u.updateLayerUniform(p, v);
                }
              },
              0
            );
          }
        }, r = function(e3, i2, r2) {
          var n2, o2 = e3.layersList;
          if (void 0 === i2.backLayer) {
            var a2 = r2.getValues();
            a2.alpha = 0, i2.backLayer = o2.addLayerBeforeAt(a2, i2), i2.backLayer.isBack = true, e3.dispose();
          }
          var s2 = "f" + i2.id + "_alpha", l2 = "f" + i2.backLayer.id + "_alpha", c = i2.uniforms[s2], u = i2.backLayer.uniforms[l2];
          null === (n2 = t._animation) || void 0 === n2 || n2.add(
            {
              targets: c,
              value: 0,
              update: function() {
                o2.updateLayerUniformByLayer(i2, s2);
              }
            },
            0
          ).add(
            {
              targets: u,
              value: Number(r2.uniforms["f" + r2.id + "_alpha"].value),
              update: function() {
                i2.backLayer && o2.updateLayerUniformByLayer(i2.backLayer, l2);
              }
            },
            0
          );
        }, n = function(e3, r2, n2) {
          var o2, a2 = e3.layersList, s2 = "f" + r2.id + "_mat", l2 = "f" + r2.id + "_texture", c = r2.uniforms[l2].value, u = n2.uniforms["f" + n2.id + "_texture"].value, h = r2.uniforms["f" + r2.id + "_crop"], d = n2.uniforms["f" + n2.id + "_crop"];
          h.value !== d.value && (h.value = Number(d.value), a2.updateLayerUniformByLayer(r2, "f" + r2.id + "_crop")), c.wrapS === u.wrapS && c.wrapT === u.wrapT || (c.wrapS = u.wrapS, c.wrapT = u.wrapT, c.needsUpdate = true, a2.updateLayerUniformByLayer(r2, l2));
          var f = c.matrix, p = u.matrix;
          if (false === f.equals(p)) {
            var v = {
              repeatX: c.repeat.x,
              repeatY: c.repeat.y,
              offsetX: c.offset.x,
              offsetY: c.offset.y
            };
            null === (o2 = t._animation) || void 0 === o2 || o2.add(
              {
                targets: v,
                repeatX: u.repeat.x,
                repeatY: u.repeat.y,
                offsetX: u.offset.x,
                offsetY: u.offset.y,
                update: function() {
                  c.repeat.set(v.repeatX, v.repeatY), c.offset.set(v.offsetX, v.offsetY), c.updateMatrix(), a2.updateLayerUniformByLayer(r2, s2);
                }
              },
              0
            );
          }
          i(e3, r2, n2, ["alpha", "mode"]);
        }, o = function(e3, r2, n2) {
          var o2, a2 = e3.layersList, s2 = r2.uniforms["f" + r2.id + "_num"], l2 = n2.uniforms["f" + n2.id + "_num"], c = "f" + r2.id + "_steps", u = "f" + n2.id + "_steps", h = r2.uniforms[c], d = n2.uniforms[u], f = "f" + r2.id + "_colors", p = "f" + n2.id + "_colors", v = r2.uniforms[f], m = n2.uniforms[p];
          if (s2.value <= l2.value) {
            for (var g = v.value[s2.value - 1], E = Number(s2.value); E < l2.value; ++E)
              h.value[E] = 1, a2.updateLayerUniformByLayer(r2, f), v.value[E].set(g.x, g.y, g.z, g.w), a2.updateLayerUniformByLayer(r2, c);
            s2.value !== l2.value && (s2.value = Number(l2.value), a2.updateLayerUniformByLayer(r2, "f" + r2.id + "_num"));
            var y = function(e4) {
              var i2 = v.value[e4], n3 = m.value[e4], s3 = h.value[e4], l3 = d.value[e4];
              if (s3 !== l3 || false === i2.equals(n3)) {
                var u2 = { value: s3 };
                null === (o2 = t._animation) || void 0 === o2 || o2.add(
                  {
                    targets: [u2, i2],
                    value: l3,
                    x: n3.x,
                    y: n3.y,
                    z: n3.z,
                    w: n3.w,
                    update: function() {
                      h.value[e4] = u2.value, a2.updateLayerUniformByLayer(r2, c), a2.updateLayerUniformByLayer(r2, f);
                    }
                  },
                  0
                );
              }
            };
            for (E = 0; E < l2.value; ++E) y(E);
          } else {
            var A = [], T = function(e4) {
              var i2 = v.value[e4], n3 = m.value[e4];
              h.value[e4] === d.value[e4] && false !== i2.equals(n3) || A.push(
                new Promise(function(o3) {
                  var s3, l3 = { value: h.value[e4] };
                  null === (s3 = t._animation) || void 0 === s3 || s3.add(
                    {
                      targets: [l3, i2],
                      value: d.value[e4],
                      x: n3.x,
                      y: n3.y,
                      z: n3.z,
                      w: n3.w,
                      update: function() {
                        h.value[e4] = l3.value, a2.updateLayerUniformByLayer(r2, c), a2.updateLayerUniformByLayer(r2, f);
                      },
                      complete: function() {
                        o3(e4);
                      }
                    },
                    0
                  );
                })
              );
            };
            for (E = 0; E < l2.value; ++E) T(E);
            var x = m.value[l2.value - 1], _ = function(e4) {
              var i2 = v.value[e4];
              h.value[e4] === d.value[e4] && false !== i2.equals(x) || A.push(
                new Promise(function(n3) {
                  var o3, s3 = { value: h.value[e4] };
                  null === (o3 = t._animation) || void 0 === o3 || o3.add(
                    {
                      targets: [s3, i2],
                      value: 1,
                      x: x.x,
                      y: x.y,
                      z: x.z,
                      w: x.w,
                      update: function() {
                        h.value[e4] = s3.value, a2.updateLayerUniformByLayer(r2, c), a2.updateLayerUniformByLayer(r2, f);
                      },
                      complete: function() {
                        n3(e4);
                      }
                    },
                    0
                  );
                })
              );
            };
            for (E = Number(l2.value); E < s2.value; ++E) _(E);
            Promise.all(A).then(
              function() {
                s2.value = Number(l2.value), a2.updateLayerUniformByLayer(r2, "f" + r2.id + "_num");
              },
              function() {
              }
            );
          }
          i(e3, r2, n2, [
            "alpha",
            "mode",
            "gl_type",
            "smooth",
            "offset",
            "morph",
            "angle"
          ]);
        };
        if (this.object.material instanceof Array)
          for (var a = 0, s = this.object.material.length; a < s; ++a)
            l(this.object.material[a], e2.material[a]);
        else l(this.object.material, e2.material);
      }
      function l(e3, t2) {
        for (var a2 = e3.layersList.head, s2 = 0; a2; )
          if (true !== a2.isBack) {
            var l2 = t2.layersList[s2++];
            if ("texture" === a2.type) {
              var c = a2.uniforms["f" + a2.id + "_texture"].value, u = l2.uniforms["f" + l2.id + "_texture"].value;
              c.image === u.image ? n(e3, a2, l2) : r(e3, a2, l2);
            } else
              "gradient" === a2.type ? a2.uniforms["f" + a2.id + "_gl_type"].value === l2.uniforms["f" + l2.id + "_gl_type"].value ? o(e3, a2, l2) : r(e3, a2, l2) : i(e3, a2, l2);
            a2 = a2.next;
          } else a2 = a2.next;
      }
    }, e.prototype.animateCamera = function(e2) {
      var t;
      if ("CombinedCamera" === this.object.objectType && void 0 !== e2.camera) {
        var i = this.object, r = "OrthographicCamera" === i.cameraType ? e2.camera.zoomOrtho : e2.camera.zoomPersp;
        i.zoom !== r && (null === (t = this._animation) || void 0 === t || t.add(
          {
            targets: i,
            zoom: r,
            update: function() {
              i.updateProjectionMatrix();
            }
          },
          0
        ));
      }
    }, e;
  }(), Object3DMixin = function(e) {
    return function(e2) {
      function t() {
        return null !== e2 && e2.apply(this, arguments) || this;
      }
      return __extends(t, e2), t.prototype.hasEntityChild = function() {
        return this.children.some(function(e3) {
          return isEntity(e3);
        });
      }, t.prototype.attach = function(e3, t2) {
        this.updateWorldMatrix(true, false);
        var i = new THREE.Matrix4().getInverse(this.matrixWorld);
        return null !== e3.parent && (e3.parent.updateWorldMatrix(true, false), i.multiply(e3.parent.matrixWorld)), isEntity(e3) ? e3.hiddenMatrix.premultiply(i) : e3.applyMatrix4(i), e3.updateWorldMatrix(false, false), this.add(e3), void 0 !== t2 && (this.children.pop(), this.children.splice(t2, 0, e3)), this;
      }, t.prototype.toJSON = function(e3) {
        var t2, i, r = void 0 === e3, n = { object: { uuid: "", objectType: "" } };
        void 0 === e3 && (e3 = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          interactionStates: {}
        }, n.metadata = {
          version: 1.4,
          type: "Object",
          generator: "Object3D.toJSON"
        });
        var o = { uuid: this.uuid, objectType: this.type };
        if ("" !== this.name && (o.name = this.name), o.matrix = this.matrix.toArray(), true === this.castShadow && (o.castShadow = true), true === this.receiveShadow && (o.receiveShadow = true), false === this.visible && (o.visible = false), false === this.frustumCulled && (o.frustumCulled = false), 0 !== this.renderOrder && (o.renderOrder = this.renderOrder), o.layers = this.layers.mask, "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), this.children.length > 0) {
          o.children = [];
          try {
            for (var a = __values(this.children), s = a.next(); !s.done; s = a.next()) {
              var l = s.value;
              (isEntity(l) || l instanceof THREE.Light) && o.children.push(l.toJSON(e3).object);
            }
          } catch (e4) {
            t2 = { error: e4 };
          } finally {
            try {
              s && !s.done && (i = a.return) && i.call(a);
            } finally {
              if (t2) throw t2.error;
            }
          }
        }
        if (r) {
          var c = extractFromCache(e3.geometries), u = extractFromCache(e3.materials), h = extractFromCache(e3.textures), d = extractFromCache(e3.images), f = extractFromCache(e3.interactionStates);
          c.length > 0 && (n.geometries = c), u.length > 0 && (n.materials = u), h.length > 0 && (n.textures = h), d.length > 0 && (n.images = d), f.length > 0 && (n.interactionStates = f);
        }
        return n.object = o, n;
      }, t.prototype.fromJSON = function(e3) {
        return this.uuid = e3.uuid, void 0 !== e3.name && (this.name = e3.name), void 0 !== e3.matrix ? (this.matrix.fromArray(e3.matrix), void 0 !== e3.matrixAutoUpdate && (this.matrixAutoUpdate = e3.matrixAutoUpdate), this.matrixAutoUpdate && this.matrix.decompose(
          this.position,
          this.quaternion,
          this.scale
        )) : (void 0 !== e3.position && this.position.fromArray(e3.position), void 0 !== e3.rotation && this.rotation.fromArray(e3.rotation), void 0 !== e3.quaternion && this.quaternion.fromArray(e3.quaternion), void 0 !== e3.scale && this.scale.fromArray(e3.scale)), void 0 !== e3.castShadow && (this.castShadow = e3.castShadow), void 0 !== e3.receiveShadow && (this.receiveShadow = e3.receiveShadow), void 0 !== e3.visible && (this.visible = e3.visible), void 0 !== e3.frustumCulled && (this.frustumCulled = e3.frustumCulled), void 0 !== e3.renderOrder && (this.renderOrder = e3.renderOrder), void 0 !== e3.layers && (this.layers.mask = e3.layers), void 0 !== e3.userData && (this.userData = e3.userData), this;
      }, t;
    }(e);
  }, isEntity$1 = function(e) {
    return "isEntity" in e;
  }, isHelperableEntity$1 = function(e) {
    return "objectHelper" in e;
  }, EntityMixin = function(e) {
    return function(e2) {
      function t() {
        var t2 = null !== e2 && e2.apply(this, arguments) || this;
        return t2.objectType = "", t2.isEntity = true, t2.raycastLock = false, t2.scaleLock = false, t2.hiddenMatrix = new THREE.Matrix4(), t2.interaction = new Interaction(t2), t2.forceComputeSize = false, t2;
      }
      return __extends(t, e2), Object.defineProperty(t.prototype, "visibility", {
        get: function() {
          return this.visible;
        },
        set: function(e3) {
          var t2, i;
          this.visible = e3;
          try {
            for (var r = __values(this.children), n = r.next(); !n.done; n = r.next()) {
              var o = n.value;
              isEntity$1(o) && o.traverseEntity(function(t3) {
                isHelperableEntity$1(t3) && t3.visible && (t3.objectHelper.visible = e3);
              });
            }
          } catch (e4) {
            t2 = { error: e4 };
          } finally {
            try {
              n && !n.done && (i = r.return) && i.call(r);
            } finally {
              if (t2) throw t2.error;
            }
          }
        },
        enumerable: false,
        configurable: true
      }), Object.defineProperty(t.prototype, "interactionCache", {
        get: function() {
          return void 0 === this.interaction.cache && this.interaction.computeCache(), this.interaction.cache;
        },
        enumerable: false,
        configurable: true
      }), t.prototype.traverseEntity = function(e3) {
        var t2, i;
        e3(this);
        try {
          for (var r = __values(this.children), n = r.next(); !n.done; n = r.next()) {
            var o = n.value;
            isEntity$1(o) && o.traverseEntity(e3);
          }
        } catch (e4) {
          t2 = { error: e4 };
        } finally {
          try {
            n && !n.done && (i = r.return) && i.call(r);
          } finally {
            if (t2) throw t2.error;
          }
        }
      }, t.prototype.computeSingleBoundingBox = function() {
        this.singleBoundingBox || (this.singleBoundingBox = new Box3()), this.singleBoundingBox.setFromObjectSize(this, false), this.singleBoundingBox.computeVertices(), this.singleBoundingBox.computeEdges(), this.singleBoundingBox.computeFaces();
      }, t.prototype.computeComplexBoundingBox = function(e3) {
        this.complexBoundingBox || (this.complexBoundingBox = new Box3()), this.complexBoundingBox.setFromObjectSize(this, e3), this.complexBoundingBox.computeVertices(), this.complexBoundingBox.computeEdges(), this.complexBoundingBox.computeFaces();
      }, t.prototype.updateMatrixWorld = function(e3) {
        var t2, i;
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e3) && (null === this.parent ? this.matrixWorld.multiplyMatrices(
          this.hiddenMatrix,
          this.matrix
        ) : (this.matrixWorld.multiplyMatrices(
          this.parent.matrixWorld,
          this.hiddenMatrix
        ), this.matrixWorld.multiplyMatrices(
          this.matrixWorld,
          this.matrix
        )), this.matrixWorldNeedsUpdate = false, e3 = true);
        try {
          for (var r = __values(this.children), n = r.next(); !n.done; n = r.next()) {
            n.value.updateMatrixWorld(e3);
          }
        } catch (e4) {
          t2 = { error: e4 };
        } finally {
          try {
            n && !n.done && (i = r.return) && i.call(r);
          } finally {
            if (t2) throw t2.error;
          }
        }
      }, t.prototype.updateWorldMatrix = function(e3, t2) {
        var i, r, n = this.parent;
        if (e3 && null !== n && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.multiplyMatrices(
          this.hiddenMatrix,
          this.matrix
        ) : (this.matrixWorld.multiplyMatrices(
          this.parent.matrixWorld,
          this.hiddenMatrix
        ), this.matrixWorld.multiplyMatrices(
          this.matrixWorld,
          this.matrix
        )), t2)
          try {
            for (var o = __values(this.children), a = o.next(); !a.done; a = o.next()) {
              a.value.updateWorldMatrix(false, true);
            }
          } catch (e4) {
            i = { error: e4 };
          } finally {
            try {
              a && !a.done && (r = o.return) && r.call(o);
            } finally {
              if (i) throw i.error;
            }
          }
      }, t.prototype.shallowClone = function(e3) {
        return new this.constructor().shallowCopy(this, e3);
      }, t.prototype.shallowCopy = function(t2, i) {
        var r, n;
        void 0 === i && (i = true);
        var o = t2.children;
        if (t2.children = [], e2.prototype.copy.call(this, t2), t2.children = o, this.raycastLock = t2.raycastLock, this.scaleLock = t2.scaleLock, this.hiddenMatrix.copy(t2.hiddenMatrix), void 0 !== t2.interaction && this.interaction.copy(t2.interaction), true === i)
          try {
            for (var a = __values(o), s = a.next(); !s.done; s = a.next()) {
              var l = s.value;
              isEntity$1(l) && this.add(l.shallowClone());
            }
          } catch (e3) {
            r = { error: e3 };
          } finally {
            try {
              s && !s.done && (n = a.return) && n.call(a);
            } finally {
              if (r) throw r.error;
            }
          }
        return this;
      }, t.prototype.clone = function(e3) {
        return new this.constructor().copy(this, e3);
      }, t.prototype.copy = function(t2, i) {
        var r, n;
        void 0 === i && (i = true);
        var o = t2.children;
        if (t2.children = [], e2.prototype.copy.call(this, t2), t2.children = o, this.raycastLock = t2.raycastLock, this.scaleLock = t2.scaleLock, this.hiddenMatrix.copy(t2.hiddenMatrix), void 0 !== t2.interaction && this.interaction.copy(t2.interaction), true === i)
          try {
            for (var a = __values(o), s = a.next(); !s.done; s = a.next()) {
              var l = s.value;
              isEntity$1(l) && this.add(l.clone());
            }
          } catch (e3) {
            r = { error: e3 };
          } finally {
            try {
              s && !s.done && (n = a.return) && n.call(a);
            } finally {
              if (r) throw r.error;
            }
          }
        return this;
      }, t.prototype.keepChildrenMatrixWorld = function() {
        var e3, t2, i = new THREE.Matrix4(), r = this.matrixWorld.clone();
        this.updateWorldMatrix(false, false), i.getInverse(this.matrixWorld), i.multiply(r);
        try {
          for (var n = __values(this.children), o = n.next(); !o.done; o = n.next()) {
            var a = o.value;
            isEntity$1(a) && a.hiddenMatrix.premultiply(i);
          }
        } catch (t3) {
          e3 = { error: t3 };
        } finally {
          try {
            o && !o.done && (t2 = n.return) && t2.call(n);
          } finally {
            if (e3) throw e3.error;
          }
        }
      }, t.prototype.toJSON = function(t2) {
        var i = e2.prototype.toJSON.call(this, t2), r = i.object;
        return true === this.raycastLock && (r.raycastLock = true), true === this.scaleLock && (r.scaleLock = true), r.hiddenMatrix = this.hiddenMatrix.toArray(), void 0 !== this.interaction && (r.interaction = this.interaction.toJSON(t2)), i;
      }, t.prototype.fromJSON = function(t2) {
        return e2.prototype.fromJSON.call(this, t2), void 0 !== t2.raycastLock && (this.raycastLock = t2.raycastLock), void 0 !== t2.scaleLock && (this.scaleLock = t2.scaleLock), this.hiddenMatrix.fromArray(t2.hiddenMatrix), this;
      }, t.prototype.fromObject3D = function(e3) {
        var t2 = e3.children;
        return e3.children = [], Object.assign(e3, {
          raycastLock: false,
          scaleLock: false,
          hiddenMatrix: new THREE.Matrix4()
        }), this.copy(e3), e3.children = t2, this;
      }, t;
    }(Object3DMixin(e));
  }, Cloner = function(e) {
    function t(t2, i) {
      void 0 === i && (i = {});
      var r = e.call(this) || this;
      r.object = t2, t2.computeComplexBoundingBox(true);
      var n = t2.complexBoundingBox.getSize(new THREE.Vector3()), o = 0.1;
      return r.parameters = {
        type: void 0 !== i.type ? i.type : "radial",
        hideBase: void 0 !== i.hideBase && i.hideBase,
        count: void 0 !== i.count ? i.count : 3,
        ra_radius: void 0 !== i.ra_radius ? i.ra_radius : 2 * Math.max(n.x, n.y),
        ra_startAngle: void 0 !== i.ra_startAngle ? i.ra_startAngle : 0,
        ra_endAngle: void 0 !== i.ra_endAngle ? i.ra_endAngle : 360,
        ra_align: void 0 !== i.ra_align && i.ra_align,
        ra_axis: void 0 !== i.ra_axis ? i.ra_axis : "y",
        ra_scale: void 0 !== i.ra_scale ? i.ra_scale.clone() : new THREE.Vector3(),
        ra_rotation: void 0 !== i.ra_rotation ? i.ra_rotation.clone() : new THREE.Euler(),
        ra_position: void 0 !== i.ra_position ? i.ra_position.clone() : new THREE.Vector3(),
        li_scale: void 0 !== i.li_scale ? i.li_scale.clone() : new THREE.Vector3(),
        li_rotation: void 0 !== i.li_rotation ? i.li_rotation.clone() : new THREE.Euler(),
        li_position: void 0 !== i.li_position ? i.li_position.clone() : new THREE.Vector3(n.x + n.x * o, 0, 0).round(),
        gr_count: void 0 !== i.gr_count ? i.gr_count.clone() : new THREE.Vector3(2, 2, 2),
        gr_size: void 0 !== i.gr_size ? i.gr_size.clone() : new THREE.Vector3(
          n.x + n.x * o,
          n.y + n.y * o,
          n.z + n.z * o
        ).round(),
        gr_fromCenter: void 0 === i.gr_fromCenter || i.gr_fromCenter
      }, r.update(), r.setHideBase(r.parameters.hideBase), r;
    }
    return __extends(t, e), t.prototype.refreshMaterial = function() {
      var e2, t2;
      if ("material" in this.object)
        try {
          for (var i = __values(this.children), r = i.next(); !r.done; r = i.next()) {
            r.value.material = this.object.material;
          }
        } catch (t3) {
          e2 = { error: t3 };
        } finally {
          try {
            r && !r.done && (t2 = i.return) && t2.call(i);
          } finally {
            if (e2) throw e2.error;
          }
        }
    }, t.prototype.setHideBase = function(e2) {
      var t2, i, r, n, o, a, s, l, c, u, h, d;
      if ("material" in this.object) {
        if (Array.isArray(this.object.material)) {
          if (this.children.length > 0) {
            try {
              for (var f = __values(this.object.material), p = f.next(); !p.done; p = f.next()) {
                ;
                (x = p.value).visible = true;
              }
            } catch (e3) {
              t2 = { error: e3 };
            } finally {
              try {
                p && !p.done && (i = f.return) && i.call(f);
              } finally {
                if (t2) throw t2.error;
              }
            }
            if (e2) {
              var v = this.object.material.map(function(e3) {
                return e3.clone();
              });
              try {
                for (var m = __values(this.children), g = m.next(); !g.done; g = m.next()) {
                  g.value.material = v;
                }
              } catch (e3) {
                r = { error: e3 };
              } finally {
                try {
                  g && !g.done && (n = m.return) && n.call(m);
                } finally {
                  if (r) throw r.error;
                }
              }
            } else
              try {
                for (var E = __values(this.children), y = E.next(); !y.done; y = E.next()) {
                  y.value.material = this.object.material;
                }
              } catch (e3) {
                o = { error: e3 };
              } finally {
                try {
                  y && !y.done && (a = E.return) && a.call(E);
                } finally {
                  if (o) throw o.error;
                }
              }
          }
          try {
            for (var A = __values(this.object.material), T = A.next(); !T.done; T = A.next()) {
              ;
              (x = T.value).visible = !e2;
            }
          } catch (e3) {
            s = { error: e3 };
          } finally {
            try {
              T && !T.done && (l = A.return) && l.call(A);
            } finally {
              if (s) throw s.error;
            }
          }
        } else {
          if (this.children.length > 0)
            if (this.object.material.visible = true, e2) {
              var x = this.object.material.clone();
              try {
                for (var _ = __values(this.children), w = _.next(); !w.done; w = _.next()) {
                  w.value.material = x;
                }
              } catch (e3) {
                c = { error: e3 };
              } finally {
                try {
                  w && !w.done && (u = _.return) && u.call(_);
                } finally {
                  if (c) throw c.error;
                }
              }
            } else
              try {
                for (var S = __values(this.children), b = S.next(); !b.done; b = S.next()) {
                  b.value.material = this.object.material;
                }
              } catch (e3) {
                h = { error: e3 };
              } finally {
                try {
                  b && !b.done && (d = S.return) && d.call(S);
                } finally {
                  if (h) throw h.error;
                }
              }
          this.object.material.visible = !e2;
        }
        this.parameters.hideBase = e2;
      }
    }, t.prototype.update = function() {
      switch (this._updateCount(), this.parameters.type) {
        case "radial":
          this._updateRadial(this.parameters);
          break;
        case "linear":
          this._updateLinear(this.parameters);
          break;
        case "grid":
          this._updateGrid(this.parameters);
      }
    }, t.prototype._updateCount = function() {
      var e2 = "grid" === this.parameters.type ? this.parameters.gr_count.x * this.parameters.gr_count.y * this.parameters.gr_count.z : this.parameters.count;
      if (this.children.length !== e2)
        if (this.children.length < e2)
          for (var t2 = 0, i = e2 - this.children.length; t2 < i; ++t2) {
            var r = this.object.shallowClone(false);
            r.visible = true, this.add(r), this.parameters.hideBase && this.setHideBase(true);
          }
        else
          for (t2 = 0, i = this.children.length - e2; t2 < i; ++t2)
            this.remove(this.children[0]);
    }, t.prototype._updateRadial = function(e2) {
      var t2, i, r, n = e2.ra_startAngle * THREE.MathUtils.DEG2RAD, o = n - e2.ra_endAngle * THREE.MathUtils.DEG2RAD, a = new THREE.Euler(
        e2.ra_rotation.x * THREE.MathUtils.DEG2RAD,
        e2.ra_rotation.y * THREE.MathUtils.DEG2RAD,
        e2.ra_rotation.z * THREE.MathUtils.DEG2RAD
      );
      switch (e2.ra_axis) {
        case "x":
          r = new THREE.Vector3(1, 0, 0);
          break;
        case "y":
          r = new THREE.Vector3(0, 1, 0);
          break;
        case "z":
          r = new THREE.Vector3(0, 0, 1);
      }
      try {
        for (var s = __values(this.children.entries()), l = s.next(); !l.done; l = s.next()) {
          var c = __read(l.value, 2), u = c[0], h = c[1];
          h.hiddenMatrix.identity(), h.scale.x = e2.ra_scale.x + 1, h.scale.y = e2.ra_scale.y + 1, h.scale.z = e2.ra_scale.z + 1, h.position.setScalar(0);
          var d = o / e2.count * u - n;
          switch (e2.ra_axis) {
            case "x":
              h.rotation.set(0, d, 0);
              break;
            case "y":
              h.rotation.set(0, 0, d);
              break;
            case "z":
              h.rotation.set(d, 0, 0);
          }
          h.translateOnAxis(r, e2.ra_radius), h.position.add(e2.ra_position), true === e2.ra_align ? (h.rotation.x += a.x, h.rotation.y += a.y, h.rotation.z += a.z) : h.rotation.copy(a);
        }
      } catch (e3) {
        t2 = { error: e3 };
      } finally {
        try {
          l && !l.done && (i = s.return) && i.call(s);
        } finally {
          if (t2) throw t2.error;
        }
      }
    }, t.prototype._updateLinear = function(e2) {
      var t2, i;
      if ("linear" !== e2.type) throw new Error();
      var r = new THREE.Euler(
        e2.li_rotation.x * THREE.MathUtils.DEG2RAD,
        e2.li_rotation.y * THREE.MathUtils.DEG2RAD,
        e2.li_rotation.z * THREE.MathUtils.DEG2RAD
      );
      try {
        for (var n = __values(this.children.entries()), o = n.next(); !o.done; o = n.next()) {
          var a = __read(o.value, 2), s = a[0], l = a[1];
          l.hiddenMatrix.identity(), l.scale.x = e2.li_scale.x * s + 1, l.scale.y = e2.li_scale.y * s + 1, l.scale.z = e2.li_scale.z * s + 1, l.rotation.x = r.x * s, l.rotation.y = r.y * s, l.rotation.z = r.z * s, l.position.x = e2.li_position.x * s, l.position.y = e2.li_position.y * s, l.position.z = e2.li_position.z * s;
        }
      } catch (e3) {
        t2 = { error: e3 };
      } finally {
        try {
          o && !o.done && (i = n.return) && i.call(n);
        } finally {
          if (t2) throw t2.error;
        }
      }
    }, t.prototype._updateGrid = function(e2) {
      var t2 = 0;
      if (true === e2.gr_fromCenter)
        for (var i = {
          x: e2.gr_count.x % 2 == 0 ? 2 : 1,
          y: e2.gr_count.y % 2 == 0 ? 2 : 1,
          z: e2.gr_count.z % 2 == 0 ? 2 : 1
        }, r = new THREE.Vector3(
          e2.gr_size.x * (e2.gr_count.x - i.x) * 0.5,
          e2.gr_size.y * (e2.gr_count.y - i.y) * 0.5,
          e2.gr_size.z * (e2.gr_count.z - i.z) * 0.5
        ), n = 0; n < e2.gr_count.x; n++)
          for (var o = 0; o < e2.gr_count.y; o++)
            for (var a = 0; a < e2.gr_count.z; a++) {
              (s = this.children[t2++]).hiddenMatrix.identity(), s.scale.setScalar(1), s.rotation.set(0, 0, 0), s.position.x = e2.gr_size.x * n - r.x, s.position.y = e2.gr_size.y * o - r.y, s.position.z = e2.gr_size.z * a - r.z;
            }
      else
        for (n = 0; n < e2.gr_count.x; n++)
          for (o = 0; o < e2.gr_count.y; o++)
            for (a = 0; a < e2.gr_count.z; a++) {
              var s;
              (s = this.children[t2++]).hiddenMatrix.identity(), s.scale.setScalar(1), s.rotation.set(0, 0, 0), s.position.x = e2.gr_size.x * n, s.position.y = -e2.gr_size.y * o, s.position.z = -e2.gr_size.z * a;
            }
    }, t.prototype.toJSON = function() {
      return {
        type: "Cloner",
        parameters: {
          type: this.parameters.type,
          hideBase: this.parameters.hideBase,
          count: this.parameters.count,
          ra_radius: this.parameters.ra_radius,
          ra_startAngle: this.parameters.ra_startAngle,
          ra_endAngle: this.parameters.ra_endAngle,
          ra_align: this.parameters.ra_align,
          ra_axis: this.parameters.ra_axis,
          ra_scale: this.parameters.ra_scale.toArray(),
          ra_rotation: this.parameters.ra_rotation.toArray(),
          ra_position: this.parameters.ra_position.toArray(),
          li_scale: this.parameters.li_scale.toArray(),
          li_rotation: this.parameters.li_rotation.toArray(),
          li_position: this.parameters.li_position.toArray(),
          gr_count: this.parameters.gr_count.toArray(),
          gr_size: this.parameters.gr_size.toArray(),
          gr_fromCenter: this.parameters.gr_fromCenter
        }
      };
    }, t.prototype.fromJSON = function(e2) {
      var t2 = e2.parameters;
      return this.parameters.type = t2.type, this.parameters.hideBase = t2.hideBase, this.parameters.count = t2.count, this.parameters.ra_radius = t2.ra_radius, this.parameters.ra_startAngle = t2.ra_startAngle, this.parameters.ra_endAngle = t2.ra_endAngle, this.parameters.ra_align = t2.ra_align, this.parameters.ra_axis = t2.ra_axis, this.parameters.ra_scale.fromArray(t2.ra_scale), this.parameters.ra_rotation.fromArray(t2.ra_rotation), this.parameters.ra_position.fromArray(t2.ra_position), this.parameters.li_scale.fromArray(t2.li_scale), this.parameters.li_rotation.fromArray(t2.li_rotation), this.parameters.li_position.fromArray(t2.li_position), this.parameters.gr_count.fromArray(t2.gr_count), this.parameters.gr_size.fromArray(t2.gr_size), this.parameters.gr_fromCenter = t2.gr_fromCenter, this.update(), this.setHideBase(this.parameters.hideBase), this;
    }, t;
  }(THREE.Object3D), AbstractMesh = function(e) {
    function t(t2, i) {
      var r = e.call(this, t2, i) || this;
      return r.isAbstractMesh = true, Array.isArray(i) && (r.selectedMaterial = 0), r;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "cloner", {
      get: function() {
        return this._cloner;
      },
      set: function(e2) {
        this._cloner && this.remove(this._cloner), e2 && this.add(e2), this._cloner = e2;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.updateGeometry = function(e2) {
      var t2 = this.geometry, i = geometries[t2.userData.type], r = "NonParametric" === this.objectType ? Object.assign({}, t2.userData, { geometry: t2 }) : t2.userData, n = i.build(i.normalizeInputs(e2, r));
      this.geometry.dispose(), this.geometry = n, this.geometry.computeBoundingSphere();
    }, t.prototype.resizeGeometry = function(e2, t2, i) {
      resizeGeometry(this.geometry, { width: e2, height: t2, depth: i });
    }, t.prototype.shallowClone = function(e2) {
      return new this.constructor(this.geometry, this.material).shallowCopy(
        this,
        e2
      );
    }, t.prototype.clone = function(e2) {
      var t2 = "NonParametric" === this.objectType ? Object.assign({}, this.geometry.userData, {
        geometry: this.geometry
      }) : this.geometry.userData, i = createGeometry(t2), r = Array.isArray(this.material) ? this.material.map(function(e3) {
        return e3.clone();
      }) : this.material.clone();
      return new this.constructor(i, r).copy(this, e2);
    }, t.prototype.copy = function(t2, i) {
      return void 0 === i && (i = true), e.prototype.copy.call(this, t2, i), t2.cloner && (this.cloner = new Cloner(t2, t2.cloner.parameters), this.add(this.cloner)), this;
    }, t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2), r = i.object;
      if (void 0 !== this.cloner && (r.cloner = this.cloner.toJSON()), r.geometry = serializeGeometry(t2.geometries, this.geometry), Array.isArray(this.material)) {
        for (var n = [], o = 0, a = this.material.length; o < a; o++)
          n.push(serialize(t2.materials, this.material[o], t2));
        r.material = n;
      } else r.material = serialize(t2.materials, this.material, t2);
      return i;
    }, t.prototype.fromJSON = function(t2) {
      return e.prototype.fromJSON.call(this, t2), void 0 !== t2.selectedMaterial && (this.selectedMaterial = t2.selectedMaterial), void 0 !== t2.cloner && (this.cloner = new Cloner(this).fromJSON(t2.cloner)), this;
    }, t;
  }(EntityMixin(THREE.Mesh)), HelperMixin = function(e) {
    var t;
    return (t = function(e2) {
      function t2() {
        var t3 = null !== e2 && e2.apply(this, arguments) || this;
        return t3.isObjectHelper = true, t3;
      }
      return __extends(t2, e2), t2;
    }(e)).geometryHelper = new THREE.BoxBufferGeometry(30, 30, 30), t;
  }, _ray$1 = new THREE.Ray(), _sphere$1 = new THREE.Sphere(), _inverseMatrix$1 = new THREE.Matrix4(), helperRaycast = function(e, t, i, r) {
    var n = t, o = e.matrixWorld;
    if (null === n.boundingSphere && n.computeBoundingSphere(), _sphere$1.copy(n.boundingSphere), _sphere$1.applyMatrix4(o), false !== i.ray.intersectsSphere(_sphere$1) && (_inverseMatrix$1.getInverse(o), _ray$1.copy(i.ray).applyMatrix4(_inverseMatrix$1), null === n.boundingBox || false !== _ray$1.intersectsBox(n.boundingBox))) {
      var a, s, l, c, u, h, d = n.index, f = n.attributes.position, p = n.drawRange;
      for (u = Math.max(0, p.start), h = Math.min(d.count, p.start + p.count); u < h; u += 3)
        if (s = d.getX(u), l = d.getX(u + 1), c = d.getX(u + 2), a = v(e, i, _ray$1, f, s, l, c))
          return a.faceIndex = Math.floor(u / 3), void r.push(a);
    }
    function v(e2, t2, i2, r2, n2, o2, a2) {
      var s2 = new THREE.Vector3(), l2 = new THREE.Vector3(), c2 = new THREE.Vector3(), u2 = new THREE.Vector3(), h2 = new THREE.Vector3();
      if (s2.fromBufferAttribute(r2, n2), l2.fromBufferAttribute(r2, o2), c2.fromBufferAttribute(r2, a2), null === i2.intersectTriangle(s2, l2, c2, false, u2))
        return null;
      h2.copy(u2), h2.applyMatrix4(e2.matrixWorld);
      var d2 = t2.ray.origin.distanceTo(h2);
      return d2 < t2.near || d2 > t2.far ? null : { faceIndex: 1, distance: d2, point: h2.clone(), object: e2 };
    }
  }, CombinedCameraHelper = function(e) {
    function t(t2) {
      var i = e.call(this, t2) || this;
      i.object = t2;
      var r = new THREE.SphereGeometry(15, 4, 2), n = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false,
        toneMapped: false
      }), o = new THREE.Mesh(r, n);
      return i.add(o), i.object = t2, i.name = "CombinedCameraHelper: " + t2.uuid, i;
    }
    return __extends(t, e), t.prototype.raycast = function(e2, i) {
      helperRaycast(this.object, t.geometryHelper, e2, i);
    }, t;
  }(HelperMixin(THREE.CameraHelper)), DirectionalLightHelper = function(e) {
    function t(t2, i, r) {
      void 0 === i && (i = 15), void 0 === r && (r = 10066329);
      var n = e.call(this, t2, i, r) || this;
      return n.object = t2, n.name = "DirectionalLightHelper: " + t2.uuid, n;
    }
    return __extends(t, e), t.prototype.raycast = function(e2, i) {
      helperRaycast(this.object, t.geometryHelper, e2, i);
    }, t;
  }(HelperMixin(THREE.DirectionalLightHelper)), EmptyObjectHelper = function(e) {
    function t(t2, i) {
      void 0 === i && (i = 15);
      var r = e.call(this, i) || this;
      return r.object = t2, r.object.updateMatrixWorld(), r.name = "EmptyObjectHelper: " + t2.uuid, r.matrix = t2.matrixWorld, r.matrixAutoUpdate = false, r;
    }
    return __extends(t, e), t.prototype.raycast = function(e2, i) {
      helperRaycast(this.object, t.geometryHelper, e2, i);
    }, t.prototype.update = function() {
    }, t;
  }(HelperMixin(THREE.AxesHelper)), PointLightHelper = function(e) {
    function t(t2, i, r) {
      void 0 === i && (i = 15), void 0 === r && (r = 6710886);
      var n = e.call(this, t2, i, r) || this;
      return n.object = t2, n.name = "PointLightHelper: " + t2.uuid, n;
    }
    return __extends(t, e), t.prototype.raycast = function(e2, i) {
      helperRaycast(this.object, t.geometryHelper, e2, i);
    }, t;
  }(HelperMixin(THREE.PointLightHelper)), SpotLightHelper = function(e) {
    function t(t2, i) {
      void 0 === i && (i = 6710886);
      var r = e.call(this, t2, i) || this;
      return r.object = t2, r.name = "SpotLightHelper: " + t2.uuid, r;
    }
    return __extends(t, e), t.prototype.raycast = function(e2, i) {
      helperRaycast(this.object, t.geometryHelper, e2, i);
    }, t.prototype.update = function() {
      if (void 0 !== this.object) {
        var e2 = t._vector, i = this.object.distance ? this.object.distance : 1e3, r = i * Math.tan(this.object.angle);
        this.cone.scale.set(r, r, i), e2.setFromMatrixPosition(this.object.target.matrixWorld), this.cone.lookAt(e2);
        var n = void 0 !== this.color ? this.color : this.light.color;
        if (this.cone.material instanceof Array)
          for (var o = 0, a = this.cone.material.length; o < a; o++)
            this.cone.material[o].color.set(n);
        else this.cone.material.color.set(n);
      }
    }, t._vector = new THREE.Vector3(), t;
  }(HelperMixin(THREE.SpotLightHelper)), _sphere$2 = new THREE.Sphere(), _inverseMatrix$2 = new THREE.Matrix4(), _ray$2 = new THREE.Ray(), _position = new THREE.Vector3(), thresholdBase = 10, VectorHelperPoints = function(e) {
    function t(t2, i, r) {
      var n = e.call(this) || this;
      return n.defaultTexture = t2, n.selectedTexture = i, n.count = r, n.drawCount = 0, n._mouseThreshold = 4, n._cameraZoom = 1, n.positionAttribute = new THREE.BufferAttribute(
        new Float32Array(3 * r),
        3
      ), n.selectionAttribute = new THREE.BufferAttribute(
        new Uint16Array(r),
        1
      ), n.geometry = new THREE.BufferGeometry(), n.geometry.setAttribute("position", n.positionAttribute), n.geometry.setAttribute("aSelection", n.selectionAttribute), n.material = new THREE.PointsMaterial({
        map: t2,
        size: 16,
        sizeAttenuation: false,
        transparent: true,
        depthTest: false
      }), n.material.onBeforeCompile = function(e2) {
        e2.uniforms.uSelectedTexture = { value: i }, e2.vertexShader = "attribute float aSelection;\nvarying float vSelection;\n" + e2.vertexShader, e2.vertexShader = e2.vertexShader.replace(
          "#include <begin_vertex>",
          "#include <begin_vertex>\n\n	vSelection = aSelection;\n"
        ), e2.fragmentShader = "uniform sampler2D uSelectedTexture;\nvarying float vSelection;\n" + e2.fragmentShader, e2.fragmentShader = e2.fragmentShader.replace(
          "#include <map_particle_fragment>",
          "\n				vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n				vec4 defaultMapTexel = texture2D( map, uv );\n				vec4 selectedMapTexel = texture2D( uSelectedTexture, uv );\n				diffuseColor *= mapTexelToLinear( mix(defaultMapTexel, selectedMapTexel, vSelection) );\n				"
        );
      }, n.mesh = new THREE.Points(n.geometry, n.material), n.add(n.mesh), n;
    }
    return __extends(t, e), t.prototype.setXYZ = function(e2, t2, i, r) {
      void 0 === r && (r = 0), this.positionAttribute.setXYZ(e2, t2, i, r);
    }, t.prototype.setPositionAt = function(e2, t2) {
      this.positionAttribute.setXYZ(e2, t2.x, t2.y, "z" in t2 ? t2.z : 0);
    }, Object.defineProperty(t.prototype, "cameraZoom", {
      get: function() {
        return this._cameraZoom;
      },
      set: function(e2) {
        this._cameraZoom = e2, this._mouseThreshold = thresholdBase / e2;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.update = function() {
      this.positionAttribute.needsUpdate = true, this.geometry.computeBoundingSphere();
    }, t.prototype.raycast = function(e2, t2) {
      var i = this.geometry, r = this.matrixWorld, n = this, o = n._mouseThreshold, a = n.scale, s = n.drawCount;
      if (null === i.boundingSphere && i.computeBoundingSphere(), _sphere$2.copy(i.boundingSphere), _sphere$2.applyMatrix4(r), _sphere$2.radius += o, false === e2.ray.intersectsSphere(_sphere$2))
        return t2;
      _inverseMatrix$2.getInverse(r), _ray$2.copy(e2.ray);
      for (var l = o / ((a.x + a.y + a.z) / 3), c = l * l, u = this.positionAttribute, h = 0, d = s; h < d; h++)
        _position.fromBufferAttribute(u, h).applyMatrix4(r), this._testPoint(_position, h, c, r, e2, t2);
      return t2;
    }, t.prototype._testPoint = function(e2, t2, i, r, n, o) {
      var a = _ray$2.distanceSqToPoint(e2);
      if (a < i) {
        var s = new THREE.Vector3();
        _ray$2.closestPointToPoint(e2, s), s.applyMatrix4(r);
        var l = n.ray.origin.distanceTo(s);
        if (l < n.near || l > n.far) return;
        o.push({
          distance: l,
          distanceToRay: Math.sqrt(a),
          point: s,
          index: t2,
          face: null,
          object: this
        });
      }
    }, t.prototype.setSelection = function(e2, t2, i) {
      void 0 === i && (i = false), this.selectionAttribute.setX(e2, t2 ? 1 : 0), i && (this.selectionAttribute.needsUpdate = true);
    }, t.prototype.getSelection = function(e2) {
      return 1 === this.selectionAttribute.getX(e2);
    }, t.prototype.clearSelection = function(e2) {
      void 0 === e2 && (e2 = false);
      for (var t2 = 0; t2 < this.count; t2++)
        this.selectionAttribute.setX(t2, 0);
      e2 && (this.selectionAttribute.needsUpdate = true);
    }, t.prototype.updateSelection = function() {
      this.selectionAttribute.needsUpdate = true;
    }, t.prototype.setDrawRange = function(e2, t2) {
      t2 = Math.min(t2, this.count), this.geometry.setDrawRange(e2, t2), this.drawCount = t2;
    }, t;
  }(THREE.Object3D), vertexHeader = "\nattribute float aSelection;\nattribute float aVisibility;\nvarying float vSelection;\nvarying float vVisibility;\n", vertexVaryingsSet = "\n	vSelection = aSelection;\n	vVisibility = aVisibility;\n", fragmentHeader = "\nuniform sampler2D uSelectedTexture;\n\nvarying float vSelection;\nvarying float vVisibility;\n", fragmentMap = "\n	if (vVisibility < 0.5) discard;\n	\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n	vec4 defaultMapTexel = texture2D( map, uv );\n	vec4 selectedMapTexel = texture2D( uSelectedTexture, uv );\n	diffuseColor *= mapTexelToLinear( mix(defaultMapTexel, selectedMapTexel, vSelection) );\n", VectorHelperControls = function(e) {
    function t(t2, i, r) {
      var n = e.call(this, t2, i, r) || this;
      return n._visibilityAttribute = new THREE.BufferAttribute(
        new Uint16Array(r),
        1
      ), n.geometry.setAttribute("aVisibility", n._visibilityAttribute), n.material.onBeforeCompile = function(e2) {
        e2.uniforms.uSelectedTexture = { value: i }, e2.vertexShader = vertexHeader + e2.vertexShader, e2.vertexShader = e2.vertexShader.replace(
          "#include <begin_vertex>",
          "#include <begin_vertex>" + vertexVaryingsSet
        ), e2.fragmentShader = fragmentHeader + e2.fragmentShader, e2.fragmentShader = e2.fragmentShader.replace(
          "#include <map_particle_fragment>",
          fragmentMap
        );
      }, n;
    }
    return __extends(t, e), t.prototype.setVisibility = function(e2, t2) {
      this._visibilityAttribute.setX(e2, t2 ? 1 : 0);
    }, t.prototype.update = function() {
      e.prototype.update.call(this), this._visibilityAttribute.needsUpdate = true;
    }, t;
  }(VectorHelperPoints), VectorHelperDefaultLine = function(e) {
    function t(t2) {
      var i = e.call(this) || this;
      return i.geometry = new VectorLineGeometry(t2), i.material = new THREE.LineBasicMaterial({
        color: 11184810,
        depthTest: false,
        linewidth: 2
      }), i.mesh = new THREE.Line(i.geometry, i.material), i.add(i.mesh), i;
    }
    return __extends(t, e), t.prototype.update = function(e2, t2) {
      var i = e2.extractShapePointsToBuffer(this.geometry.positions, t2);
      this.geometry.drawCount = i, this.geometry.positions.needsUpdate = true, this.geometry.computeBoundingSphere();
    }, t;
  }(THREE.Object3D), VectorHelperSelectedLine = function(e) {
    function t(t2) {
      var i = e.call(this) || this;
      return i.selection = [], i.geometry = new VectorLineGeometry(t2), i.material = new THREE.LineBasicMaterial({
        color: 16777215,
        depthTest: false,
        linewidth: 2
      }), i.mesh = new THREE.LineSegments(i.geometry, i.material), i.add(i.mesh), i;
    }
    return __extends(t, e), t.prototype.setSelection = function(e2) {
      this.selection = e2;
    }, t.prototype.update = function(e2, t2) {
      for (var i = [], r = 0, n = e2.points.length; r < n; r++)
        i.push(this.selection.indexOf(r) >= 0);
      var o = e2.extractFilteredShapePointsToBuffer(
        this.geometry.positions,
        i,
        t2
      );
      this.geometry.drawCount = o, this.geometry.positions.needsUpdate = true, this.geometry.computeBoundingSphere();
    }, t;
  }(THREE.Object3D), VectorHelperSegments = function(e) {
    function t(t2, i) {
      void 0 === i && (i = {});
      var r = e.call(this) || this;
      return r.drawCount = 0, r._positions = new THREE.Float32BufferAttribute(
        new Float32Array(3 * t2),
        3
      ), r.geometry = new THREE.BufferGeometry(), r.geometry.setAttribute("position", r._positions), r.material = new THREE.LineBasicMaterial(i), r.segments = new THREE.LineSegments(r.geometry, r.material), r.add(r.segments), r.segments.frustumCulled = false, r;
    }
    return __extends(t, e), t.prototype.setPositionAt = function(e2, t2) {
      this._positions.setXYZ(e2, t2.x, t2.y, "z" in t2 ? t2.z : 0);
    }, t.prototype.setXYZ = function(e2, t2, i, r) {
      void 0 === r && (r = 0), this._positions.setXYZ(e2, t2, i, r);
    }, t.prototype.getX = function(e2) {
      return this._positions.getX(e2);
    }, t.prototype.getY = function(e2) {
      return this._positions.getY(e2);
    }, t.prototype.getZ = function(e2) {
      return this._positions.getZ(e2);
    }, t.prototype.update = function() {
      this._positions.needsUpdate = true;
    }, t.prototype.setDrawRange = function(e2, t2) {
      this.geometry.setDrawRange(e2, t2), this.drawCount = t2;
    }, t;
  }(THREE.Object3D), MAX_POINTS = 500, MAX_SUBDIVISIONS = 40, textureLoader = new THREE.TextureLoader(), vectorPointDefaultTexture, vectorControlDefaultTexture, vectorPointSelectedTexture, vectorControlSelectedTexture, tempV2a = new THREE.Vector2(), tempV2b = new THREE.Vector2(), tempV2c = new THREE.Vector2(), quarterPI = 0.25 * Math.PI, halfPI = 0.5 * Math.PI, snapBase = 4;
  (function(e) {
    function t() {
      var t2 = e.call(this) || this;
      return t2.count = 0, t2.raycaster = new THREE.Raycaster(), t2.nextPointDest = new THREE.Vector3(), t2.useAngleSnapping = false, t2.showAllControls = false, t2._subdivisions = 20, t2._snapThreshold = snapBase, t2._snapEnabled = false, t2._cameraZoom = 1, t2._onShapeUpdate = function() {
        t2.update();
      }, t2._onGeometryUpdate = function() {
        if (void 0 !== t2.object) {
          var e2 = t2.object.geometry.userData.parameters;
          t2.subdivisions = e2.subdivisions;
        }
      }, t2.matrixAutoUpdate = false, t2.visible = false, t2.loadTextures(), t2.vectorLineMesh = new VectorHelperDefaultLine(
        MAX_POINTS * MAX_SUBDIVISIONS
      ), t2.add(t2.vectorLineMesh), t2.vectorSelectedLineMesh = new VectorHelperSelectedLine(
        MAX_POINTS * MAX_SUBDIVISIONS
      ), t2.add(t2.vectorSelectedLineMesh), t2.controlLines = new VectorHelperSegments(4 * MAX_POINTS, {
        transparent: true,
        opacity: 0.3,
        depthTest: false
      }), t2.add(t2.controlLines), t2.nextLine = new VectorHelperSegments(6, {
        linewidth: 2,
        depthTest: false
      }), t2.add(t2.nextLine), t2.snapLines = new VectorHelperSegments(12, {
        linewidth: 2,
        depthTest: false,
        color: 16711680
      }), t2.add(t2.snapLines), t2.points = new VectorHelperPoints(
        vectorPointDefaultTexture,
        vectorPointSelectedTexture,
        MAX_POINTS
      ), t2.add(t2.points), t2.controls = new VectorHelperControls(
        vectorControlDefaultTexture,
        vectorControlSelectedTexture,
        MAX_POINTS
      ), t2.add(t2.controls), t2.nextPoint = new VectorHelperPoints(
        vectorPointDefaultTexture,
        null,
        1
      ), t2.add(t2.nextPoint), t2.splitPoint = new VectorHelperPoints(
        vectorPointDefaultTexture,
        null,
        1
      ), t2.add(t2.splitPoint), t2.hideNextLine(), t2;
    }
    return __extends(t, e), t.prototype.loadTextures = function() {
      vectorPointDefaultTexture = textureLoader.load(
        "/_assets/_vectors/point_default_out.png"
      ), vectorControlDefaultTexture = textureLoader.load(
        "/_assets/_vectors/control_default.png"
      ), vectorPointSelectedTexture = textureLoader.load(
        "/_assets/_vectors/point_selected_out.png"
      ), vectorControlSelectedTexture = textureLoader.load(
        "/_assets/_vectors/control_selected.png"
      );
    }, t.prototype.setLineSelection = function(e2) {
      this.vectorSelectedLineMesh.setSelection(e2), this.update();
    }, t.prototype.show = function(e2) {
      var t2;
      void 0 !== this.object && this.clear(), this.object = e2, null === (t2 = this.object.shape.eventDispatcher) || void 0 === t2 || t2.addEventListener("update", this._onShapeUpdate), this.object.eventDispatcher.addEventListener(
        "geometryUpdate",
        this._onGeometryUpdate
      ), this._onGeometryUpdate(), this.updateHelperMatrix(), this.update(), this.visible = true;
    }, t.prototype.hide = function() {
      this.visible = false;
    }, t.prototype.setEnableSnapping = function(e2) {
      this._snapEnabled = e2;
    }, Object.defineProperty(t.prototype, "cameraZoom", {
      get: function() {
        return this._cameraZoom;
      },
      set: function(e2) {
        this._cameraZoom = e2, this._snapThreshold = snapBase / e2, this.points.cameraZoom = e2, this.controls.cameraZoom = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "snapThreshold", {
      get: function() {
        return this._snapThreshold;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "subdivisions", {
      get: function() {
        return this._subdivisions;
      },
      set: function(e2) {
        this._subdivisions = e2, this.update();
      },
      enumerable: false,
      configurable: true
    }), t.prototype.showNextLine = function() {
      this.nextLine.visible = !!this.object && this.object.shape.points.length > 0, this.nextPoint.visible = true;
    }, t.prototype.hideNextLine = function() {
      this.nextLine.visible = false, this.nextPoint.visible = false;
    }, t.prototype.showSplitPoint = function() {
      this.splitPoint.visible = true;
    }, t.prototype.hideSplitPoint = function() {
      this.splitPoint.visible = false;
    }, t.prototype.clear = function() {
      var e2, t2, i;
      null === (t2 = null === (e2 = this.object) || void 0 === e2 ? void 0 : e2.shape.eventDispatcher) || void 0 === t2 || t2.removeEventListener("update", this._onShapeUpdate), null === (i = this.object) || void 0 === i || i.eventDispatcher.removeEventListener(
        "geometryUpdate",
        this._onGeometryUpdate
      ), this.object = void 0;
    }, t.prototype.getPointByInstanceId = function(e2, t2) {
      var i;
      void 0 === t2 && (t2 = false);
      var r = Math.floor(e2 / 3), n = e2 % 3, o = null === (i = this.object) || void 0 === i ? void 0 : i.shape.points[r];
      if (o) {
        var a = o.controlsMoved();
        return t2 || a ? n > 0 ? o.controls[n - 1] : t2 && !a ? o.controls[0] : o : o;
      }
      return null;
    }, t.prototype.setSnapLines = function(e2, t2, i, r) {
      void 0 === e2 && (e2 = null), void 0 === t2 && (t2 = null), void 0 === i && (i = null), void 0 === r && (r = null), null === e2 && null === t2 && null !== i && null !== r && (e2 = i, t2 = r, i = null, r = null);
      var n = 0;
      null !== e2 && null !== t2 && (this.snapLines.setPositionAt(0, e2), this.snapLines.setPositionAt(1, t2), n += 2), null !== i && null !== r && (this.snapLines.setPositionAt(2, i), this.snapLines.setPositionAt(3, r), n += 2), this.snapLines.setDrawRange(0, n), this.snapLines.update();
    }, t.prototype.hideSnapLines = function() {
      this.setSnapLines();
    }, t.prototype.updateHelperMatrix = function() {
      var e2, t2;
      if (void 0 !== this.object) {
        var i = this.object, r = i.parent;
        null !== r && r.updateWorldMatrix(true, false), i.matrixAutoUpdate && i.updateMatrix(), null !== r ? (this.matrixWorld.multiplyMatrices(
          r.matrixWorld,
          i.hiddenMatrix
        ), this.matrixWorld.multiplyMatrices(this.matrixWorld, i.matrix)) : this.matrixWorld.multiplyMatrices(i.hiddenMatrix, i.matrix), this.matrix.copy(this.matrixWorld);
        try {
          for (var n = __values(this.children), o = n.next(); !o.done; o = n.next()) {
            o.value.matrixWorld.copy(this.matrixWorld);
          }
        } catch (t3) {
          e2 = { error: t3 };
        } finally {
          try {
            o && !o.done && (t2 = n.return) && t2.call(n);
          } finally {
            if (e2) throw e2.error;
          }
        }
        i.updateWorldMatrix(true, true);
      }
    }, t.prototype.snap = function(e2, t2, i, r) {
      var n;
      if (t2.x = e2.x, t2.y = e2.y, !this._snapEnabled) return t2;
      var o = tempV2a.set(e2.x, e2.y), a = null === (n = this.object) || void 0 === n ? void 0 : n.shape;
      if (void 0 === a) return t2;
      for (var s, l, c = false, u = false, h = o.x, d = o.y, f = 0, p = a.points.length; f < p; f++) {
        var v = a.points[f];
        if (void 0 === i || v !== i) {
          var m = v.position;
          Math.abs(m.x - o.x) < this._snapThreshold && (h = m.x, s = v.position, c = true), Math.abs(m.y - o.y) < this._snapThreshold && (d = m.y, l = v.position, u = true);
        }
      }
      if (this.useAngleSnapping && void 0 !== r) {
        var g = tempV2b.set(r.x, r.y);
        o.set(h, d);
        var E = g.distanceTo(o), y = tempV2c.subVectors(g, o).angle() + Math.PI, A = Math.round(y / quarterPI) * quarterPI % (2 * Math.PI);
        if (true === c && A !== halfPI && A !== 1.5 * Math.PI) {
          var T = h - g.x;
          d = g.y + Math.tan(A) * T, l = g;
        } else if (true === u && 0 !== A && A !== Math.PI) {
          var x = d - g.y;
          h = g.x - x / Math.tan(Math.PI - A), s = g;
        } else
          h = g.x + Math.cos(A) * E, d = g.y + Math.sin(A) * E, s = g, l = void 0;
        c = true, u = true;
      }
      return c && (t2.x = h), u && (t2.y = d), this.setSnapLines(
        c ? t2 : null,
        c ? s : null,
        u ? t2 : null,
        u ? l : null
      ), t2;
    }, t.prototype.setNextPointDest = function(e2) {
      if (void 0 !== this.object) {
        var t2;
        void 0 !== e2 && (t2 = this.snap(
          e2,
          tempV2a,
          void 0,
          this.object.shape.getLastPoint().position
        ));
        var i = null == t2 ? void 0 : t2.x, r = null == t2 ? void 0 : t2.y, n = this.nextLine.getX(0), o = this.nextLine.getY(0);
        this.nextLine.setXYZ(1, null != i ? i : n, null != r ? r : o), this.nextLine.update(), this.nextPoint.setXYZ(0, null != i ? i : n, null != r ? r : o, 0), this.nextPoint.update(), this.nextPointDest.set(null != i ? i : n, null != r ? r : o, 0);
      }
    }, t.prototype.setSplitPointDest = function(e2, t2, i) {
      void 0 === i && (i = 0), this.splitPoint.position.set(e2, t2, i);
    }, t.prototype.update = function() {
      if (void 0 !== this.object && void 0 !== this.object.shape) {
        for (var e2 = 0, t2 = 0, i = 0, r = this.object.shape.points.length, n = 0; n < r; n++) {
          var o = 0 === n ? r - 1 : n - 1, a = n === r - 1 ? 0 : n + 1, s = this.object.shape.points[n], l = s.controls[0], c = s.controls[1], u = s.position.distanceTo(l.position), h = s.position.distanceTo(c.position), d = this.showAllControls || this.points.getSelection(n) || this.points.getSelection(o) || this.points.getSelection(a);
          this.points.setPositionAt(e2, s.position), e2++, this.controls.setPositionAt(t2, l.position), this.controls.setVisibility(t2, d && u > this._snapThreshold), t2++, this.controls.setPositionAt(t2, c.position), this.controls.setVisibility(t2, d && h > this._snapThreshold), t2++, d && (this.controlLines.setPositionAt(i + 0, s.position), this.controlLines.setPositionAt(i + 1, l.position), this.controlLines.setPositionAt(i + 2, s.position), this.controlLines.setPositionAt(i + 3, c.position), i += 4);
        }
        var f = this.object.shape.points[r - 1];
        f && (this.nextLine.setPositionAt(0, f.position), this.nextLine.update()), this.controlLines.setDrawRange(0, i), this.controlLines.update(), this.vectorLineMesh.update(this.object.shape, this._subdivisions), this.vectorSelectedLineMesh.update(
          this.object.shape,
          this._subdivisions
        ), this.points.update(), this.points.setDrawRange(0, e2), this.controls.update(), this.controls.setDrawRange(0, t2);
      }
    }, t.prototype.clearPointSelection = function() {
      this.points.clearSelection();
    }, t.prototype.setPointSelection = function(e2) {
      var t2 = this;
      this.clearPointSelection(), e2.forEach(function(e3) {
        t2._selectPoint(e3);
      }), this.points.updateSelection(), this.update();
    }, t.prototype._selectPoint = function(e2) {
      this.points.setSelection(e2, true);
    }, t;
  })(EntityMixin(THREE.Group));
  var EntityHelperMixin = function(e, t) {
    return function(e2) {
      function i() {
        var i2 = null !== e2 && e2.apply(this, arguments) || this;
        return i2.objectHelper = new t(i2), i2.enableHelper = false, i2;
      }
      return __extends(i, e2), Object.defineProperty(i.prototype, "visibility", {
        get: function() {
          return this.visible;
        },
        set: function(e3) {
          this.visible = e3, this.setHelperVisibility(e3), this.setHelperChildrenVisibility(e3);
        },
        enumerable: false,
        configurable: true
      }), Object.defineProperty(i.prototype, "geometryHelper", {
        get: function() {
          return t.geometryHelper;
        },
        enumerable: false,
        configurable: true
      }), i.prototype.setHelperVisibility = function(e3) {
        this.objectHelper.visible = e3;
      }, i.prototype.setHelperChildrenVisibility = function(e3) {
        var t2, i2;
        try {
          for (var r = __values(this.children), n = r.next(); !n.done; n = r.next()) {
            var o = n.value;
            isEntity$1(o) && o.traverseEntity(function(t3) {
              isHelperableEntity$1(t3) && t3.visible && (t3.objectHelper.visible = e3);
            });
          }
        } catch (e4) {
          t2 = { error: e4 };
        } finally {
          try {
            n && !n.done && (i2 = r.return) && i2.call(r);
          } finally {
            if (t2) throw t2.error;
          }
        }
      }, i.prototype.raycast = function(e3, t2) {
        this.objectHelper.raycast(e3, t2);
      }, i.prototype.copy = function(t2, i2) {
        return void 0 === i2 && (i2 = true), e2.prototype.copy.call(this, t2, i2), void 0 !== t2.enableHelper && (this.enableHelper = t2.enableHelper), void 0 !== t2.objectHelper && (this.objectHelper.visible = t2.objectHelper.visible), this;
      }, i.prototype.toJSON = function(t2) {
        var i2 = e2.prototype.toJSON.call(this, t2);
        return i2.object.enableHelper = this.enableHelper, i2;
      }, i.prototype.fromJSON = function(t2) {
        return e2.prototype.fromJSON.call(this, t2), void 0 !== t2.enableHelper && (this.enableHelper = true), this;
      }, i;
    }(e);
  }, CombinedCamera = function(e) {
    function t(t2, i, r, n, o) {
      void 0 === t2 && (t2 = 100), void 0 === i && (i = 100), void 0 === r && (r = 45), void 0 === n && (n = 50), void 0 === o && (o = 5e4);
      var a = e.call(this) || this;
      return a.objectType = "CombinedCamera", a.width = window.innerWidth, a.height = window.innerHeight, a.orthoCamera = new THREE.OrthographicCamera(
        -0.5 * t2,
        0.5 * t2,
        0.5 * i,
        -0.5 * i,
        n,
        o
      ), a.perspCamera = new THREE.PerspectiveCamera(r, t2 / i, n, o), a._cameraType = "OrthographicCamera", a.left = a.orthoCamera.left, a.right = a.orthoCamera.right, a.top = a.orthoCamera.top, a.bottom = a.orthoCamera.bottom, a.far = a.orthoCamera.far, a.view = a.orthoCamera.view, a.aspect = a.perspCamera.aspect, a.fov = a.perspCamera.fov, a.focus = a.perspCamera.focus, a.filmGauge = a.perspCamera.filmGauge, a.filmOffset = a.perspCamera.filmOffset, a.targetOffset = 1e3, a.toOrthographic(true), a;
    }
    return __extends(t, e), t.prototype.setDefault = function() {
      this.name = "Default Camera", this.isEntity = false, this.enableHelper = false, this.objectHelper.visible = false;
    }, Object.defineProperty(t.prototype, "cameraType", {
      get: function() {
        return this._cameraType;
      },
      set: function(e2) {
        "PerspectiveCamera" === e2 ? this.toPerspective() : this.toOrthographic();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "near", {
      get: function() {
        return "PerspectiveCamera" === this._cameraType ? this.perspCamera.near : this.orthoCamera.near;
      },
      set: function(e2) {
        "PerspectiveCamera" === this._cameraType ? this.perspCamera.near = e2 : this.orthoCamera.near = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "zoom", {
      get: function() {
        return "PerspectiveCamera" === this._cameraType ? this.perspCamera.zoom : this.orthoCamera.zoom;
      },
      set: function(e2) {
        e2 >= 0 && ("PerspectiveCamera" === this._cameraType ? this.perspCamera.zoom = e2 : this.orthoCamera.zoom = e2);
      },
      enumerable: false,
      configurable: true
    }), t.prototype.getTarget = function(e2) {
      var t2 = this.getWorldDirection(new THREE.Vector3()).multiplyScalar(
        this.targetOffset
      );
      return e2.copy(this.position).add(t2), e2;
    }, t.prototype.getViewFrontToObject = function(e2) {
      var t2 = e2.getWorldPosition(new THREE.Vector3()), i = e2.getWorldDirection(new THREE.Vector3()).multiplyScalar(this.targetOffset);
      return { position: t2.clone().add(i), target: t2 };
    }, t.prototype.getViewToObject = function(e2) {
      var t2 = e2.getWorldPosition(new THREE.Vector3()), i = this.getWorldDirection(new THREE.Vector3()).multiplyScalar(
        this.targetOffset
      );
      return { position: t2.clone().sub(i), target: t2 };
    }, t.prototype.setViewplaneSize = function(e2, t2) {
      this.left = 0.5 * -e2, this.right = 0.5 * e2, this.top = 0.5 * t2, this.bottom = 0.5 * -t2, this.aspect = e2 / t2, this.updateProjectionMatrix();
    }, t.prototype.toOrthographic = function(e2) {
      this.orthoCamera.left = this.left, this.orthoCamera.right = this.right, this.orthoCamera.top = this.top, this.orthoCamera.bottom = this.bottom, this.orthoCamera.view = this.view, this.orthoCamera.far = this.far, this.orthoCamera.updateProjectionMatrix(), this.projectionMatrix = this.orthoCamera.projectionMatrix, this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse, this._cameraType = "OrthographicCamera", true !== this.enableHelper && true !== e2 || this.objectHelper.update();
    }, t.prototype.toPerspective = function(e2) {
      this.perspCamera.aspect = this.aspect, this.perspCamera.fov = this.fov, this.perspCamera.view = this.view, this.perspCamera.far = this.far, this.perspCamera.updateProjectionMatrix(), this.projectionMatrix = this.perspCamera.projectionMatrix, this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse, this._cameraType = "PerspectiveCamera", true !== this.enableHelper && true !== e2 || this.objectHelper.update();
    }, t.prototype.setFocalLength = function(e2) {
      this.perspCamera.setFocalLength(e2), this.toPerspective();
    }, t.prototype.getFocalLength = function() {
      return this.perspCamera.getFocalLength();
    }, t.prototype.getEffectiveFOV = function() {
      return this.perspCamera.getEffectiveFOV();
    }, t.prototype.getFilmWidth = function() {
      return this.perspCamera.getFilmWidth();
    }, t.prototype.getFilmHeight = function() {
      return this.perspCamera.getFilmHeight();
    }, t.prototype.setViewOffset = function(e2, t2, i, r, n, o) {
      "PerspectiveCamera" === this._cameraType ? (this.perspCamera.setViewOffset(e2, t2, i, r, n, o), this.toPerspective()) : (this.orthoCamera.setViewOffset(e2, t2, i, r, n, o), this.toOrthographic());
    }, t.prototype.clearViewOffset = function() {
      "PerspectiveCamera" === this._cameraType ? (this.perspCamera.clearViewOffset(), this.toPerspective()) : (this.orthoCamera.clearViewOffset(), this.toOrthographic());
    }, t.prototype.updateProjectionMatrix = function(e2) {
      "PerspectiveCamera" === this._cameraType ? this.toPerspective(e2) : "OrthographicCamera" === this._cameraType && this.toOrthographic(e2);
    }, t.prototype.updateMatrixWorld = function(t2) {
      e.prototype.updateMatrixWorld.call(this, t2), this.matrixWorldInverse.getInverse(this.matrixWorld);
    }, t.prototype.updateWorldMatrix = function(t2, i) {
      e.prototype.updateWorldMatrix.call(this, t2, i), this.matrixWorldInverse.getInverse(this.matrixWorld);
    }, t.prototype.raycast = function(e2, t2) {
      this.enableHelper && this.objectHelper.visible && this.objectHelper.raycast(e2, t2);
    }, t.prototype.copy = function(t2, i) {
      return e.prototype.copy.call(this, t2, i), this.orthoCamera.copy(t2.orthoCamera), this.perspCamera.copy(t2.perspCamera), this.left = t2.left, this.right = t2.right, this.top = t2.top, this.bottom = t2.bottom, this.far = t2.far, this.view = null === t2.view ? null : Object.assign({}, t2.view), this._cameraType = t2._cameraType, this.aspect = t2.aspect, this.fov = t2.fov, this.focus = t2.focus, this.filmGauge = t2.filmGauge, this.filmOffset = t2.filmOffset, this.targetOffset = t2.targetOffset, this.updateProjectionMatrix(), this;
    }, t.prototype.fromCameraRender = function(e2) {
      var t2 = { near: this.orthoCamera.near, far: this.orthoCamera.far }, i = { near: this.perspCamera.near, far: this.perspCamera.far };
      return this.copy(e2), this.name = "", this.isEntity = true, this.enableHelper = true, this.objectHelper.visible = true, this.orthoCamera.near = t2.near, this.orthoCamera.far = t2.far, this.perspCamera.near = i.near, this.perspCamera.far = i.far, this.updateProjectionMatrix(), this;
    }, t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2), r = i.object;
      return r.objectType = "CombinedCamera", r.cameraType = this.cameraType, r.targetOffset = this.targetOffset, r.left = this.left, r.right = this.right, r.top = this.top, r.bottom = this.bottom, null !== this.view && (r.view = Object.assign({}, this.view)), r.zoomOrtho = this.orthoCamera.zoom, r.nearOrtho = this.orthoCamera.near, r.far = this.far, r.aspect = this.aspect, r.fov = this.fov, r.focus = this.focus, r.filmGauge = this.filmGauge, r.filmOffset = this.filmOffset, r.zoomPersp = this.perspCamera.zoom, r.nearPersp = this.perspCamera.near, i;
    }, t.prototype.fromJSON = function(t2) {
      return e.prototype.fromJSON.call(this, t2), this.cameraType = t2.cameraType, void 0 !== t2.targetOffset && (this.targetOffset = t2.targetOffset), void 0 !== t2.left && (this.left = t2.left), void 0 !== t2.right && (this.right = t2.right), void 0 !== t2.top && (this.top = t2.top), void 0 !== t2.bottom && (this.bottom = t2.bottom), void 0 !== t2.view && (this.view = Object.assign({}, t2.view)), void 0 !== t2.zoomOrtho && (this.orthoCamera.zoom = t2.zoomOrtho), void 0 !== t2.nearOrtho && (this.orthoCamera.near = t2.nearOrtho), void 0 !== t2.far && (this.far = t2.far), void 0 !== t2.aspect && (this.aspect = t2.aspect), void 0 !== t2.fov && (this.fov = t2.fov), void 0 !== t2.focus && (this.focus = t2.focus), void 0 !== t2.filmGauge && (this.filmGauge = t2.filmGauge), void 0 !== t2.filmOffset && (this.filmOffset = t2.filmOffset), void 0 !== t2.zoomPersp && (this.perspCamera.zoom = t2.zoomPersp), void 0 !== t2.nearPersp && (this.perspCamera.near = t2.nearPersp), this.updateProjectionMatrix(), this;
    }, t;
  }(EntityHelperMixin(EntityMixin(THREE.Camera), CombinedCameraHelper)), EmptyObject = function(e) {
    function t() {
      var t2 = null !== e && e.apply(this, arguments) || this;
      return t2.objectType = "EmptyObject", t2;
    }
    return __extends(t, e), t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2);
      return i.object.objectType = "EmptyObject", i;
    }, t;
  }(EntityHelperMixin(EntityMixin(THREE.Group), EmptyObjectHelper)), LightDirectional = function(e) {
    function t() {
      for (var t2 = [], i = 0; i < arguments.length; i++) t2[i] = arguments[i];
      var r = e.apply(this, __spread(t2)) || this;
      r.objectType = "LightDirectional", r._gizmos = {}, r.shadow.mapSize.width = 1024, r.shadow.mapSize.height = 1024;
      var n = r.shadow, o = n.camera;
      o.top = 1250, o.bottom = -1250, o.right = 1250, o.left = -1250, o.near = 1, o.far = 2500;
      var a = new THREE.CameraHelper(r.shadow.camera);
      return a.visible = false, r._gizmos.shadowmap = a, r.update(), r;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "gizmos", {
      get: function() {
        return this._gizmos;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.showGizmos = function() {
      for (var e2 in this._gizmos) {
        var t2 = this._gizmos[e2];
        t2 instanceof THREE.CameraHelper && (t2.visible = true);
      }
    }, t.prototype.hideGizmos = function() {
      for (var e2 in this._gizmos) {
        var t2 = this._gizmos[e2];
        t2 instanceof THREE.CameraHelper && (t2.visible = false);
      }
    }, t.prototype.update = function() {
      for (var e2 in this.shadow.camera.updateProjectionMatrix(), this._gizmos) {
        var t2 = this._gizmos[e2];
        t2 instanceof THREE.CameraHelper && t2.update();
      }
    }, t.prototype.updateMatrixWorld = function(t2) {
      e.prototype.updateMatrixWorld.call(this, t2), true === this.enableHelper && true === this.objectHelper.visible && this.objectHelper.update();
    }, t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2), r = i.object;
      return r.objectType = "LightDirectional", r.color = this.color.getHex(), r.intensity = this.intensity, r.shadow = this.shadow.toJSON(), i;
    }, t.prototype.fromJSON = function(t2) {
      e.prototype.fromJSON.call(this, t2), this.color.set(t2.color), this.intensity = t2.intensity, this.shadow.radius = t2.shadow.radius, this.shadow.mapSize.fromArray(t2.shadow.mapSize);
      var i = this.shadow.camera, r = t2.shadow.camera;
      return i.near = r.near, i.far = r.far, i.zoom = r.zoom, i.left = r.left, i.right = r.right, i.top = r.top, i.bottom = r.bottom, void 0 !== r.view && (i.view = Object.assign({}, r.view)), this;
    }, t;
  }(
    EntityHelperMixin(
      EntityMixin(THREE.DirectionalLight),
      DirectionalLightHelper
    )
  ), LightPoint = function(e) {
    function t() {
      for (var t2 = [], i = 0; i < arguments.length; i++) t2[i] = arguments[i];
      var r = e.apply(this, __spread(t2)) || this;
      r.objectType = "LightPoint", r._gizmos = {}, r.shadow.mapSize.width = 1024, r.shadow.mapSize.height = 1024;
      var n = r.shadow, o = n.camera;
      o.fov = 90, o.aspect = 1, o.near = 100, o.far = 2500;
      var a = new THREE.Vector3(
        -o.far + r.position.x,
        -o.far + r.position.y,
        -o.far + r.position.z
      ), s = new THREE.Vector3(
        o.far + r.position.x,
        o.far + r.position.y,
        o.far + r.position.z
      ), l = new THREE.Box3(a, s), c = new THREE.Box3Helper(l, new THREE.Color(16755200));
      return c.visible = false, r._gizmos.shadowmap = c, r.update(), r;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "gizmos", {
      get: function() {
        return this._gizmos;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.showGizmos = function() {
      for (var e2 in this._gizmos) {
        var t2 = this._gizmos[e2];
        t2 instanceof THREE.Box3Helper && (t2.visible = true);
      }
    }, t.prototype.hideGizmos = function() {
      for (var e2 in this._gizmos) {
        var t2 = this._gizmos[e2];
        t2 instanceof THREE.Box3Helper && (t2.visible = false);
      }
    }, t.prototype.update = function() {
      if (this.shadow && (this.shadow.camera.updateProjectionMatrix(), this._gizmos))
        for (var e2 in this._gizmos) {
          var t2 = this._gizmos[e2];
          if (t2 instanceof THREE.Box3Helper) {
            var i = this.shadow.camera, r = new THREE.Vector3(
              -i.far + this.position.x,
              -i.far + this.position.y,
              -i.far + this.position.z
            ), n = new THREE.Vector3(
              i.far + this.position.x,
              i.far + this.position.y,
              i.far + this.position.z
            );
            t2.box.set(r, n), t2.updateMatrixWorld(true);
          }
        }
    }, t.prototype.updateMatrixWorld = function(t2) {
      e.prototype.updateWorldMatrix.call(this, t2), true === this.enableHelper && true === this.objectHelper.visible && this.objectHelper.update();
    }, t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2), r = i.object;
      return r.objectType = "LightPoint", r.color = this.color.getHex(), r.intensity = this.intensity, r.distance = this.distance, r.decay = this.decay, r.shadow = this.shadow.toJSON(), i;
    }, t.prototype.fromJSON = function(t2) {
      e.prototype.fromJSON.call(this, t2), this.color.set(t2.color), this.intensity = t2.intensity, this.distance = t2.distance, this.decay = t2.decay, this.shadow.radius = t2.shadow.radius, this.shadow.mapSize.fromArray(t2.shadow.mapSize);
      var i = this.shadow.camera, r = t2.shadow.camera;
      return i.near = r.near, i.far = r.far, i.zoom = r.zoom, i.fov = r.fov, i.focus = r.focus, i.aspect = r.aspect, i.filmGauge = r.filmGauge, i.filmOffset = r.filmOffset, void 0 !== r.view && (i.view = Object.assign({}, r.view)), this;
    }, t;
  }(EntityHelperMixin(EntityMixin(THREE.PointLight), PointLightHelper)), _v1 = new THREE.Vector3(), _position$1 = new THREE.Vector3(), _quaternion = new THREE.Quaternion(), LightSpot = function(e) {
    function t() {
      for (var t2 = [], i = 0; i < arguments.length; i++) t2[i] = arguments[i];
      var r = e.apply(this, __spread(t2)) || this;
      r.objectType = "LightSpot", r._gizmos = {}, r.shadow.mapSize.width = 1024, r.shadow.mapSize.height = 1024;
      var n = r.shadow, o = n.camera;
      o.fov = 2 * THREE.MathUtils.RAD2DEG * r.angle, o.aspect = 1, o.near = 100, o.far = 2500;
      var a = new THREE.CameraHelper(r.shadow.camera);
      return a.visible = false, r._gizmos.shadowmap = a, r.update(), r;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "gizmos", {
      get: function() {
        return this._gizmos;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.showGizmos = function() {
      for (var e2 in this._gizmos) {
        var t2 = this._gizmos[e2];
        t2 instanceof THREE.CameraHelper && (t2.visible = true);
      }
    }, t.prototype.hideGizmos = function() {
      for (var e2 in this._gizmos) {
        var t2 = this._gizmos[e2];
        t2 instanceof THREE.CameraHelper && (t2.visible = false);
      }
    }, t.prototype.update = function() {
      for (var e2 in this.shadow.camera.updateProjectionMatrix(), this._gizmos) {
        var t2 = this._gizmos[e2];
        t2 instanceof THREE.CameraHelper && t2.update();
      }
    }, t.prototype.updateMatrixWorld = function(t2) {
      e.prototype.updateWorldMatrix.call(this, t2), _position$1.setFromMatrixPosition(this.matrixWorld), _quaternion.setFromRotationMatrix(this.matrixWorld), _v1.copy(this.up).applyQuaternion(_quaternion).negate().multiplyScalar(this.distance), this.target.position.copy(_position$1).add(_v1), this.target.updateMatrixWorld(), true === this.enableHelper && true === this.objectHelper.visible && this.objectHelper.update();
    }, t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2), r = i.object;
      return r.objectType = "LightSpot", r.color = this.color.getHex(), r.intensity = this.intensity, r.distance = this.distance, r.angle = this.angle, r.decay = this.decay, r.penumbra = this.penumbra, r.shadow = this.shadow.toJSON(), i;
    }, t.prototype.fromJSON = function(t2) {
      e.prototype.fromJSON.call(this, t2), this.color.set(t2.color), this.intensity = t2.intensity, this.distance = t2.distance, this.angle = t2.angle, this.decay = t2.decay, this.penumbra = t2.penumbra, this.shadow.radius = t2.shadow.radius, this.shadow.mapSize.fromArray(t2.shadow.mapSize);
      var i = this.shadow.camera, r = t2.shadow.camera;
      return i.near = r.near, i.far = r.far, i.zoom = r.zoom, i.fov = r.fov, i.focus = r.focus, i.aspect = r.aspect, i.filmGauge = r.filmGauge, i.filmOffset = r.filmOffset, void 0 !== r.view && (i.view = Object.assign({}, r.view)), this;
    }, t;
  }(EntityHelperMixin(EntityMixin(THREE.SpotLight), SpotLightHelper));
  class BasicMaterial extends THREE.MeshPhongMaterial {
    constructor(e) {
      let t;
      void 0 === e && (e = {}), void 0 === e.color && (e.color = 5855577), void 0 === e.transparent && (e.transparent = true), void 0 === e.side && (e.side = THREE.DoubleSide), void 0 !== e.map && (t = e.map, delete e.map), super(e), this.userData.type = "BasicMaterial", this.userData.category = "Basic", this.userData.layers = new LayerStack(this.color, this.opacity), t && (async () => {
        for (; void 0 === t.image; )
          await new Promise((e2) => requestAnimationFrame(e2));
        this.userData.layers.addLayerAt(1, {
          id: this.userData.layers.id++,
          type: "texture",
          texture: t
        }), this.dispose();
      })(), this.onBeforeCompile = ShaderLib.createCallback(this);
    }
    get layersList() {
      return this.userData.layers;
    }
    set layersList(e) {
      this.userData.layers = e;
    }
    equals(e) {
      return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
      if (void 0 !== e.userData.layers && e.userData.layers instanceof LayerStack == true) {
        const t = e.userData.layers;
        e.userData.layers = void 0, super.copy(e), e.userData.layers = t, this.userData.layers = t.clone();
      } else super.copy(e);
      return this;
    }
    toJSON(e) {
      const t = this.userData.layers;
      this.userData.layers = void 0;
      let i = super.toJSON(e);
      return i.userData = JSON.parse(JSON.stringify(this.userData)), i.userData.layers = t.toJSON(e), this.userData.layers = t, i;
    }
    static fromMaterial(e) {
      const t = {};
      return e.color && (t.color = e.color), e.opacity && (t.opacity = e.opacity), e.map && (t.map = e.map), new PhongMaterial(t);
    }
    static fromJSON(e, t) {
      const i = new BasicMaterial();
      return i.copy(e), i.userData.layers = new LayerStack().fromJSON(e.userData.layers, t), i;
    }
    dispose() {
      super.dispose(), this.userData.layers.dispose();
    }
  }
  class LambertMaterial extends THREE.MeshLambertMaterial {
    constructor(e) {
      void 0 === e && (e = {}), void 0 === e.color && (e.color = 5855577), void 0 === e.transparent && (e.transparent = true), void 0 === e.side && (e.side = THREE.FrontSide);
      const t = e.map;
      void 0 !== e.map && delete e.map, super(e), this.userData.type = "LambertMaterial", this.userData.category = "Lambert", this.userData.layers = new LayerStack(this.color, this.opacity), t && (async () => {
        for (; void 0 === t.image; )
          await new Promise((e2) => requestAnimationFrame(e2));
        this.userData.layers.addLayerAt(1, {
          id: this.userData.layers.id++,
          type: "texture",
          texture: t
        }), this.dispose();
      })(), this.onBeforeCompile = ShaderLib.createCallback(this);
    }
    get layersList() {
      return this.userData.layers;
    }
    set layersList(e) {
      this.userData.layers = e;
    }
    equals(e) {
      return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
      if (void 0 !== e.userData.layers && e.userData.layers instanceof LayerStack == true) {
        const t = e.userData.layers;
        e.userData.layers = void 0, super.copy(e), e.userData.layers = t, this.userData.layers = t.clone();
      } else super.copy(e);
      return this;
    }
    toJSON(e) {
      const t = this.userData.layers;
      this.userData.layers = void 0;
      let i = super.toJSON(e);
      return i.userData = JSON.parse(JSON.stringify(this.userData)), i.userData.layers = t.toJSON(e), this.userData.layers = t, i;
    }
    static fromJSON(e, t) {
      const i = new LambertMaterial();
      return i.copy(e), i.userData.layers = new LayerStack().fromJSON(e.userData.layers, t), i;
    }
    dispose() {
      super.dispose(), this.userData.layers.dispose();
    }
  }
  class PhongMaterial$1 extends THREE.MeshPhongMaterial {
    constructor(e) {
      let t;
      void 0 === e && (e = {}), void 0 === e.color && (e.color = 5855577), void 0 === e.transparent && (e.transparent = true), void 0 === e.side && (e.side = THREE.FrontSide), void 0 !== e.map && (t = e.map, delete e.map), super(e), this.userData.type = "PhongMaterial", this.userData.category = "Phong", this.userData.layers = new LayerStack(this.color, this.opacity), t && (async () => {
        for (; void 0 === t.image; )
          await new Promise((e2) => requestAnimationFrame(e2));
        this.userData.layers.addLayerAt(1, {
          id: this.userData.layers.id++,
          type: "texture",
          texture: t
        }), this.dispose();
      })(), this.onBeforeCompile = ShaderLib.createCallback(this);
    }
    get layersList() {
      return this.userData.layers;
    }
    set layersList(e) {
      this.userData.layers = e;
    }
    equals(e) {
      return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
      if (void 0 !== e.userData.layers && e.userData.layers instanceof LayerStack == true) {
        const t = e.userData.layers;
        e.userData.layers = void 0, super.copy(e), e.userData.layers = t, this.userData.layers = t.clone();
      } else super.copy(e);
      return this;
    }
    static fromMaterial(e) {
      const t = {};
      return e.color && (t.color = e.color), e.opacity && (t.opacity = e.opacity), e.map && (t.map = e.map), new PhongMaterial$1(t);
    }
    toJSON(e) {
      const t = this.userData.layers;
      this.userData.layers = void 0;
      let i = super.toJSON(e);
      return i.userData = JSON.parse(JSON.stringify(this.userData)), i.userData.layers = t.toJSON(e), this.userData.layers = t, i;
    }
    static fromJSON(e, t) {
      const i = new PhongMaterial$1();
      return i.copy(e), i.userData.layers = new LayerStack().fromJSON(e.userData.layers, t), i;
    }
    dispose() {
      super.dispose(), this.userData.layers.dispose();
    }
  }
  class PhysicalMaterial extends THREE.MeshPhysicalMaterial {
    constructor(e) {
      void 0 === e && (e = {}), void 0 === e.color && (e.color = 5855577), void 0 === e.transparent && (e.transparent = true), void 0 === e.side && (e.side = THREE.FrontSide), void 0 === e.roughness && (e.roughness = 0.3);
      const t = e.map;
      void 0 !== e.map && delete e.map, super(e), this.userData.type = "PhysicalMaterial", this.userData.category = "Physical", this.userData.layers = new LayerStack(this.color, this.opacity), t && (async () => {
        for (; void 0 === t.image; )
          await new Promise((e2) => requestAnimationFrame(e2));
        this.userData.layers.addLayerAt(1, {
          id: this.userData.layers.id++,
          type: "texture",
          texture: t
        }), this.dispose();
      })(), this.onBeforeCompile = ShaderLib.createCallback(this);
    }
    get layersList() {
      return this.userData.layers;
    }
    set layersList(e) {
      this.userData.layers = e;
    }
    equals(e) {
      return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
      if (void 0 !== e.userData.layers && e.userData.layers instanceof LayerStack == true) {
        const t = e.userData.layers;
        e.userData.layers = void 0, super.copy(e), e.userData.layers = t, this.userData.layers = t.clone();
      } else super.copy(e);
      return this;
    }
    toJSON(e) {
      const t = this.userData.layers;
      this.userData.layers = void 0;
      let i = super.toJSON(e);
      return i.userData = JSON.parse(JSON.stringify(this.userData)), i.userData.layers = t.toJSON(e), this.userData.layers = t, i;
    }
    static fromJSON(e, t) {
      const i = new PhysicalMaterial();
      return i.copy(e), i.userData.layers = new LayerStack().fromJSON(e.userData.layers, t), i;
    }
    dispose() {
      super.dispose(), this.userData.layers.dispose();
    }
  }
  class ToonMaterial extends THREE.MeshToonMaterial {
    constructor(e) {
      void 0 === e && (e = {}), void 0 === e.color && (e.color = 5855577), void 0 === e.transparent && (e.transparent = true), void 0 === e.side && (e.side = THREE.FrontSide);
      const t = e.map;
      void 0 !== e.map && delete e.map, super(e), this.userData.type = "ToonMaterial", this.userData.category = "Toon", this.userData.layers = new LayerStack(this.color, this.opacity), t && (async () => {
        for (; void 0 === t.image; )
          await new Promise((e2) => requestAnimationFrame(e2));
        this.userData.layers.addLayerAt(1, {
          id: this.userData.layers.id++,
          type: "texture",
          texture: t
        }), this.dispose();
      })(), this.onBeforeCompile = ShaderLib.createCallback(this);
    }
    get layersList() {
      return this.userData.layers;
    }
    set layersList(e) {
      this.userData.layers = e;
    }
    equals(e) {
      return this.userData.type === e.userData.type && this.userData.layers.uuid == e.userData.layers.uuid;
    }
    copy(e) {
      if (void 0 !== e.userData.layers && e.userData.layers instanceof LayerStack == true) {
        const t = e.userData.layers;
        e.userData.layers = void 0, super.copy(e), e.userData.layers = t, this.userData.layers = t.clone();
      } else super.copy(e);
      return this;
    }
    toJSON(e) {
      const t = this.userData.layers;
      this.userData.layers = void 0;
      let i = super.toJSON(e);
      return i.userData = JSON.parse(JSON.stringify(this.userData)), i.userData.layers = t.toJSON(e), this.userData.layers = t, i;
    }
    static fromJSON(e, t) {
      const i = new ToonMaterial();
      return i.copy(e), i.userData.layers = new LayerStack().fromJSON(e.userData.layers, t), i;
    }
    dispose() {
      super.dispose(), this.userData.layers.dispose();
    }
  }
  var isVideoElement = function(e) {
    return "VIDEO" === e.tagName;
  }, TextureUtils = function() {
    function e() {
    }
    return e.resize = function(e2, t, i) {
      var r, n = e2 / t;
      if (i.image) {
        var o = i.image;
        n > (r = isVideoElement(o) ? o.videoWidth / o.videoHeight : o.width / o.height) && ("WEBCAM" == i.imageType ? i.repeat.set(-1, 1 * r / n) : i.repeat.set(1, 1 * r / n)), n < r && ("WEBCAM" == i.imageType ? i.repeat.set(1 * n / r * -1, 1) : i.repeat.set(1 * n / r, 1)), n == r && ("WEBCAM" == i.imageType ? i.repeat.set(-1, 1) : i.repeat.set(1, 1));
      }
    }, e.resizeTextureLayer = function(e2, t, i) {
      var r, n = e2 / t, o = i.image.width / i.image.height;
      r = n > o ? { x: 1, y: o / n } : n < o ? { x: n / o, y: 1 } : { x: 1, y: 1 }, i.repeat.set(r.x, r.y), i.updateMatrix();
    }, e.resizeTextureLayers = function(t, i, r) {
      for (var n = r.userData.layers, o = n.getLayers(), a = 0; a < o.length; a++) {
        var s = o[a];
        if ("texture" === s.type) {
          var l = s.id;
          e.resizeTextureLayer(
            t,
            i,
            s.uniforms["f" + l + "_texture"].value
          ), n.updateLayerUniform(l, "f" + l + "_mat");
        }
      }
    }, e.resizeComplex = function(e2, t, i, r) {
      var n, o = e2 / t, a = i.image;
      n = isVideoElement(a) ? a.videoWidth / a.videoHeight : a.width / a.height, r.geometry.type.includes("Shape") ? (o > n && ("WEBCAM" == i.imageType ? i.repeat.set(1 / e2 * -1, 1 / t * n / o) : i.repeat.set(1 / e2, 1 / t * n / o)), o < n && ("WEBCAM" == i.imageType ? i.repeat.set(1 / e2 * o / n * -1, 1 / t) : i.repeat.set(1 / e2 * o / n, 1 / t)), o == n && ("WEBCAM" == i.imageType ? i.repeat.set(1 / e2 * -1, 1 / t) : i.repeat.set(1 / e2, 1 / t))) : (o > n && ("WEBCAM" == i.imageType ? i.repeat.set(-1, 1 * n / o) : i.repeat.set(1, 1 * n / o)), o < n && ("WEBCAM" == i.imageType ? i.repeat.set(1 * o / n * -1, 1) : i.repeat.set(1 * o / n, 1)), o == n && ("WEBCAM" == i.imageType ? i.repeat.set(-1, 1) : i.repeat.set(1, 1)));
    }, e;
  }(), Mesh2D = function(e) {
    function t(t2, i) {
      void 0 === i && (i = new BasicMaterial());
      var r = e.call(this, t2, i) || this;
      return r.objectType = "Mesh2D", r.castShadow = true, r.receiveShadow = true, r;
    }
    return __extends(t, e), t.prototype.updateGeometry = function(t2) {
      e.prototype.updateGeometry.call(this, t2), this.material.userData.layers && TextureUtils.resizeTextureLayers(
        this.geometry.userData.parameters.width,
        this.geometry.userData.parameters.height,
        this.material
      );
    }, t.prototype.resizeGeometry = function(t2, i) {
      e.prototype.resizeGeometry.call(this, t2, i, 0), this.material.userData.layers && TextureUtils.resizeTextureLayers(
        this.geometry.userData.parameters.width,
        this.geometry.userData.parameters.height,
        this.material
      );
    }, t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2);
      return i.object.objectType = "Mesh2D", i;
    }, t.fromTexture = function(e2) {
      var i, r;
      if (e2 instanceof THREE.VideoTexture) {
        var n = e2.image;
        i = 0.5 * n.videoWidth, r = 0.5 * n.videoHeight;
      } else {
        var o = e2.image;
        i = 0.5 * o.width, r = 0.5 * o.height;
      }
      var a = RectangleGeometry.create({
        parameters: { width: i, height: r }
      }), s = new BasicMaterial();
      return s.layersList.changeLayer(0, { type: "texture", texture: e2 }), s.layersList.moveLayer(0, 1), s.dispose(), new t(a, s);
    }, t;
  }(AbstractMesh), Mesh3D = function(e) {
    function t(t2, i) {
      void 0 === i && (i = new PhongMaterial$1());
      var r = e.call(this, t2, i) || this;
      return r.objectType = "Mesh3D", r.castShadow = true, r.receiveShadow = true, r;
    }
    return __extends(t, e), t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2);
      return i.object.objectType = "Mesh3D", i;
    }, t;
  }(AbstractMesh);
  (function(e) {
    function t(t2, i) {
      void 0 === i && (i = new PhongMaterial$1());
      var r = e.call(this, t2, i) || this;
      return r.objectType = "NonParametric", r;
    }
    return __extends(t, e), t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2);
      return i.object.objectType = "NonParametric", i;
    }, t;
  })(Mesh3D);
  var PlayMode = function() {
    function e(e2, t, i) {
      var r = this;
      this.isEnable = false, this._enableEvent = {}, this._map = {}, this._raycaster = new Raycaster(), this._intersection = new THREE.Vector3(), this._plane = new THREE.Plane(), this._normal = new THREE.Vector3(), this._position = new THREE.Vector3(), this._onMouseDown = function(e3) {
        var t2;
        r._raycaster.setFromCamera(r._getPointer(e3), r._camera);
        var i2 = r._scene.raycastMesh(r._raycaster), n = i2.length > 0 ? i2[0].object : void 0;
        n && (null === (t2 = n.interactionCache.mouseDown) || void 0 === t2 || t2.dispatch(), n.traverseAncestors(function(e4) {
          var t3;
          e4 instanceof EmptyObject && (null === (t3 = e4.interactionCache.mouseDown) || void 0 === t3 || t3.dispatch());
        }));
      }, this._onMouseUp = function(e3) {
        var t2;
        r._raycaster.setFromCamera(r._getPointer(e3), r._camera);
        var i2 = r._scene.raycastMesh(r._raycaster), n = i2.length > 0 ? i2[0].object : void 0;
        n && (null === (t2 = n.interactionCache.mouseUp) || void 0 === t2 || t2.dispatch(), n.traverseAncestors(function(e4) {
          var t3;
          e4 instanceof EmptyObject && (null === (t3 = e4.interactionCache.mouseUp) || void 0 === t3 || t3.dispatch());
        }));
      }, this._onMouseMove = function(e3) {
        var t2, i2, n, o, a;
        if (r._raycaster.setFromCamera(r._getPointer(e3), r._camera), r._camera.getWorldDirection(r._normal), r._normal.negate(), void 0 !== r._enableEvent[INTERACTION_EVENT.MOUSE_HOVER]) {
          var s = r._scene.raycastMesh(r._raycaster), l = s.length > 0 ? s[0].object : void 0;
          if (r._prevObject !== l) {
            if (void 0 !== r._prevObject && (null === (n = r._prevObject.interactionCache.mouseHover) || void 0 === n || n.dispatchReverse(), r._prevSubObjects))
              try {
                for (var c = __values(r._prevSubObjects), u = c.next(); !u.done; u = c.next()) {
                  null === (o = u.value.interactionCache.mouseHover) || void 0 === o || o.dispatchReverse();
                }
              } catch (e4) {
                t2 = { error: e4 };
              } finally {
                try {
                  u && !u.done && (i2 = c.return) && i2.call(c);
                } finally {
                  if (t2) throw t2.error;
                }
              }
            void 0 !== l && (null === (a = l.interactionCache.mouseHover) || void 0 === a || a.dispatch(), r._prevSubObjects = [], l.traverseAncestors(function(e4) {
              var t3;
              if (e4 instanceof EmptyObject) {
                var i3 = e4.interactionCache.mouseHover;
                i3 && (null === (t3 = r._prevSubObjects) || void 0 === t3 || t3.push(e4), null == i3 || i3.dispatch());
              }
            }));
          }
          r._prevObject = l;
        }
        void 0 !== r._enableEvent[INTERACTION_EVENT.LOOK_AT] && r._map[INTERACTION_EVENT.LOOK_AT].forEach(function(e4) {
          var t3, i3 = null === (t3 = e4.interactionCache.lookAt) || void 0 === t3 ? void 0 : t3.distance;
          void 0 !== i3 && (r._plane.set(r._normal, -i3), r._raycaster.ray.intersectPlane(r._plane, r._intersection), e4.interaction.lookAt(r._intersection));
        }), void 0 !== r._enableEvent[INTERACTION_EVENT.FOLLOW] && r._map[INTERACTION_EVENT.FOLLOW].forEach(function(e4) {
          r._plane.setFromNormalAndCoplanarPoint(
            r._normal,
            e4.getWorldPosition(r._position)
          ), r._raycaster.ray.intersectPlane(r._plane, r._intersection), e4.interaction.follow(r._intersection);
        });
      }, this._onKeyDown = function(e3) {
        r._map[INTERACTION_EVENT.KEY_DOWN].forEach(function(t2) {
          var i2, r2 = null === (i2 = t2.interactionCache.keyDown) || void 0 === i2 ? void 0 : i2.find(function(t3) {
            return t3.key === e3.key;
          });
          null == r2 || r2.dispatch();
        });
      }, this._onKeyUp = function(e3) {
        r._map[INTERACTION_EVENT.KEY_UP].forEach(function(t2) {
          var i2, r2 = null === (i2 = t2.interactionCache.keyUp) || void 0 === i2 ? void 0 : i2.find(function(t3) {
            return t3.key === e3.key;
          });
          null == r2 || r2.dispatch();
        });
      }, this._domElement = e2, this._scene = t, this._camera = i;
    }
    return e.prototype.activate = function() {
      var e2, t, i, r = this;
      if (this.isEnable = true, this._scene.traverseEntity(function(e3) {
        var t2, i2;
        if (void 0 !== e3.interaction) {
          e3.interaction.start();
          try {
            for (var n2 = __values(e3.interaction.events), o2 = n2.next(); !o2.done; o2 = n2.next()) {
              var a = o2.value.type;
              r._enableEvent[a] = true, a !== INTERACTION_EVENT.KEY_DOWN && a !== INTERACTION_EVENT.KEY_UP && a !== INTERACTION_EVENT.START && a !== INTERACTION_EVENT.LOOK_AT && a !== INTERACTION_EVENT.FOLLOW || (void 0 === r._map[a] && (r._map[a] = []), r._map[a].push(e3));
            }
          } catch (e4) {
            t2 = { error: e4 };
          } finally {
            try {
              o2 && !o2.done && (i2 = n2.return) && i2.call(n2);
            } finally {
              if (t2) throw t2.error;
            }
          }
        }
      }), void 0 !== this._enableEvent[INTERACTION_EVENT.START])
        try {
          for (var n = __values(this._map[INTERACTION_EVENT.START]), o = n.next(); !o.done; o = n.next()) {
            null === (i = o.value.interactionCache.start) || void 0 === i || i.dispatch();
          }
        } catch (t2) {
          e2 = { error: t2 };
        } finally {
          try {
            o && !o.done && (t = n.return) && t.call(n);
          } finally {
            if (e2) throw e2.error;
          }
        }
      void 0 !== this._enableEvent[INTERACTION_EVENT.MOUSE_DOWN] && this._domElement.addEventListener(
        "pointerdown",
        this._onMouseDown,
        false
      ), void 0 !== this._enableEvent[INTERACTION_EVENT.MOUSE_UP] && this._domElement.addEventListener(
        "pointerup",
        this._onMouseUp,
        false
      ), void 0 === this._enableEvent[INTERACTION_EVENT.MOUSE_HOVER] && void 0 === this._enableEvent[INTERACTION_EVENT.LOOK_AT] && void 0 === this._enableEvent[INTERACTION_EVENT.FOLLOW] || this._domElement.addEventListener(
        "pointermove",
        this._onMouseMove,
        false
      ), void 0 !== this._enableEvent[INTERACTION_EVENT.KEY_DOWN] && document.addEventListener("keydown", this._onKeyDown, false), void 0 !== this._enableEvent[INTERACTION_EVENT.KEY_UP] && document.addEventListener("keyup", this._onKeyUp, false);
    }, e.prototype.deactivate = function() {
      this._scene.traverseEntity(function(e2) {
        void 0 !== e2.interaction && e2.interaction.end(), e2.interaction.cache = void 0;
      }), void 0 !== this._enableEvent[INTERACTION_EVENT.MOUSE_DOWN] && this._domElement.removeEventListener(
        "pointerdown",
        this._onMouseDown
      ), void 0 !== this._enableEvent[INTERACTION_EVENT.MOUSE_UP] && this._domElement.removeEventListener(
        "pointerup",
        this._onMouseUp
      ), void 0 === this._enableEvent[INTERACTION_EVENT.MOUSE_HOVER] && void 0 === this._enableEvent[INTERACTION_EVENT.LOOK_AT] && void 0 === this._enableEvent[INTERACTION_EVENT.FOLLOW] || this._domElement.removeEventListener(
        "pointermove",
        this._onMouseMove
      ), void 0 !== this._enableEvent[INTERACTION_EVENT.KEY_DOWN] && document.removeEventListener("keydown", this._onKeyDown), void 0 !== this._enableEvent[INTERACTION_EVENT.KEY_UP] && document.removeEventListener("keyup", this._onKeyUp), this._enableEvent = {}, this._map = {}, this.isEnable = false;
    }, e.prototype.reset = function() {
      var e2, t, i;
      if (this._scene.traverseEntity(function(e3) {
        e3.interaction.start();
      }), void 0 !== this._enableEvent[INTERACTION_EVENT.START])
        try {
          for (var r = __values(this._map[INTERACTION_EVENT.START]), n = r.next(); !n.done; n = r.next()) {
            null === (i = n.value.interactionCache.start) || void 0 === i || i.dispatch();
          }
        } catch (t2) {
          e2 = { error: t2 };
        } finally {
          try {
            n && !n.done && (t = r.return) && t.call(r);
          } finally {
            if (e2) throw e2.error;
          }
        }
    }, e.prototype._getPointer = function(e2) {
      var t = this._domElement.getBoundingClientRect();
      return {
        x: (e2.clientX - t.left) / t.width * 2 - 1,
        y: -(e2.clientY - t.top) / t.height * 2 + 1
      };
    }, e;
  }(), ColorChannel = { RED: 0, GREEN: 1, BLUE: 2, ALPHA: 3 }, shader_default2 = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", shader_default3 = "uniform sampler2D inputBuffer;uniform sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nvarying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;\n#else\nfloat CoC=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(CoC,CoCNearFar.g*scale);\n#else\nvec2 step=texelSize*CoC;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}", BokehMaterial = class extends THREE.ShaderMaterial {
    constructor(e = false, t = false) {
      super({
        type: "BokehMaterial",
        defines: { PASS: e ? "2" : "1" },
        uniforms: {
          kernel64: new THREE.Uniform(null),
          kernel16: new THREE.Uniform(null),
          inputBuffer: new THREE.Uniform(null),
          cocBuffer: new THREE.Uniform(null),
          texelSize: new THREE.Uniform(new THREE.Vector2()),
          scale: new THREE.Uniform(1)
        },
        fragmentShader: shader_default3,
        vertexShader: shader_default2,
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false
      }), this.toneMapped = false, t && (this.defines.FOREGROUND = "1"), this.generateKernel();
    }
    generateKernel() {
      const e = new Float32Array(128), t = new Float32Array(32);
      let i = 0, r = 0;
      for (let n2 = 0; n2 < 80; ++n2) {
        const o2 = 2.39996323 * n2, a = Math.sqrt(n2) / Math.sqrt(80), s = a * Math.cos(o2), l = a * Math.sin(o2);
        n2 % 5 == 0 ? (t[r++] = s, t[r++] = l) : (e[i++] = s, e[i++] = l);
      }
      const n = [], o = [];
      for (let t2 = 0; t2 < 128; )
        n.push(new THREE.Vector4(e[t2++], e[t2++], e[t2++], e[t2++]));
      for (let e2 = 0; e2 < 32; )
        o.push(new THREE.Vector4(t[e2++], t[e2++], t[e2++], t[e2++]));
      this.uniforms.kernel64.value = n, this.uniforms.kernel16.value = o;
    }
    setTexelSize(e, t) {
      this.uniforms.texelSize.value.set(e, t);
    }
  }, shader_default4 = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focalLength;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focalLength,abs(signedDistance));gl_FragColor.rg=vec2(step(signedDistance,0.0)*magnitude,step(0.0,signedDistance)*magnitude);}", CircleOfConfusionMaterial = class extends THREE.ShaderMaterial {
    constructor(e) {
      super({
        type: "CircleOfConfusionMaterial",
        defines: { DEPTH_PACKING: "0" },
        uniforms: {
          depthBuffer: new THREE.Uniform(null),
          focusDistance: new THREE.Uniform(0),
          focalLength: new THREE.Uniform(0),
          cameraNear: new THREE.Uniform(0.3),
          cameraFar: new THREE.Uniform(1e3)
        },
        fragmentShader: shader_default4,
        vertexShader: shader_default2,
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false
      }), this.toneMapped = false, this.adoptCameraSettings(e);
    }
    get depthPacking() {
      return Number(this.defines.DEPTH_PACKING);
    }
    set depthPacking(e) {
      this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = true;
    }
    adoptCameraSettings(e = null) {
      null !== e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof THREE.PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = true);
    }
  }, shader_default5 = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}", shader_default6 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}", shader_default7 = "#include <common>\n#include <dithering_pars_fragment>\nuniform sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <dithering_fragment>\n}", shader_default8 = "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", ConvolutionMaterial = class extends THREE.ShaderMaterial {
    constructor(e = new THREE.Vector2()) {
      super({
        type: "ConvolutionMaterial",
        uniforms: {
          inputBuffer: new THREE.Uniform(null),
          texelSize: new THREE.Uniform(new THREE.Vector2()),
          halfTexelSize: new THREE.Uniform(new THREE.Vector2()),
          kernel: new THREE.Uniform(0),
          scale: new THREE.Uniform(1)
        },
        fragmentShader: shader_default7,
        vertexShader: shader_default8,
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false
      }), this.toneMapped = false, this.setTexelSize(e.x, e.y), this.kernelSize = KernelSize.LARGE;
    }
    getKernel() {
      return kernelPresets[this.kernelSize];
    }
    setTexelSize(e, t) {
      this.uniforms.texelSize.value.set(e, t), this.uniforms.halfTexelSize.value.set(e, t).multiplyScalar(0.5);
    }
  }, kernelPresets = [
    new Float32Array([0, 0]),
    new Float32Array([0, 1, 1]),
    new Float32Array([0, 1, 1, 2]),
    new Float32Array([0, 1, 2, 2, 3]),
    new Float32Array([0, 1, 2, 3, 4, 4, 5]),
    new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
  ], KernelSize = {
    VERY_SMALL: 0,
    SMALL: 1,
    MEDIUM: 2,
    LARGE: 3,
    VERY_LARGE: 4,
    HUGE: 5
  }, shader_default9 = "uniform sampler2D inputBuffer;uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n}", CopyMaterial = class extends THREE.ShaderMaterial {
    constructor() {
      super({
        type: "CopyMaterial",
        uniforms: {
          inputBuffer: new THREE.Uniform(null),
          opacity: new THREE.Uniform(1)
        },
        fragmentShader: shader_default9,
        vertexShader: shader_default2,
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false
      }), this.toneMapped = false;
    }
  }, EdgeDetectionMaterial = class extends THREE.ShaderMaterial {
    constructor(e = new THREE.Vector2(), t = EdgeDetectionMode.COLOR) {
      super({
        type: "EdgeDetectionMaterial",
        defines: {
          LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
          EDGE_THRESHOLD: "0.1",
          DEPTH_THRESHOLD: "0.01",
          PREDICATION_MODE: "0",
          PREDICATION_THRESHOLD: "0.01",
          PREDICATION_SCALE: "2.0",
          PREDICATION_STRENGTH: "1.0",
          DEPTH_PACKING: "0"
        },
        uniforms: {
          inputBuffer: new THREE.Uniform(null),
          depthBuffer: new THREE.Uniform(null),
          predicationBuffer: new THREE.Uniform(null),
          texelSize: new THREE.Uniform(e)
        },
        fragmentShader: shader_default5,
        vertexShader: shader_default6,
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false
      }), this.toneMapped = false, this.setEdgeDetectionMode(t);
    }
    get depthPacking() {
      return Number(this.defines.DEPTH_PACKING);
    }
    set depthPacking(e) {
      this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = true;
    }
    setEdgeDetectionMode(e) {
      this.defines.EDGE_DETECTION_MODE = e.toFixed(0), this.needsUpdate = true;
    }
    setLocalContrastAdaptationFactor(e) {
      this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"), this.needsUpdate = true;
    }
    setEdgeDetectionThreshold(e) {
      this.defines.EDGE_THRESHOLD = e.toFixed("6"), this.defines.DEPTH_THRESHOLD = (0.1 * e).toFixed("6"), this.needsUpdate = true;
    }
    setPredicationMode(e) {
      this.defines.PREDICATION_MODE = e.toFixed(0), this.needsUpdate = true;
    }
    setPredicationBuffer(e) {
      this.uniforms.predicationBuffer.value = e;
    }
    setPredicationThreshold(e) {
      this.defines.PREDICATION_THRESHOLD = e.toFixed("6"), this.needsUpdate = true;
    }
    setPredicationScale(e) {
      this.defines.PREDICATION_SCALE = e.toFixed("6"), this.needsUpdate = true;
    }
    setPredicationStrength(e) {
      this.defines.PREDICATION_STRENGTH = e.toFixed("6"), this.needsUpdate = true;
    }
  }, EdgeDetectionMode = { DEPTH: 0, LUMA: 1, COLOR: 2 }, PredicationMode = { DISABLED: 0, DEPTH: 1, CUSTOM: 2 }, shader_default17 = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\nuniform sampler2D inputBuffer;\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <encodings_fragment>\n#endif\n#include <dithering_fragment>\n}", shader_default18 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}", EffectMaterial = class extends THREE.ShaderMaterial {
    constructor(e = null, t = null, i = null, r, n = false) {
      super({
        type: "EffectMaterial",
        defines: { DEPTH_PACKING: "0", ENCODE_OUTPUT: "1" },
        uniforms: {
          inputBuffer: new THREE.Uniform(null),
          depthBuffer: new THREE.Uniform(null),
          resolution: new THREE.Uniform(new THREE.Vector2()),
          texelSize: new THREE.Uniform(new THREE.Vector2()),
          cameraNear: new THREE.Uniform(0.3),
          cameraFar: new THREE.Uniform(1e3),
          aspect: new THREE.Uniform(1),
          time: new THREE.Uniform(0)
        },
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false,
        dithering: n
      }), this.toneMapped = false, null !== e && this.setShaderParts(e), null !== t && this.setDefines(t), null !== i && this.setUniforms(i), this.adoptCameraSettings(r);
    }
    get depthPacking() {
      return Number(this.defines.DEPTH_PACKING);
    }
    set depthPacking(e) {
      this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = true;
    }
    setShaderParts(e) {
      return this.fragmentShader = shader_default17.replace(Section.FRAGMENT_HEAD, e.get(Section.FRAGMENT_HEAD)).replace(Section.FRAGMENT_MAIN_UV, e.get(Section.FRAGMENT_MAIN_UV)).replace(
        Section.FRAGMENT_MAIN_IMAGE,
        e.get(Section.FRAGMENT_MAIN_IMAGE)
      ), this.vertexShader = shader_default18.replace(Section.VERTEX_HEAD, e.get(Section.VERTEX_HEAD)).replace(
        Section.VERTEX_MAIN_SUPPORT,
        e.get(Section.VERTEX_MAIN_SUPPORT)
      ), this.needsUpdate = true, this;
    }
    setDefines(e) {
      for (const t of e.entries()) this.defines[t[0]] = t[1];
      return this.needsUpdate = true, this;
    }
    setUniforms(e) {
      for (const t of e.entries()) this.uniforms[t[0]] = t[1];
      return this;
    }
    adoptCameraSettings(e = null) {
      null !== e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof THREE.PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = true);
    }
    setSize(e, t) {
      const i = Math.max(e, 1), r = Math.max(t, 1);
      this.uniforms.resolution.value.set(i, r), this.uniforms.texelSize.value.set(1 / i, 1 / r), this.uniforms.aspect.value = i / r;
    }
  }, Section = {
    FRAGMENT_HEAD: "FRAGMENT_HEAD",
    FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
    FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
    VERTEX_HEAD: "VERTEX_HEAD",
    VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
  }, shader_default20 = "#include <common>\nuniform sampler2D inputBuffer;\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=linearToRelativeLuminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l);\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*l,l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}", LuminanceMaterial = class extends THREE.ShaderMaterial {
    constructor(e = false, t = null) {
      const i = null !== t;
      super({
        type: "LuminanceMaterial",
        uniforms: {
          inputBuffer: new THREE.Uniform(null),
          threshold: new THREE.Uniform(0),
          smoothing: new THREE.Uniform(1),
          range: new THREE.Uniform(i ? t : new THREE.Vector2())
        },
        fragmentShader: shader_default20,
        vertexShader: shader_default2,
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false
      }), this.toneMapped = false, this.colorOutput = e, this.useThreshold = true, this.useRange = i;
    }
    get threshold() {
      return this.uniforms.threshold.value;
    }
    set threshold(e) {
      this.uniforms.threshold.value = e;
    }
    get smoothing() {
      return this.uniforms.smoothing.value;
    }
    set smoothing(e) {
      this.uniforms.smoothing.value = e;
    }
    get useThreshold() {
      return void 0 !== this.defines.THRESHOLD;
    }
    set useThreshold(e) {
      e ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.needsUpdate = true;
    }
    get colorOutput() {
      return void 0 !== this.defines.COLOR;
    }
    set colorOutput(e) {
      e ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = true;
    }
    setColorOutputEnabled(e) {
      this.colorOutput = e;
    }
    get useRange() {
      return void 0 !== this.defines.RANGE;
    }
    set useRange(e) {
      e ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.needsUpdate = true;
    }
    get luminanceRange() {
      return this.useRange;
    }
    set luminanceRange(e) {
      this.useRange = e;
    }
    setLuminanceRangeEnabled(e) {
      this.useRange = e;
    }
  }, shader_default21 = "uniform sampler2D maskTexture;uniform sampler2D inputBuffer;\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nif(mask>0.0){discard;}\n#else\nif(mask==0.0){discard;}\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=(1.0-mask);\n#endif\n#if MASK_FUNCTION == 1\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#else\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#endif\n#endif\n}", MaskMaterial = class extends THREE.ShaderMaterial {
    constructor(e = null) {
      super({
        type: "MaskMaterial",
        uniforms: {
          maskTexture: new THREE.Uniform(e),
          inputBuffer: new THREE.Uniform(null),
          strength: new THREE.Uniform(1)
        },
        fragmentShader: shader_default21,
        vertexShader: shader_default2,
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false
      }), this.toneMapped = false, this.colorChannel = ColorChannel.RED, this.maskFunction = MaskFunction.DISCARD;
    }
    set maskTexture(e) {
      this.uniforms.maskTexture.value = e;
    }
    set colorChannel(e) {
      this.defines.COLOR_CHANNEL = e.toFixed(0), this.needsUpdate = true;
    }
    set maskFunction(e) {
      this.defines.MASK_FUNCTION = e.toFixed(0), this.needsUpdate = true;
    }
    get inverted() {
      return void 0 !== this.defines.INVERTED;
    }
    set inverted(e) {
      this.inverted && !e ? delete this.defines.INVERTED : e && (this.defines.INVERTED = "1"), this.needsUpdate = true;
    }
    get strength() {
      return this.uniforms.strength.value;
    }
    set strength(e) {
      this.uniforms.strength.value = e;
    }
  }, MaskFunction = { DISCARD: 0, MULTIPLY: 1, MULTIPLY_RGB_SET_ALPHA: 2 }, shader_default24 = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\nuniform sampler2D inputBuffer;uniform sampler2D areaTexture;uniform sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}", shader_default25 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}", SMAAWeightsMaterial = class extends THREE.ShaderMaterial {
    constructor(e = new THREE.Vector2(), t = new THREE.Vector2()) {
      super({
        type: "SMAAWeightsMaterial",
        defines: {
          MAX_SEARCH_STEPS_INT: "16",
          MAX_SEARCH_STEPS_FLOAT: "16.0",
          MAX_SEARCH_STEPS_DIAG_INT: "8",
          MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
          CORNER_ROUNDING: "25",
          CORNER_ROUNDING_NORM: "0.25",
          AREATEX_MAX_DISTANCE: "16.0",
          AREATEX_MAX_DISTANCE_DIAG: "20.0",
          AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
          AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
          SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
          SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
        },
        uniforms: {
          inputBuffer: new THREE.Uniform(null),
          areaTexture: new THREE.Uniform(null),
          searchTexture: new THREE.Uniform(null),
          texelSize: new THREE.Uniform(e),
          resolution: new THREE.Uniform(t)
        },
        fragmentShader: shader_default24,
        vertexShader: shader_default25,
        blending: THREE.NoBlending,
        depthWrite: false,
        depthTest: false
      }), this.toneMapped = false;
    }
    setOrthogonalSearchSteps(e) {
      const t = Math.min(Math.max(e, 0), 112);
      this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"), this.needsUpdate = true;
    }
    setDiagonalSearchSteps(e) {
      const t = Math.min(Math.max(e, 0), 20);
      this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"), this.needsUpdate = true;
    }
    setCornerRounding(e) {
      const t = Math.min(Math.max(e, 0), 100);
      this.defines.CORNER_ROUNDING = t.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"), this.needsUpdate = true;
    }
    get diagonalDetection() {
      return void 0 === this.defines.DISABLE_DIAG_DETECTION;
    }
    set diagonalDetection(e) {
      e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = true;
    }
    get cornerRounding() {
      return void 0 === this.defines.DISABLE_CORNER_DETECTION;
    }
    set cornerRounding(e) {
      e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = true;
    }
  }, dummyCamera = new THREE.Camera(), geometry = null;
  function getFullscreenTriangle() {
    if (null === geometry) {
      const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), t = new Float32Array([0, 0, 2, 0, 0, 2]);
      void 0 !== (geometry = new THREE.BufferGeometry()).setAttribute ? (geometry.setAttribute("position", new THREE.BufferAttribute(e, 3)), geometry.setAttribute("uv", new THREE.BufferAttribute(t, 2))) : (geometry.addAttribute("position", new THREE.BufferAttribute(e, 3)), geometry.addAttribute("uv", new THREE.BufferAttribute(t, 2)));
    }
    return geometry;
  }
  var Pass = class {
    constructor(e = "Pass", t = new THREE.Scene(), i = dummyCamera) {
      this.name = e, this.scene = t, this.camera = i, this.screen = null, this.rtt = true, this.needsSwap = true, this.needsDepthTexture = false, this.enabled = true;
    }
    get renderToScreen() {
      return !this.rtt;
    }
    set renderToScreen(e) {
      if (this.rtt === e) {
        const t = this.getFullscreenMaterial();
        null !== t && (t.needsUpdate = true), this.rtt = !e;
      }
    }
    getFullscreenMaterial() {
      return null !== this.screen ? this.screen.material : null;
    }
    setFullscreenMaterial(e) {
      let t = this.screen;
      null !== t ? t.material = e : (t = new THREE.Mesh(getFullscreenTriangle(), e), t.frustumCulled = false, null === this.scene && (this.scene = new THREE.Scene()), this.scene.add(t), this.screen = t);
    }
    getDepthTexture() {
      return null;
    }
    setDepthTexture(e, t = 0) {
    }
    render(e, t, i, r, n) {
      throw new Error("Render method not implemented!");
    }
    setSize(e, t) {
    }
    initialize(e, t, i) {
    }
    dispose() {
      const e = this.getFullscreenMaterial();
      null !== e && e.dispose();
      for (const e2 of Object.keys(this)) {
        const t = this[e2];
        if (null !== t && "function" == typeof t.dispose) {
          if (t instanceof THREE.Scene) continue;
          this[e2].dispose();
        }
      }
    }
  }, AUTO_SIZE = -1, Resizer = class {
    constructor(e, t = AUTO_SIZE, i = AUTO_SIZE, r = 1) {
      this.resizable = e, this.base = new THREE.Vector2(1, 1), this.target = new THREE.Vector2(t, i), this.s = r;
    }
    get scale() {
      return this.s;
    }
    set scale(e) {
      this.s = e, this.target.x = AUTO_SIZE, this.target.y = AUTO_SIZE, this.resizable.setSize(this.base.x, this.base.y);
    }
    get width() {
      const e = this.base, t = this.target;
      let i;
      return i = t.x !== AUTO_SIZE ? t.x : t.y !== AUTO_SIZE ? Math.round(t.y * (e.x / e.y)) : Math.round(e.x * this.s), i;
    }
    set width(e) {
      this.target.x = e, this.resizable.setSize(this.base.x, this.base.y);
    }
    get height() {
      const e = this.base, t = this.target;
      let i;
      return i = t.y !== AUTO_SIZE ? t.y : t.x !== AUTO_SIZE ? Math.round(t.x / (e.x / e.y)) : Math.round(e.y * this.s), i;
    }
    set height(e) {
      this.target.y = e, this.resizable.setSize(this.base.x, this.base.y);
    }
    static get AUTO_SIZE() {
      return AUTO_SIZE;
    }
  }, BlurPass = class extends Pass {
    constructor({
      resolutionScale: e = 0.5,
      width: t = Resizer.AUTO_SIZE,
      height: i = Resizer.AUTO_SIZE,
      kernelSize: r = KernelSize.LARGE
    } = {}) {
      super("BlurPass"), this.renderTargetA = new THREE.WebGLRenderTarget(1, 1, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B", this.resolution = new Resizer(this, t, i, e), this.convolutionMaterial = new ConvolutionMaterial(), this.ditheredConvolutionMaterial = new ConvolutionMaterial(), this.ditheredConvolutionMaterial.dithering = true, this.dithering = false, this.kernelSize = r;
    }
    get width() {
      return this.resolution.width;
    }
    set width(e) {
      this.resolution.width = e;
    }
    get height() {
      return this.resolution.height;
    }
    set height(e) {
      this.resolution.height = e;
    }
    get scale() {
      return this.convolutionMaterial.uniforms.scale.value;
    }
    set scale(e) {
      this.convolutionMaterial.uniforms.scale.value = e, this.ditheredConvolutionMaterial.uniforms.scale.value = e;
    }
    get kernelSize() {
      return this.convolutionMaterial.kernelSize;
    }
    set kernelSize(e) {
      this.convolutionMaterial.kernelSize = e, this.ditheredConvolutionMaterial.kernelSize = e;
    }
    getResolutionScale() {
      return this.resolution.scale;
    }
    setResolutionScale(e) {
      this.resolution.scale = e;
    }
    render(e, t, i, r, n) {
      const o = this.scene, a = this.camera, s = this.renderTargetA, l = this.renderTargetB;
      let c = this.convolutionMaterial, u = c.uniforms;
      const h = c.getKernel();
      let d, f, p, v = t;
      for (this.setFullscreenMaterial(c), f = 0, p = h.length - 1; f < p; ++f)
        d = 0 == (1 & f) ? s : l, u.kernel.value = h[f], u.inputBuffer.value = v.texture, e.setRenderTarget(d), e.render(o, a), v = d;
      this.dithering && (c = this.ditheredConvolutionMaterial, u = c.uniforms, this.setFullscreenMaterial(c)), u.kernel.value = h[f], u.inputBuffer.value = v.texture, e.setRenderTarget(this.renderToScreen ? null : i), e.render(o, a);
    }
    setSize(e, t) {
      const i = this.resolution;
      i.base.set(e, t);
      const r = i.width, n = i.height;
      this.renderTargetA.setSize(r, n), this.renderTargetB.setSize(r, n), this.convolutionMaterial.setTexelSize(1 / r, 1 / n), this.ditheredConvolutionMaterial.setTexelSize(1 / r, 1 / n);
    }
    initialize(e, t, i) {
      t || i !== THREE.UnsignedByteType || (this.renderTargetA.texture.format = THREE.RGBFormat, this.renderTargetB.texture.format = THREE.RGBFormat), void 0 !== i && (this.renderTargetA.texture.type = i, this.renderTargetB.texture.type = i);
    }
    static get AUTO_SIZE() {
      return Resizer.AUTO_SIZE;
    }
  }, ClearMaskPass = class extends Pass {
    constructor() {
      super("ClearMaskPass", null, null), this.needsSwap = false;
    }
    render(e, t, i, r, n) {
      const o = e.state.buffers.stencil;
      o.setLocked(false), o.setTest(false);
    }
  }, color = new THREE.Color(), ClearPass = class extends Pass {
    constructor(e = true, t = true, i = false) {
      super("ClearPass", null, null), this.needsSwap = false, this.color = e, this.depth = t, this.stencil = i, this.overrideClearColor = null, this.overrideClearAlpha = -1;
    }
    render(e, t, i, r, n) {
      const o = this.overrideClearColor, a = this.overrideClearAlpha, s = e.getClearAlpha(), l = null !== o, c = a >= 0;
      l ? (color.copy(e.getClearColor(color)), e.setClearColor(o, c ? a : s)) : c && e.setClearAlpha(a), e.setRenderTarget(this.renderToScreen ? null : t), e.clear(this.color, this.depth, this.stencil), l ? e.setClearColor(color, s) : c && e.setClearAlpha(s);
    }
  }, workaroundEnabled = false, OverrideMaterialManager = class {
    constructor(e = null) {
      this.originalMaterials = /* @__PURE__ */ new Map(), this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.setMaterial(e), this.meshCount = 0, this.replaceMaterial = (e2) => {
        if (e2.isMesh) {
          let t;
          switch (e2.material.side) {
            case THREE.DoubleSide:
              t = this.materialsDoubleSide;
              break;
            case THREE.BackSide:
              t = this.materialsBackSide;
              break;
            default:
              t = this.materials;
          }
          this.originalMaterials.set(e2, e2.material), e2.isSkinnedMesh ? e2.material = t[2] : e2.isInstancedMesh ? e2.material = t[1] : e2.material = t[0], ++this.meshCount;
        }
      };
    }
    setMaterial(e) {
      if (this.disposeMaterials(), this.material = e, null !== e) {
        const t = this.materials = [e.clone(), e.clone(), e.clone()];
        for (const i of t)
          i.uniforms = Object.assign({}, e.uniforms), i.side = THREE.FrontSide;
        t[2].skinning = true, this.materialsBackSide = t.map((t2) => {
          const i = t2.clone();
          return i.uniforms = Object.assign({}, e.uniforms), i.side = THREE.BackSide, i;
        }), this.materialsDoubleSide = t.map((t2) => {
          const i = t2.clone();
          return i.uniforms = Object.assign({}, e.uniforms), i.side = THREE.DoubleSide, i;
        });
      }
    }
    render(e, t, i) {
      const r = e.shadowMap.enabled;
      if (e.shadowMap.enabled = false, workaroundEnabled) {
        const r2 = this.originalMaterials;
        this.meshCount = 0, t.traverse(this.replaceMaterial), e.render(t, i);
        for (const e2 of r2) e2[0].material = e2[1];
        this.meshCount !== r2.size && r2.clear();
      } else {
        const r2 = t.overrideMaterial;
        t.overrideMaterial = this.material, e.render(t, i), t.overrideMaterial = r2;
      }
      e.shadowMap.enabled = r;
    }
    disposeMaterials() {
      if (null !== this.material) {
        const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide);
        for (const t of e) t.dispose();
      }
    }
    dispose() {
      this.originalMaterials.clear(), this.disposeMaterials();
    }
    static get workaroundEnabled() {
      return workaroundEnabled;
    }
    static set workaroundEnabled(e) {
      workaroundEnabled = e;
    }
  }, RenderPass = class extends Pass {
    constructor(e, t, i = null) {
      super("RenderPass", e, t), this.needsSwap = false, this.clearPass = new ClearPass(), this.overrideMaterialManager = null === i ? null : new OverrideMaterialManager(i);
    }
    get renderToScreen() {
      return super.renderToScreen;
    }
    set renderToScreen(e) {
      super.renderToScreen = e, this.clearPass.renderToScreen = e;
    }
    get overrideMaterial() {
      const e = this.overrideMaterialManager;
      return null !== e ? e.material : null;
    }
    set overrideMaterial(e) {
      const t = this.overrideMaterialManager;
      null !== e ? null !== t ? t.setMaterial(e) : this.overrideMaterialManager = new OverrideMaterialManager(e) : null !== t && (t.dispose(), this.overrideMaterialManager = null);
    }
    get clear() {
      return this.clearPass.enabled;
    }
    set clear(e) {
      this.clearPass.enabled = e;
    }
    getClearPass() {
      return this.clearPass;
    }
    render(e, t, i, r, n) {
      const o = this.scene, a = this.camera, s = o.background, l = this.renderToScreen ? null : t;
      this.clear && (null !== this.clearPass.overrideClearColor && (o.background = null), this.clearPass.render(e, t)), e.setRenderTarget(l), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(e, o, a) : e.render(o, a), o.background !== s && (o.background = s);
    }
  }, DepthPass = class extends Pass {
    constructor(e, t, {
      resolutionScale: i = 1,
      width: r = Resizer.AUTO_SIZE,
      height: n = Resizer.AUTO_SIZE,
      renderTarget: o
    } = {}) {
      super("DepthPass"), this.needsSwap = false, this.renderPass = new RenderPass(
        e,
        t,
        new THREE.MeshDepthMaterial({
          depthPacking: THREE.RGBADepthPacking
        })
      );
      const a = this.renderPass.getClearPass();
      a.overrideClearColor = new THREE.Color(16777215), a.overrideClearAlpha = 1, this.renderTarget = o, void 0 === this.renderTarget && (this.renderTarget = new THREE.WebGLRenderTarget(1, 1, {
        minFilter: THREE.NearestFilter,
        magFilter: THREE.NearestFilter,
        stencilBuffer: false
      }), this.renderTarget.texture.name = "DepthPass.Target"), this.resolution = new Resizer(this, r, n, i);
    }
    get texture() {
      return this.renderTarget.texture;
    }
    getResolutionScale() {
      return this.resolutionScale;
    }
    setResolutionScale(e) {
      this.resolutionScale = e, this.setSize(this.resolution.base.x, this.resolution.base.y);
    }
    render(e, t, i, r, n) {
      const o = this.renderToScreen ? null : this.renderTarget;
      this.renderPass.render(e, o);
    }
    setSize(e, t) {
      const i = this.resolution;
      i.base.set(e, t), this.renderTarget.setSize(i.width, i.height);
    }
  }, BlendFunction = {
    SKIP: 0,
    ADD: 1,
    ALPHA: 2,
    AVERAGE: 3,
    COLOR_BURN: 4,
    COLOR_DODGE: 5,
    DARKEN: 6,
    DIFFERENCE: 7,
    EXCLUSION: 8,
    LIGHTEN: 9,
    MULTIPLY: 10,
    DIVIDE: 11,
    NEGATION: 12,
    NORMAL: 13,
    OVERLAY: 14,
    REFLECT: 15,
    SCREEN: 16,
    SOFT_LIGHT: 17,
    SUBTRACT: 18
  }, shader_default28 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}", shader_default29 = "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}", shader_default30 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}", shader_default31 = "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default32 = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default33 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}", shader_default34 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}", shader_default35 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}", shader_default36 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}", shader_default37 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}", shader_default38 = "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default39 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}", shader_default40 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}", shader_default41 = "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default42 = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default43 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}", shader_default44 = "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default45 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}", blendFunctions = /* @__PURE__ */ new Map([
    [BlendFunction.SKIP, null],
    [BlendFunction.ADD, shader_default28],
    [BlendFunction.ALPHA, shader_default29],
    [BlendFunction.AVERAGE, shader_default30],
    [BlendFunction.COLOR_BURN, shader_default31],
    [BlendFunction.COLOR_DODGE, shader_default32],
    [BlendFunction.DARKEN, shader_default33],
    [BlendFunction.DIFFERENCE, shader_default34],
    [BlendFunction.EXCLUSION, shader_default35],
    [BlendFunction.LIGHTEN, shader_default36],
    [BlendFunction.MULTIPLY, shader_default37],
    [BlendFunction.DIVIDE, shader_default38],
    [BlendFunction.NEGATION, shader_default39],
    [BlendFunction.NORMAL, shader_default40],
    [BlendFunction.OVERLAY, shader_default41],
    [BlendFunction.REFLECT, shader_default42],
    [BlendFunction.SCREEN, shader_default43],
    [BlendFunction.SOFT_LIGHT, shader_default44],
    [BlendFunction.SUBTRACT, shader_default45]
  ]), BlendMode = class extends THREE.EventDispatcher {
    constructor(e, t = 1) {
      super(), this.blendFunction = e, this.opacity = new THREE.Uniform(t);
    }
    getBlendFunction() {
      return this.blendFunction;
    }
    setBlendFunction(e) {
      this.blendFunction = e, this.dispatchEvent({ type: "change" });
    }
    getShaderCode() {
      return blendFunctions.get(this.blendFunction);
    }
  }, Effect = class extends THREE.EventDispatcher {
    constructor(e, t, {
      attributes: i = EffectAttribute.NONE,
      blendFunction: r = BlendFunction.SCREEN,
      defines: n = /* @__PURE__ */ new Map(),
      uniforms: o = /* @__PURE__ */ new Map(),
      extensions: a = null,
      vertexShader: s = null
    } = {}) {
      super(), this.name = e, this.attributes = i, this.fragmentShader = t, this.vertexShader = s, this.defines = n, this.uniforms = o, this.extensions = a, this.blendMode = new BlendMode(r), this.blendMode.addEventListener("change", (e2) => this.setChanged());
    }
    setChanged() {
      this.dispatchEvent({ type: "change" });
    }
    getAttributes() {
      return this.attributes;
    }
    setAttributes(e) {
      this.attributes = e, this.setChanged();
    }
    getFragmentShader() {
      return this.fragmentShader;
    }
    setFragmentShader(e) {
      this.fragmentShader = e, this.setChanged();
    }
    getVertexShader() {
      return this.vertexShader;
    }
    setVertexShader(e) {
      this.vertexShader = e, this.setChanged();
    }
    setDepthTexture(e, t = 0) {
    }
    update(e, t, i) {
    }
    setSize(e, t) {
    }
    initialize(e, t, i) {
    }
    dispose() {
      for (const e of Object.keys(this)) {
        const t = this[e];
        if (null !== t && "function" == typeof t.dispose) {
          if (t instanceof THREE.Scene) continue;
          this[e].dispose();
        }
      }
    }
  }, EffectAttribute = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 };
  function findSubstrings(e, t) {
    const i = [];
    let r;
    for (; null !== (r = e.exec(t)); ) i.push(r[1]);
    return i;
  }
  function prefixSubstrings(e, t, i) {
    let r, n;
    for (const o of t) {
      r = "$1" + e + o.charAt(0).toUpperCase() + o.slice(1), n = new RegExp("([^\\.])(\\b" + o + "\\b)", "g");
      for (const e2 of i.entries())
        null !== e2[1] && i.set(e2[0], e2[1].replace(n, r));
    }
  }
  function integrateEffect(e, t, i, r, n, o, a) {
    const s = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g, l = /(?:varying\s+\w+\s+(\w*))/g, c = t.blendMode, u = /* @__PURE__ */ new Map([
      ["fragment", t.getFragmentShader()],
      ["vertex", t.getVertexShader()]
    ]), h = void 0 !== u.get("fragment") && /mainImage/.test(u.get("fragment")), d = void 0 !== u.get("fragment") && /mainUv/.test(u.get("fragment"));
    let f = [], p = [], v = false, m = false;
    if (void 0 === u.get("fragment"))
      console.error("Missing fragment shader", t);
    else if (d && 0 != (a & EffectAttribute.CONVOLUTION))
      console.error(
        "Effects that transform UV coordinates are incompatible with convolution effects",
        t
      );
    else if (h || d) {
      if (d && (i.set(
        Section.FRAGMENT_MAIN_UV,
        i.get(Section.FRAGMENT_MAIN_UV) + "	" + e + "MainUv(UV);\n"
      ), v = true), null !== u.get("vertex") && /mainSupport/.test(u.get("vertex"))) {
        let t2 = "	" + e + "MainSupport(";
        /mainSupport *\([\w\s]*?uv\s*?\)/.test(u.get("vertex")) && (t2 += "vUv"), t2 += ");\n", i.set(
          Section.VERTEX_MAIN_SUPPORT,
          i.get(Section.VERTEX_MAIN_SUPPORT) + t2
        ), f = f.concat(findSubstrings(l, u.get("vertex"))), p = p.concat(f).concat(findSubstrings(s, u.get("vertex")));
      }
      if (p = p.concat(findSubstrings(s, u.get("fragment"))).concat(
        Array.from(t.defines.keys()).map(
          (e2) => e2.replace(/\([\w\s,]*\)/g, "")
        )
      ).concat(Array.from(t.uniforms.keys())), t.uniforms.forEach(
        (t2, i2) => o.set(e + i2.charAt(0).toUpperCase() + i2.slice(1), t2)
      ), t.defines.forEach(
        (t2, i2) => n.set(e + i2.charAt(0).toUpperCase() + i2.slice(1), t2)
      ), prefixSubstrings(e, p, n), prefixSubstrings(e, p, u), r.set(c.blendFunction, c), h) {
        const t2 = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
        let r2 = e + "MainImage(color0, UV, ";
        0 != (a & EffectAttribute.DEPTH) && t2.test(u.get("fragment")) && (r2 += "depth, ", m = true), r2 += "color1);\n	";
        const n2 = e + "BlendOpacity";
        o.set(n2, c.opacity), r2 += "color0 = blend" + c.getBlendFunction() + "(color0, color1, " + n2 + ");\n\n	", i.set(
          Section.FRAGMENT_MAIN_IMAGE,
          i.get(Section.FRAGMENT_MAIN_IMAGE) + r2
        ), i.set(
          Section.FRAGMENT_HEAD,
          i.get(Section.FRAGMENT_HEAD) + "uniform float " + n2 + ";\n\n"
        );
      }
      i.set(
        Section.FRAGMENT_HEAD,
        i.get(Section.FRAGMENT_HEAD) + u.get("fragment") + "\n"
      ), null !== u.get("vertex") && i.set(
        Section.VERTEX_HEAD,
        i.get(Section.VERTEX_HEAD) + u.get("vertex") + "\n"
      );
    } else
      console.error(
        "The fragment shader contains neither a mainImage nor a mainUv function",
        t
      );
    return { varyings: f, transformedUv: v, readDepth: m };
  }
  var EffectPass = class extends Pass {
    constructor(e, ...t) {
      super("EffectPass"), this.setFullscreenMaterial(new EffectMaterial(null, null, null, e)), this.effects = t.sort((e2, t2) => t2.attributes - e2.attributes), this.skipRendering = false, this.uniforms = 0, this.varyings = 0, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY;
    }
    get encodeOutput() {
      return void 0 !== this.getFullscreenMaterial().defines.ENCODE_OUTPUT;
    }
    set encodeOutput(e) {
      if (this.encodeOutput !== e) {
        const t = this.getFullscreenMaterial();
        t.needsUpdate = true, e ? t.defines.ENCODE_OUTPUT = "1" : delete t.defines.ENCODE_OUTPUT;
      }
    }
    get dithering() {
      return this.getFullscreenMaterial().dithering;
    }
    set dithering(e) {
      const t = this.getFullscreenMaterial();
      t.dithering !== e && (t.dithering = e, t.needsUpdate = true);
    }
    verifyResources(e) {
      const t = e.capabilities;
      let i = Math.min(t.maxFragmentUniforms, t.maxVertexUniforms);
      this.uniforms > i && console.warn(
        "The current rendering context doesn't support more than " + i + " uniforms, but " + this.uniforms + " were defined"
      ), i = t.maxVaryings, this.varyings > i && console.warn(
        "The current rendering context doesn't support more than " + i + " varyings, but " + this.varyings + " were defined"
      );
    }
    updateMaterial() {
      const e = /\bblend\b/g, t = /* @__PURE__ */ new Map([
        [Section.FRAGMENT_HEAD, ""],
        [Section.FRAGMENT_MAIN_UV, ""],
        [Section.FRAGMENT_MAIN_IMAGE, ""],
        [Section.VERTEX_HEAD, ""],
        [Section.VERTEX_MAIN_SUPPORT, ""]
      ]), i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set();
      let a, s = 0, l = 0, c = 0, u = false, h = false;
      for (const e2 of this.effects)
        if (e2.blendMode.getBlendFunction() === BlendFunction.SKIP)
          c |= e2.getAttributes() & EffectAttribute.DEPTH;
        else if (0 != (c & EffectAttribute.CONVOLUTION) && 0 != (e2.getAttributes() & EffectAttribute.CONVOLUTION))
          console.error("Convolution effects cannot be merged", e2);
        else if (c |= e2.getAttributes(), a = integrateEffect("e" + s++, e2, t, i, r, n, c), l += a.varyings.length, u = u || a.transformedUv, h = h || a.readDepth, null !== e2.extensions)
          for (const t2 of e2.extensions) o.add(t2);
      for (const r2 of i.values())
        t.set(
          Section.FRAGMENT_HEAD,
          t.get(Section.FRAGMENT_HEAD) + r2.getShaderCode().replace(e, "blend" + r2.getBlendFunction()) + "\n"
        );
      0 != (c & EffectAttribute.DEPTH) ? (h && t.set(
        Section.FRAGMENT_MAIN_IMAGE,
        "float depth = readDepth(UV);\n\n	" + t.get(Section.FRAGMENT_MAIN_IMAGE)
      ), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = false, u ? (t.set(
        Section.FRAGMENT_MAIN_UV,
        "vec2 transformedUv = vUv;\n" + t.get(Section.FRAGMENT_MAIN_UV)
      ), r.set("UV", "transformedUv")) : r.set("UV", "vUv"), t.forEach((e2, t2, i2) => i2.set(t2, e2.trim().replace(/^#/, "\n#"))), this.uniforms = n.size, this.varyings = l, this.skipRendering = 0 === s, this.needsSwap = !this.skipRendering;
      const d = this.getFullscreenMaterial();
      if (d.setShaderParts(t).setDefines(r).setUniforms(n), d.extensions = {}, o.size > 0)
        for (const e2 of o) d.extensions[e2] = true;
      this.needsUpdate = false;
    }
    recompile(e) {
      this.updateMaterial(), void 0 !== e && this.verifyResources(e);
    }
    getDepthTexture() {
      return this.getFullscreenMaterial().uniforms.depthBuffer.value;
    }
    setDepthTexture(e, t = THREE.BasicDepthPacking) {
      const i = this.getFullscreenMaterial();
      i.uniforms.depthBuffer.value = e, i.depthPacking = t, i.needsUpdate = true;
      for (const i2 of this.effects) i2.setDepthTexture(e, t);
    }
    render(e, t, i, r, n) {
      const o = this.getFullscreenMaterial(), a = o.uniforms.time.value + r;
      this.needsUpdate && this.recompile(e);
      for (const i2 of this.effects) i2.update(e, t, r);
      this.skipRendering && !this.renderToScreen || (o.uniforms.inputBuffer.value = t.texture, o.uniforms.time.value = a <= this.maxTime ? a : this.minTime, e.setRenderTarget(this.renderToScreen ? null : i), e.render(this.scene, this.camera));
    }
    setSize(e, t) {
      this.getFullscreenMaterial().setSize(e, t);
      for (const i of this.effects) i.setSize(e, t);
    }
    initialize(e, t, i) {
      this.capabilities = e.capabilities;
      for (const r of this.effects)
        r.initialize(e, t, i), r.addEventListener("change", (e2) => this.handleEvent(e2));
      this.updateMaterial(), this.verifyResources(e);
    }
    dispose() {
      super.dispose();
      for (const e of this.effects) e.dispose();
    }
    handleEvent(e) {
      switch (e.type) {
        case "change":
          this.needsUpdate = true;
      }
    }
  }, LuminancePass = class extends Pass {
    constructor({
      width: e = Resizer.AUTO_SIZE,
      height: t = Resizer.AUTO_SIZE,
      renderTarget: i,
      luminanceRange: r,
      colorOutput: n
    } = {}) {
      super("LuminancePass"), this.setFullscreenMaterial(new LuminanceMaterial(n, r)), this.needsSwap = false, this.renderTarget = i, void 0 === this.renderTarget && (this.renderTarget = new THREE.WebGLRenderTarget(1, 1, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: n ? THREE.RGBAFormat : THREE.LuminanceFormat,
        stencilBuffer: false,
        depthBuffer: false
      }), this.renderTarget.texture.name = "LuminancePass.Target", this.renderTarget.texture.generateMipmaps = false), this.resolution = new Resizer(this, e, t);
    }
    get texture() {
      return this.renderTarget.texture;
    }
    render(e, t, i, r, n) {
      this.getFullscreenMaterial().uniforms.inputBuffer.value = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera);
    }
    setSize(e, t) {
      const i = this.resolution;
      i.base.set(e, t), this.renderTarget.setSize(i.width, i.height);
    }
  }, MaskPass = class extends Pass {
    constructor(e, t) {
      super("MaskPass", e, t), this.needsSwap = false, this.clearPass = new ClearPass(false, false, true), this.inverse = false;
    }
    get clear() {
      return this.clearPass.enabled;
    }
    set clear(e) {
      this.clearPass.enabled = e;
    }
    render(e, t, i, r, n) {
      const o = e.getContext(), a = e.state.buffers, s = this.scene, l = this.camera, c = this.clearPass, u = this.inverse ? 0 : 1, h = 1 - u;
      a.color.setMask(false), a.depth.setMask(false), a.color.setLocked(true), a.depth.setLocked(true), a.stencil.setTest(true), a.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), a.stencil.setFunc(o.ALWAYS, u, 4294967295), a.stencil.setClear(h), a.stencil.setLocked(true), this.clear && (this.renderToScreen ? c.render(e, null) : (c.render(e, t), c.render(e, i))), this.renderToScreen ? (e.setRenderTarget(null), e.render(s, l)) : (e.setRenderTarget(t), e.render(s, l), e.setRenderTarget(i), e.render(s, l)), a.color.setLocked(false), a.depth.setLocked(false), a.stencil.setLocked(false), a.stencil.setFunc(o.EQUAL, 1, 4294967295), a.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), a.stencil.setLocked(true);
    }
  }, ShaderPass = class extends Pass {
    constructor(e, t = "inputBuffer") {
      super("ShaderPass"), this.setFullscreenMaterial(e), this.uniform = null, this.setInput(t);
    }
    setInput(e) {
      const t = this.getFullscreenMaterial();
      if (this.uniform = null, null !== t) {
        const i = t.uniforms;
        void 0 !== i && void 0 !== i[e] && (this.uniform = i[e]);
      }
    }
    render(e, t, i, r, n) {
      null !== this.uniform && null !== t && (this.uniform.value = t.texture), e.setRenderTarget(this.renderToScreen ? null : i), e.render(this.scene, this.camera);
    }
  }, EffectComposer = class {
    constructor(e = null, {
      depthBuffer: t = true,
      stencilBuffer: i = false,
      multisampling: r = 0,
      frameBufferType: n
    } = {}) {
      this.renderer = e, this.inputBuffer = null, this.outputBuffer = null, null !== this.renderer && (this.renderer.autoClear = false, this.inputBuffer = this.createBuffer(t, i, n, r), this.outputBuffer = this.inputBuffer.clone(), this.enableExtensions()), this.copyPass = new ShaderPass(new CopyMaterial()), this.depthTexture = null, this.passes = [], this.autoRenderToScreen = true;
    }
    get multisampling() {
      return this.inputBuffer instanceof THREE.WebGLMultisampleRenderTarget ? this.inputBuffer.samples : 0;
    }
    set multisampling(e) {
      const t = this.inputBuffer, i = this.multisampling;
      i > 0 && e > 0 ? (this.inputBuffer.samples = e, this.outputBuffer.samples = e) : i !== e && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(
        t.depthBuffer,
        t.stencilBuffer,
        t.texture.type,
        e
      ), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone());
    }
    getRenderer() {
      return this.renderer;
    }
    enableExtensions() {
      const e = this.inputBuffer.texture.type, t = this.renderer.capabilities, i = this.renderer.getContext();
      e !== THREE.UnsignedByteType && (t.isWebGL2 ? i.getExtension("EXT_color_buffer_float") : i.getExtension("EXT_color_buffer_half_float"));
    }
    replaceRenderer(e, t = true) {
      const i = this.renderer;
      if (null !== i && i !== e) {
        const r = i.getSize(new THREE.Vector2()), n = e.getSize(new THREE.Vector2()), o = i.domElement.parentNode;
        this.renderer = e, this.renderer.autoClear = false, r.equals(n) || this.setSize(), t && null !== o && (o.removeChild(i.domElement), o.appendChild(e.domElement)), this.enableExtensions();
      }
      return i;
    }
    createDepthTexture() {
      const e = this.depthTexture = new THREE.DepthTexture();
      return this.inputBuffer.depthTexture = e, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (e.format = THREE.DepthStencilFormat, e.type = THREE.UnsignedInt248Type) : e.type = THREE.UnsignedIntType, e;
    }
    deleteDepthTexture() {
      if (null !== this.depthTexture) {
        this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
        for (const e of this.passes) e.setDepthTexture(null);
      }
    }
    createBuffer(e, t, i, r) {
      const n = this.renderer.getDrawingBufferSize(new THREE.Vector2()), o = {
        format: this.renderer.getContext().getContextAttributes().alpha || i !== THREE.UnsignedByteType ? THREE.RGBAFormat : THREE.RGBFormat,
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        stencilBuffer: t,
        depthBuffer: e,
        type: i
      }, a = r > 0 ? new THREE.WebGLMultisampleRenderTarget(n.width, n.height, o) : new THREE.WebGLRenderTarget(n.width, n.height, o);
      return r > 0 && (a.samples = r), a.texture.name = "EffectComposer.Buffer", a.texture.generateMipmaps = false, a;
    }
    addPass(e, t) {
      const i = this.passes, r = this.renderer, n = r.getDrawingBufferSize(new THREE.Vector2()), o = r.getContext().getContextAttributes().alpha, a = this.inputBuffer.texture.type;
      if (e.setSize(n.width, n.height), e.initialize(r, o, a), this.autoRenderToScreen && (i.length > 0 && (i[i.length - 1].renderToScreen = false), e.renderToScreen && (this.autoRenderToScreen = false)), void 0 !== t ? i.splice(t, 0, e) : i.push(e), this.autoRenderToScreen && (i[i.length - 1].renderToScreen = true), e.needsDepthTexture || null !== this.depthTexture)
        if (null === this.depthTexture) {
          const t2 = this.createDepthTexture();
          for (e of i) e.setDepthTexture(t2);
        } else e.setDepthTexture(this.depthTexture);
    }
    removePass(e) {
      const t = this.passes, i = t.indexOf(e);
      if (-1 !== i && t.splice(i, 1).length > 0) {
        if (null !== this.depthTexture) {
          const i2 = (e2, t2) => e2 || t2.needsDepthTexture;
          t.reduce(i2, false) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null), this.deleteDepthTexture());
        }
        this.autoRenderToScreen && i === t.length && (e.renderToScreen = false, t.length > 0 && (t[t.length - 1].renderToScreen = true));
      }
    }
    removeAllPasses() {
      const e = this.passes;
      this.deleteDepthTexture(), e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = false), this.passes = []);
    }
    render(e) {
      const t = this.renderer, i = this.copyPass;
      let r, n, o, a = this.inputBuffer, s = this.outputBuffer, l = false;
      for (const c of this.passes)
        c.enabled && (c.render(t, a, s, e, l), c.needsSwap && (l && (i.renderToScreen = c.renderToScreen, r = t.getContext(), n = t.state.buffers.stencil, n.setFunc(r.NOTEQUAL, 1, 4294967295), i.render(t, a, s, e, l), n.setFunc(r.EQUAL, 1, 4294967295)), o = a, a = s, s = o), c instanceof MaskPass ? l = true : c instanceof ClearMaskPass && (l = false));
    }
    setSize(e, t, i) {
      const r = this.renderer;
      if (void 0 === e || void 0 === t) {
        const i2 = r.getSize(new THREE.Vector2());
        e = i2.width, t = i2.height;
      } else r.setSize(e, t, i);
      const n = r.getDrawingBufferSize(new THREE.Vector2());
      this.inputBuffer.setSize(n.width, n.height), this.outputBuffer.setSize(n.width, n.height);
      for (const e2 of this.passes) e2.setSize(n.width, n.height);
    }
    reset() {
      this.dispose(), this.autoRenderToScreen = true;
    }
    dispose() {
      for (const e of this.passes) e.dispose();
      this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose();
    }
  }, shader_default46 = "uniform sampler2D texture;uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(texture,uv)*intensity,0.0,1.0);}", BloomEffect = class extends Effect {
    constructor({
      blendFunction: e = BlendFunction.SCREEN,
      luminanceThreshold: t = 0.9,
      luminanceSmoothing: i = 0.025,
      resolutionScale: r = 0.5,
      intensity: n = 1,
      width: o = Resizer.AUTO_SIZE,
      height: a = Resizer.AUTO_SIZE,
      kernelSize: s = KernelSize.LARGE
    } = {}) {
      super("BloomEffect", shader_default46, {
        blendFunction: e,
        uniforms: /* @__PURE__ */ new Map([
          ["texture", new THREE.Uniform(null)],
          ["intensity", new THREE.Uniform(n)]
        ])
      }), this.renderTarget = new THREE.WebGLRenderTarget(1, 1, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      }), this.renderTarget.texture.name = "Bloom.Target", this.renderTarget.texture.generateMipmaps = false, this.uniforms.get("texture").value = this.renderTarget.texture, this.blurPass = new BlurPass({
        resolutionScale: r,
        width: o,
        height: a,
        kernelSize: s
      }), this.blurPass.resolution.resizable = this, this.luminancePass = new LuminancePass({
        renderTarget: this.renderTarget,
        colorOutput: true
      }), this.luminancePass.resolution = this.resolution, this.luminanceMaterial.threshold = t, this.luminanceMaterial.smoothing = i;
    }
    get texture() {
      return this.renderTarget.texture;
    }
    get luminanceMaterial() {
      return this.luminancePass.getFullscreenMaterial();
    }
    get resolution() {
      return this.blurPass.resolution;
    }
    get width() {
      return this.resolution.width;
    }
    set width(e) {
      this.resolution.width = e;
    }
    get height() {
      return this.resolution.height;
    }
    set height(e) {
      this.resolution.height = e;
    }
    get dithering() {
      return this.blurPass.dithering;
    }
    set dithering(e) {
      this.blurPass.dithering = e;
    }
    get kernelSize() {
      return this.blurPass.kernelSize;
    }
    set kernelSize(e) {
      this.blurPass.kernelSize = e;
    }
    get distinction() {
      return console.warn(
        this.name,
        "The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead."
      ), 1;
    }
    set distinction(e) {
      console.warn(
        this.name,
        "The distinction field has been removed, use luminanceMaterial.threshold and luminanceMaterial.smoothing instead."
      );
    }
    get intensity() {
      return this.uniforms.get("intensity").value;
    }
    set intensity(e) {
      this.uniforms.get("intensity").value = e;
    }
    getResolutionScale() {
      return this.resolution.scale;
    }
    setResolutionScale(e) {
      this.resolution.scale = e;
    }
    update(e, t, i) {
      const r = this.renderTarget;
      this.luminancePass.enabled ? (this.luminancePass.render(e, t, r), this.blurPass.render(e, r, r)) : this.blurPass.render(e, t, r);
    }
    setSize(e, t) {
      this.blurPass.setSize(e, t), this.renderTarget.setSize(
        this.resolution.width,
        this.resolution.height
      );
    }
    initialize(e, t, i) {
      this.blurPass.initialize(e, t, i), t || i !== THREE.UnsignedByteType || (this.renderTarget.texture.format = THREE.RGBFormat), void 0 !== i && (this.renderTarget.texture.type = i);
    }
  }, shader_default48 = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}", BrightnessContrastEffect = class extends Effect {
    constructor({
      blendFunction: e = BlendFunction.NORMAL,
      brightness: t = 0,
      contrast: i = 0
    } = {}) {
      super("BrightnessContrastEffect", shader_default48, {
        blendFunction: e,
        uniforms: /* @__PURE__ */ new Map([
          ["brightness", new THREE.Uniform(t)],
          ["contrast", new THREE.Uniform(i)]
        ])
      });
    }
  }, shader_default49 = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float sum=inputColor.r+inputColor.g+inputColor.b;outputColor=vec4(vec3(sum/3.0),inputColor.a);}", ColorAverageEffect = class extends Effect {
    constructor(e = BlendFunction.NORMAL) {
      super("ColorAverageEffect", shader_default49, { blendFunction: e });
    }
  }, shader_default51 = "varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 color=inputColor;\n#ifdef ALPHA\nvec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;color.r=ra.x;color.b=ba.x;color.a=max(max(ra.y,ba.y),inputColor.a);\n#else\ncolor.r=texture2D(inputBuffer,vUvR).r;color.b=texture2D(inputBuffer,vUvB).b;\n#endif\noutputColor=color;}", shader_default52 = "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vUvR=uv+offset;vUvB=uv-offset;}", ChromaticAberrationEffect = class extends Effect {
    constructor({
      blendFunction: e = BlendFunction.NORMAL,
      offset: t = new THREE.Vector2(1e-3, 5e-4)
    } = {}) {
      super("ChromaticAberrationEffect", shader_default51, {
        vertexShader: shader_default52,
        blendFunction: e,
        attributes: EffectAttribute.CONVOLUTION,
        uniforms: /* @__PURE__ */ new Map([["offset", new THREE.Uniform(t)]])
      });
    }
    get offset() {
      return this.uniforms.get("offset").value;
    }
    set offset(e) {
      this.uniforms.get("offset").value = e;
    }
    initialize(e, t, i) {
      t ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA");
    }
  }, shader_default54 = "uniform sampler2D nearColorBuffer;uniform sampler2D farColorBuffer;uniform sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}", DepthOfFieldEffect = class extends Effect {
    constructor(e, {
      blendFunction: t = BlendFunction.NORMAL,
      focusDistance: i = 0,
      focalLength: r = 0.1,
      bokehScale: n = 1,
      width: o = Resizer.AUTO_SIZE,
      height: a = Resizer.AUTO_SIZE
    } = {}) {
      super("DepthOfFieldEffect", shader_default54, {
        blendFunction: t,
        attributes: EffectAttribute.DEPTH,
        uniforms: /* @__PURE__ */ new Map([
          ["nearColorBuffer", new THREE.Uniform(null)],
          ["farColorBuffer", new THREE.Uniform(null)],
          ["nearCoCBuffer", new THREE.Uniform(null)],
          ["scale", new THREE.Uniform(1)]
        ])
      }), this.camera = e, this.renderTarget = new THREE.WebGLRenderTarget(1, 1, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        stencilBuffer: false,
        depthBuffer: false
      }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTarget.texture.generateMipmaps = false, this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get(
        "nearColorBuffer"
      ).value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get(
        "farColorBuffer"
      ).value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.format = THREE.RGBFormat, this.renderTargetCoC.texture.name = "DoF.CoC", this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get(
        "nearCoCBuffer"
      ).value = this.renderTargetCoCBlurred.texture, this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(e));
      const s = this.circleOfConfusionMaterial;
      s.uniforms.focusDistance.value = i, s.uniforms.focalLength.value = r, this.blurPass = new BlurPass({
        width: o,
        height: a,
        kernelSize: KernelSize.MEDIUM
      }), this.blurPass.resolution.resizable = this, this.maskPass = new ShaderPass(
        new MaskMaterial(this.renderTargetCoC.texture)
      );
      const l = this.maskPass.getFullscreenMaterial();
      l.maskFunction = MaskFunction.MULTIPLY_RGB_SET_ALPHA, l.colorChannel = ColorChannel.GREEN, this.bokehNearBasePass = new ShaderPass(new BokehMaterial(false, true)), this.bokehNearFillPass = new ShaderPass(new BokehMaterial(true, true)), this.bokehFarBasePass = new ShaderPass(new BokehMaterial(false, false)), this.bokehFarFillPass = new ShaderPass(new BokehMaterial(true, false)), this.bokehScale = n, this.target = null;
    }
    get circleOfConfusionMaterial() {
      return this.cocPass.getFullscreenMaterial();
    }
    get resolution() {
      return this.blurPass.resolution;
    }
    get bokehScale() {
      return this.uniforms.get("scale").value;
    }
    set bokehScale(e) {
      [
        this.bokehNearBasePass,
        this.bokehNearFillPass,
        this.bokehFarBasePass,
        this.bokehFarFillPass
      ].map((e2) => e2.getFullscreenMaterial().uniforms.scale).forEach((t) => {
        t.value = e;
      }), this.maskPass.getFullscreenMaterial().uniforms.strength.value = e, this.uniforms.get("scale").value = e;
    }
    calculateFocusDistance(e) {
      const t = this.camera, i = t.far - t.near, r = t.position.distanceTo(e);
      return Math.min(Math.max(r / i, 0), 1);
    }
    setDepthTexture(e, t = THREE.BasicDepthPacking) {
      const i = this.circleOfConfusionMaterial;
      i.uniforms.depthBuffer.value = e, i.depthPacking = t;
    }
    update(e, t, i) {
      const r = this.renderTarget, n = this.renderTargetCoC, o = this.renderTargetCoCBlurred, a = this.renderTargetMasked, s = this.bokehFarBasePass, l = this.bokehFarFillPass, c = s.getFullscreenMaterial().uniforms, u = l.getFullscreenMaterial().uniforms, h = this.bokehNearBasePass, d = this.bokehNearFillPass, f = h.getFullscreenMaterial().uniforms, p = d.getFullscreenMaterial().uniforms;
      if (null !== this.target) {
        const e2 = this.calculateFocusDistance(this.target);
        this.circleOfConfusionMaterial.uniforms.focusDistance.value = e2;
      }
      this.cocPass.render(e, null, n), this.blurPass.render(e, n, o), this.maskPass.render(e, t, a), c.cocBuffer.value = u.cocBuffer.value = n.texture, s.render(e, a, r), l.render(e, r, this.renderTargetFar), f.cocBuffer.value = p.cocBuffer.value = o.texture, h.render(e, t, r), d.render(e, r, this.renderTargetNear);
    }
    setSize(e, t) {
      const i = this.resolution;
      let r = [
        this.cocPass,
        this.blurPass,
        this.maskPass,
        this.bokehNearBasePass,
        this.bokehNearFillPass,
        this.bokehFarBasePass,
        this.bokehFarFillPass
      ];
      r.push(this.renderTargetCoC, this.renderTargetMasked), r.forEach((i2) => i2.setSize(e, t));
      const n = i.width, o = i.height;
      r = [
        this.renderTarget,
        this.renderTargetNear,
        this.renderTargetFar,
        this.renderTargetCoCBlurred
      ], r.forEach((e2) => e2.setSize(n, o));
      [
        this.bokehNearBasePass,
        this.bokehNearFillPass,
        this.bokehFarBasePass,
        this.bokehFarFillPass
      ].forEach((e2) => e2.getFullscreenMaterial().setTexelSize(1 / n, 1 / o));
    }
    initialize(e, t, i) {
      [
        this.cocPass,
        this.maskPass,
        this.bokehNearBasePass,
        this.bokehNearFillPass,
        this.bokehFarBasePass,
        this.bokehFarFillPass
      ].forEach((r) => r.initialize(e, t, i)), this.blurPass.initialize(e, t, THREE.UnsignedByteType), t || i !== THREE.UnsignedByteType || (this.renderTargetNear.texture.type = THREE.RGBFormat), void 0 !== i && (this.renderTarget.texture.type = i, this.renderTargetNear.texture.type = i, this.renderTargetFar.texture.type = i, this.renderTargetMasked.texture.type = i);
    }
  };
  new THREE.Vector3();
  new THREE.Matrix4();
  var shader_default60 = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", HueSaturationEffect = class extends Effect {
    constructor({
      blendFunction: e = BlendFunction.NORMAL,
      hue: t = 0,
      saturation: i = 0
    } = {}) {
      super("HueSaturationEffect", shader_default60, {
        blendFunction: e,
        uniforms: /* @__PURE__ */ new Map([
          ["hue", new THREE.Uniform(new THREE.Vector3())],
          ["saturation", new THREE.Uniform(i)]
        ])
      }), this.setHue(t);
    }
    setHue(e) {
      const t = Math.sin(e), i = Math.cos(e);
      this.uniforms.get("hue").value.set(2 * i, -Math.sqrt(3) * t - i, Math.sqrt(3) * t - i).addScalar(1).divideScalar(3);
    }
  };
  new THREE.Color();
  var shader_default62 = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}", NoiseEffect = class extends Effect {
    constructor({
      blendFunction: e = BlendFunction.SCREEN,
      premultiply: t = false
    } = {}) {
      super("NoiseEffect", shader_default62, { blendFunction: e }), this.premultiply = t;
    }
    get premultiply() {
      return this.defines.has("PREMULTIPLY");
    }
    set premultiply(e) {
      this.premultiply !== e && (e ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged());
    }
  }, shader_default65 = "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}", PixelationEffect = class extends Effect {
    constructor(e = 30) {
      super("PixelationEffect", shader_default65, {
        uniforms: /* @__PURE__ */ new Map([
          ["active", new THREE.Uniform(false)],
          ["d", new THREE.Uniform(new THREE.Vector2())]
        ])
      }), this.resolution = new THREE.Vector2(), this.granularity = e;
    }
    getGranularity() {
      return this.granularity;
    }
    setGranularity(e) {
      (e = Math.floor(e)) % 2 > 0 && (e += 1);
      const t = this.uniforms;
      t.get("active").value = e > 0, t.get("d").value.set(e, e).divide(this.resolution), this.granularity = e;
    }
    setSize(e, t) {
      this.resolution.set(e, t), this.setGranularity(this.granularity);
    }
  };
  new THREE.Vector3();
  new THREE.Vector3();
  var searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC", areaImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC", shader_default71 = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", shader_default72 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}", SMAAEffect = class extends Effect {
    constructor(e, t, i = SMAAPreset.HIGH, r = EdgeDetectionMode.COLOR) {
      super("SMAAEffect", shader_default71, {
        vertexShader: shader_default72,
        blendFunction: BlendFunction.NORMAL,
        attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH,
        uniforms: /* @__PURE__ */ new Map([["weightMap", new THREE.Uniform(null)]])
      }), this.renderTargetEdges = new THREE.WebGLRenderTarget(1, 1, {
        minFilter: THREE.LinearFilter,
        stencilBuffer: false,
        depthBuffer: false,
        format: THREE.RGBFormat
      }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.renderTargetWeights.texture.format = THREE.RGBAFormat, this.uniforms.get(
        "weightMap"
      ).value = this.renderTargetWeights.texture, this.clearPass = new ClearPass(true, false, false), this.clearPass.overrideClearColor = new THREE.Color(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new ShaderPass(
        new EdgeDetectionMaterial(new THREE.Vector2(), r)
      ), this.weightsPass = new ShaderPass(new SMAAWeightsMaterial());
      const n = new THREE.Texture(e);
      n.name = "SMAA.Search", n.magFilter = THREE.NearestFilter, n.minFilter = THREE.NearestFilter, n.format = THREE.RGBAFormat, n.generateMipmaps = false, n.needsUpdate = true, n.flipY = true;
      const o = new THREE.Texture(t);
      o.name = "SMAA.Area", o.minFilter = THREE.LinearFilter, o.format = THREE.RGBAFormat, o.generateMipmaps = false, o.needsUpdate = true, o.flipY = false;
      const a = this.weightsPass.getFullscreenMaterial();
      a.uniforms.searchTexture.value = n, a.uniforms.areaTexture.value = o, this.applyPreset(i);
    }
    get edgeDetectionMaterial() {
      return this.edgeDetectionPass.getFullscreenMaterial();
    }
    get colorEdgesMaterial() {
      return this.edgeDetectionMaterial;
    }
    get weightsMaterial() {
      return this.weightsPass.getFullscreenMaterial();
    }
    setEdgeDetectionThreshold(e) {
      this.edgeDetectionPass.getFullscreenMaterial().setEdgeDetectionThreshold(e);
    }
    setOrthogonalSearchSteps(e) {
      this.weightsPass.getFullscreenMaterial().setOrthogonalSearchSteps(e);
    }
    applyPreset(e) {
      const t = this.edgeDetectionMaterial, i = this.weightsMaterial;
      switch (e) {
        case SMAAPreset.LOW:
          t.setEdgeDetectionThreshold(0.15), i.setOrthogonalSearchSteps(4), i.diagonalDetection = false, i.cornerRounding = false;
          break;
        case SMAAPreset.MEDIUM:
          t.setEdgeDetectionThreshold(0.1), i.setOrthogonalSearchSteps(8), i.diagonalDetection = false, i.cornerRounding = false;
          break;
        case SMAAPreset.HIGH:
          t.setEdgeDetectionThreshold(0.1), i.setOrthogonalSearchSteps(16), i.setDiagonalSearchSteps(8), i.setCornerRounding(25), i.diagonalDetection = true, i.cornerRounding = true;
          break;
        case SMAAPreset.ULTRA:
          t.setEdgeDetectionThreshold(0.05), i.setOrthogonalSearchSteps(32), i.setDiagonalSearchSteps(16), i.setCornerRounding(25), i.diagonalDetection = true, i.cornerRounding = true;
      }
    }
    setDepthTexture(e, t = THREE.BasicDepthPacking) {
      const i = this.edgeDetectionMaterial;
      i.uniforms.depthBuffer.value = e, i.depthPacking = t;
    }
    update(e, t, i) {
      this.clearPass.render(e, this.renderTargetEdges), this.edgeDetectionPass.render(e, t, this.renderTargetEdges), this.weightsPass.render(
        e,
        this.renderTargetEdges,
        this.renderTargetWeights
      );
    }
    setSize(e, t) {
      const i = this.edgeDetectionPass.getFullscreenMaterial(), r = this.weightsPass.getFullscreenMaterial();
      this.renderTargetEdges.setSize(e, t), this.renderTargetWeights.setSize(e, t), r.uniforms.resolution.value.set(e, t), r.uniforms.texelSize.value.set(1 / e, 1 / t), i.uniforms.texelSize.value.copy(r.uniforms.texelSize.value);
    }
    dispose() {
      const e = this.weightsPass.getFullscreenMaterial().uniforms;
      e.searchTexture.value.dispose(), e.areaTexture.value.dispose(), super.dispose();
    }
    static get searchImageDataURL() {
      return searchImageDataURL_default;
    }
    static get areaImageDataURL() {
      return areaImageDataURL_default;
    }
  }, SMAAPreset = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 }, shader_default77 = "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#ifdef ESKIL\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#else\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#endif\noutputColor=vec4(color,inputColor.a);}", VignetteEffect = class extends Effect {
    constructor(e = {}) {
      const t = Object.assign(
        {
          blendFunction: BlendFunction.NORMAL,
          eskil: false,
          offset: 0.5,
          darkness: 0.5
        },
        e
      );
      super("VignetteEffect", shader_default77, {
        blendFunction: t.blendFunction,
        uniforms: /* @__PURE__ */ new Map([
          ["offset", new THREE.Uniform(t.offset)],
          ["darkness", new THREE.Uniform(t.darkness)]
        ])
      }), this.eskil = t.eskil;
    }
    get eskil() {
      return this.defines.has("ESKIL");
    }
    set eskil(e) {
      this.eskil !== e && (e ? this.defines.set("ESKIL", "1") : this.defines.delete("ESKIL"), this.setChanged());
    }
  }, SMAAImageLoader = class extends THREE.Loader {
    load(e = () => {
    }, t = null) {
      4 === arguments.length ? (e = arguments[1], t = arguments[3]) : 3 !== arguments.length && "function" == typeof arguments[0] || (e = arguments[1], t = null);
      const i = this.manager, r = new THREE.LoadingManager();
      return new Promise((n, o) => {
        const a = new Image(), s = new Image();
        r.onError = (e2) => {
          i.itemError(e2), null !== t ? (t(`Failed to load ${e2}`), n()) : o(`Failed to load ${e2}`);
        }, r.onLoad = () => {
          const t2 = [a, s];
          e(t2), n(t2);
        }, a.addEventListener("error", (e2) => {
          r.itemError("smaa-search");
        }), s.addEventListener("error", (e2) => {
          r.itemError("smaa-area");
        }), a.addEventListener("load", () => {
          i.itemEnd("smaa-search"), r.itemEnd("smaa-search");
        }), s.addEventListener("load", () => {
          i.itemEnd("smaa-area"), r.itemEnd("smaa-area");
        }), i.itemStart("smaa-search"), i.itemStart("smaa-area"), r.itemStart("smaa-search"), r.itemStart("smaa-area"), a.src = searchImageDataURL_default, s.src = areaImageDataURL_default;
      });
    }
  }, TinyState = function() {
    function e() {
      this.subscriptions = [];
    }
    return e.prototype.subscribe = function(e2) {
      var t = this;
      return this.subscriptions.push(e2), function() {
        return t.unsubscribe(e2);
      };
    }, e.prototype.unsubscribe = function(e2) {
      this.subscriptions = this.subscriptions.filter(function(t) {
        return t !== e2;
      });
    }, e.prototype.onChange = function() {
      var e2 = this;
      this.subscriptions.forEach(function(t) {
        "function" == typeof t && t(e2);
      });
    }, e.prototype.setState = function(e2) {
      var t = this;
      Object.keys(e2).forEach(function(i) {
        t[i] = e2[i];
      }), this.onChange();
    }, e;
  }(), Effect$1 = function(e) {
    function t(t2, i) {
      var r = e.call(this) || this;
      return r.enabled = false, r.effect = new t2(i), Object.defineProperty(r, "opacity", {
        enumerable: true,
        set: function(e2) {
          this.effect.blendMode.opacity.value = e2;
        },
        get: function() {
          return this.effect.blendMode.opacity.value;
        }
      }), Object.defineProperty(r, "blendFunction", {
        enumerable: true,
        set: function(e2) {
          this.effect.blendMode.setBlendFunction(Number(e2));
        },
        get: function() {
          return this.effect.blendMode.blendFunction;
        }
      }), r.blendFunction = BlendFunction.NORMAL, r;
    }
    return __extends(t, e), t.prototype.toJSON = function() {
      var e2, t2, i = __assign({}, this), r = Object.getPrototypeOf(this), n = Object.getOwnPropertyNames(r);
      try {
        for (var o = __values(n), a = o.next(); !a.done; a = o.next()) {
          var s = a.value, l = Object.getOwnPropertyDescriptor(r, s);
          l && "function" == typeof l.get && (i[s] = this[s]);
        }
      } catch (t3) {
        e2 = { error: t3 };
      } finally {
        try {
          a && !a.done && (t2 = o.return) && t2.call(o);
        } finally {
          if (e2) throw e2.error;
        }
      }
      return ["constructor", "effect", "subscriptions"].forEach(function(e3) {
        return delete i[e3];
      }), i;
    }, t.prototype.fromJSON = function(e2) {
      this.setState(e2);
    }, t;
  }(TinyState), Bloom = function(e) {
    function t() {
      var t2 = e.call(this, BloomEffect) || this;
      return t2.blendFunction = BlendFunction.SCREEN, t2;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "intensity", {
      get: function() {
        return this.effect.intensity;
      },
      set: function(e2) {
        this.effect.intensity = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "luminanceThreshold", {
      get: function() {
        return this.effect.luminanceMaterial.threshold;
      },
      set: function(e2) {
        this.effect.luminanceMaterial.threshold = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "luminanceSmoothing", {
      get: function() {
        return this.effect.luminanceMaterial.smoothing;
      },
      set: function(e2) {
        this.effect.luminanceMaterial.smoothing = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "blurScale", {
      get: function() {
        return this.effect.blurPass.scale;
      },
      set: function(e2) {
        this.effect.blurPass.scale = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "kernelSize", {
      get: function() {
        return this.effect.blurPass.kernelSize;
      },
      set: function(e2) {
        this.effect.blurPass.kernelSize = e2;
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Effect$1), BrightnessContrast = function(e) {
    function t() {
      return e.call(this, BrightnessContrastEffect) || this;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "contrast", {
      get: function() {
        return this.effect.uniforms.get("contrast").value;
      },
      set: function(e2) {
        this.effect.uniforms.get("contrast").value = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "brightness", {
      get: function() {
        return this.effect.uniforms.get("brightness").value;
      },
      set: function(e2) {
        this.effect.uniforms.get("brightness").value = e2;
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Effect$1), ChromaticAberration = function(e) {
    function t() {
      var t2 = e.call(this, ChromaticAberrationEffect) || this;
      return t2.effect.offset = new THREE.Vector2(0.01, 0.01), t2;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "offset", {
      get: function() {
        return [1e3 * this.effect.offset.x, 1e3 * this.effect.offset.y];
      },
      set: function(e2) {
        this.effect.offset.set(e2[0] / 1e3, e2[1] / 1e3);
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Effect$1), ColorAverage = function(e) {
    function t() {
      return e.call(this, ColorAverageEffect) || this;
    }
    return __extends(t, e), t;
  }(Effect$1), HueSaturation = function(e) {
    function t() {
      var t2 = e.call(this, HueSaturationEffect) || this;
      return t2._hue = 0, t2;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "hue", {
      get: function() {
        return this._hue;
      },
      set: function(e2) {
        this._hue = e2, this.effect.setHue(e2);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "saturation", {
      get: function() {
        return this.effect.uniforms.get("saturation").value;
      },
      set: function(e2) {
        this.effect.uniforms.get("saturation").value = e2;
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Effect$1), Noise = function(e) {
    function t() {
      var t2 = e.call(this, NoiseEffect) || this;
      return t2.blendFunction = BlendFunction.OVERLAY, t2;
    }
    return __extends(t, e), t;
  }(Effect$1), Vignette = function(e) {
    function t() {
      return e.call(this, VignetteEffect) || this;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "eskil", {
      get: function() {
        return this.effect.eskil;
      },
      set: function(e2) {
        this.effect.eskil = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "darkness", {
      get: function() {
        return this.effect.uniforms.get("darkness").value;
      },
      set: function(e2) {
        this.effect.uniforms.get("darkness").value = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "offset", {
      get: function() {
        return this.effect.uniforms.get("offset").value;
      },
      set: function(e2) {
        this.effect.uniforms.get("offset").value = e2;
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Effect$1), Bloom$1 = function(e) {
    function t(t2) {
      return e.call(this, DepthOfFieldEffect, t2) || this;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "focalLength", {
      get: function() {
        return this.effect.circleOfConfusionMaterial.uniforms.focalLength.value;
      },
      set: function(e2) {
        this.effect.circleOfConfusionMaterial.uniforms.focalLength.value = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "focusDistance", {
      get: function() {
        return this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value;
      },
      set: function(e2) {
        this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value = e2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "bokehScale", {
      get: function() {
        return this.effect.bokehScale;
      },
      set: function(e2) {
        this.effect.bokehScale = e2;
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Effect$1), Vignette$1 = function(e) {
    function t() {
      return e.call(this, PixelationEffect) || this;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "granularity", {
      get: function() {
        return this.effect.getGranularity();
      },
      set: function(e2) {
        this.effect.setGranularity(e2);
      },
      enumerable: false,
      configurable: true
    }), t;
  }(Effect$1);
  function removeDisabledLayers(e, t) {
    return t && t.enabled && e.push(t.effect), e;
  }
  var Post = function(e) {
    function t() {
      var t2 = e.call(this) || this;
      return t2.effects = /* @__PURE__ */ new Map(), t2.loadingManager = new THREE.LoadingManager(), t2.smaaImageLoader = new SMAAImageLoader(t2.loadingManager), t2.renderPass = new RenderPass(), t2.depthPass = new DepthPass(), t2.clock = new THREE.Clock(), t2.enabled = false, t2.debug = false, t2.effects.set("bloom", new Bloom()), t2.effects.set("chromaticAberration", new ChromaticAberration()), t2.effects.set("vignette", new Vignette()), t2.effects.set("noise", new Noise()), t2.effects.set("colorAverage", new ColorAverage()), t2.effects.set("hueSaturation", new HueSaturation()), t2.effects.set("brightnessContrast", new BrightnessContrast()), t2.effects.set("depthOfField", new Bloom$1()), t2.effects.set("pixelation", new Vignette$1()), t2;
    }
    return __extends(t, e), t.prototype.reinit = function() {
      if (this.effectComposer = new EffectComposer(this.renderer), this.renderPass = new RenderPass(this.scene, this.camera), this.enabled) {
        var e2 = new SMAAEffect(
          this.search,
          this.area,
          SMAAPreset.ULTRA,
          EdgeDetectionMode.COLOR
        );
        e2.edgeDetectionMaterial.setPredicationMode(PredicationMode.DEPTH), e2.edgeDetectionMaterial.setEdgeDetectionThreshold(0.05), e2.edgeDetectionMaterial.setPredicationThreshold(2e-3), e2.edgeDetectionMaterial.setPredicationScale(1), this.depthPass = new DepthPass(this.scene, this.camera), this.effectComposer.addPass(this.renderPass), this.effectComposer.addPass(this.depthPass), this.effectComposer.addPass(new EffectPass(this.camera, e2));
        var t2 = [
          this.effects.get("chromaticAberration"),
          this.effects.get("bloom"),
          this.effects.get("colorAverage"),
          this.effects.get("hueSaturation"),
          this.effects.get("brightnessContrast"),
          this.effects.get("vignette"),
          this.effects.get("noise")
        ].reduce(removeDisabledLayers, []), i = [this.effects.get("pixelation")].reduce(
          removeDisabledLayers,
          []
        );
        i.length > 0 && this.effectComposer.addPass(
          new (EffectPass.bind.apply(
            EffectPass,
            __spread([void 0, this.camera], i)
          ))()
        ), this.effectComposer.addPass(
          new (EffectPass.bind.apply(
            EffectPass,
            __spread([void 0, this.camera], t2)
          ))()
        );
      } else this.effectComposer.addPass(this.renderPass);
    }, t.prototype.init = function(e2) {
      var t2 = this, i = e2.renderer, r = e2.camera, n = e2.scene;
      this.renderer = i, this.scene = n, this.camera = r, this.smaaImageLoader.load(function(e3) {
        var i2 = __read(e3, 2), r2 = i2[0], n2 = i2[1];
        t2.search = r2, t2.area = n2, t2.reinit();
      });
    }, t.prototype.fromJSON = function(e2) {
      var t2 = this;
      e2 && (Object.keys(e2).forEach(function(i) {
        var r;
        null === (r = t2.effects.get(i)) || void 0 === r || r.fromJSON(e2[i]);
      }), this.setState({ enabled: e2.enabled }));
    }, t.prototype.toJSON = function() {
      var e2 = {};
      return this.effects.forEach(function(t2, i) {
        e2[i] = t2.toJSON();
      }, e2), __assign({ enabled: this.enabled }, e2);
    }, t.prototype.enable = function() {
      this.setState({ enabled: true });
    }, t.prototype.disable = function() {
      this.setState({ enabled: false });
    }, t.prototype.toggle = function() {
      this.enabled ? this.disable() : this.enable(), this.reinit();
    }, t.prototype.render = function() {
      var e2;
      null === (e2 = this.effectComposer) || void 0 === e2 || e2.render(this.clock.getDelta());
    }, t;
  }(TinyState), Scene = function(e) {
    function t() {
      var t2 = e.call(this) || this;
      return t2.objectType = "Scene", t2.alpha = 1, t2.backupFog = new THREE.Fog(16777215, 100, 1e3), t2.fogUseBGColor = false, t2.directionalLightState = true, t2.ambientLightState = true, t2.shadowsState = true, t2.wireframeState = false, t2.canvas = {
        mode: 1,
        fullScreen: true,
        size: { width: 512, height: 512 }
      }, t2._color = new THREE.Color(1644825), t2._enableFog = false, t2.name = "Untitled", t2;
    }
    return __extends(t, e), Object.defineProperty(t.prototype, "color", {
      get: function() {
        return this._color;
      },
      set: function(e2) {
        true === this.fogUseBGColor && this.backupFog.color.copy(e2), this._color.copy(e2);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(t.prototype, "enableFog", {
      get: function() {
        return null !== this.fog;
      },
      set: function(e2) {
        this.fog = true === e2 ? this.backupFog : null, this._enableFog = e2;
      },
      enumerable: false,
      configurable: true
    }), t.prototype.init = function(e2, t2) {
      this.camera = new CombinedCamera(e2, t2), this.camera.setDefault(), this.camera.orthoCamera.near = -5e4, this.camera.perspCamera.near = 50, this.camera.orthoCamera.far = 1e5, this.camera.perspCamera.far = 1e5, this.camera.updateProjectionMatrix(), this.camera.position.set(0, 0, this.camera.targetOffset), this.camera.lookAt(new THREE.Vector3(0, 0, -1)), this.add(this.camera), this.ambientLight = new THREE.HemisphereLight(
        13882323,
        8553090,
        0.75
      ), this.ambientLight.name = "Default Ambient Light", this.add(this.ambientLight), this.directionalLight = new THREE.DirectionalLight(
        16777215,
        0.75
      ), this.directionalLight.name = "Default Directional Light", this.directionalLight.position.set(85e4, 13e5, 1e6), this.activeCamera = this.camera, this.activeCamera.add(this.directionalLight), this.postprocessing = new Post();
    }, t.prototype.initFromObjectLoader = function(e2) {
      var t2 = this;
      return this.traverse(function(i) {
        i.uuid === e2.ambientLight ? t2.ambientLight = i : i.uuid === e2.directionalLight ? t2.directionalLight = i : (i.uuid === e2.activeCamera && (t2.activeCamera = i), i.uuid === e2.camera && (t2.camera = i, t2.camera.setDefault()));
      }), this;
    }, t.prototype.addDefaultChild = function() {
      var e2 = new Mesh2D(
        RectangleGeometry.create({
          parameters: { width: 320, height: 320 }
        }),
        new BasicMaterial({ color: 16777215 })
      );
      return e2.position.z = -1, this.add(e2), e2;
    }, t.prototype.raycast = function(e2) {
      var t2 = [], i = function(r) {
        var n, o;
        try {
          for (var a = __values(r.children), s = a.next(); !s.done; s = a.next()) {
            var l = s.value;
            isEntity$1(l) && !l.raycastLock && l.visible && ((isMeshEntity(l) || isHelperableEntity(l) && l.enableHelper) && e2.intersectObject(l, false, t2), i(l));
          }
        } catch (e3) {
          n = { error: e3 };
        } finally {
          try {
            s && !s.done && (o = a.return) && o.call(a);
          } finally {
            if (n) throw n.error;
          }
        }
      };
      return i(this), t2;
    }, t.prototype.raycastMesh = function(e2) {
      var t2 = [], i = function(r) {
        var n, o;
        try {
          for (var a = __values(r.children), s = a.next(); !s.done; s = a.next()) {
            var l = s.value;
            isEntity$1(l) && !l.raycastLock && l.visible && (isMeshEntity(l) && e2.intersectObject(l, false, t2), i(l));
          }
        } catch (e3) {
          n = { error: e3 };
        } finally {
          try {
            s && !s.done && (o = a.return) && o.call(a);
          } finally {
            if (n) throw n.error;
          }
        }
      };
      return i(this), t2;
    }, t.prototype.traverseEntity = function(e2) {
      var t2, i;
      try {
        for (var r = __values(this.children), n = r.next(); !n.done; n = r.next()) {
          var o = n.value;
          isEntity$1(o) && this.camera !== o && o.traverseEntity(e2);
        }
      } catch (e3) {
        t2 = { error: e3 };
      } finally {
        try {
          n && !n.done && (i = r.return) && i.call(r);
        } finally {
          if (t2) throw t2.error;
        }
      }
    }, t.prototype.toJSON = function(t2) {
      var i, r, n, o, a, s = e.prototype.toJSON.call(this, t2), l = s.object;
      return l.objectType = "Scene", l.activeCamera = null === (i = this.activeCamera) || void 0 === i ? void 0 : i.uuid, l.camera = null === (r = this.camera) || void 0 === r ? void 0 : r.uuid, l.directionalLight = null === (n = this.directionalLight) || void 0 === n ? void 0 : n.uuid, l.ambientLight = null === (o = this.ambientLight) || void 0 === o ? void 0 : o.uuid, l.color = this.color.toArray(), l.alpha = this.alpha, null !== this.background && "toJSON" in this.background && (l.background = this.background.toJSON(t2)), null !== this.environment && (l.environment = this.environment.toJSON(t2)), null !== this.fog && (l.fog = this.fog.toJSON()), true === this.enableFog && (l.enableFog = true), true === this.fogUseBGColor && (l.fogUseBGColor = true), true === this.directionalLightState && (l.directionalLightState = true), true === this.ambientLightState && (l.ambientLightState = true), true === this.wireframeState && (l.wireframeState = true), l.canvas = {
        mode: this.canvas.mode,
        size: {
          width: this.canvas.size.width,
          height: this.canvas.size.height
        }
      }, true === this.canvas.fullScreen && (l.canvas.fullScreen = true), l.postprocessing = null === (a = this.postprocessing) || void 0 === a ? void 0 : a.toJSON(), s;
    }, t.prototype.fromJSON = function(t2) {
      var i, r, n, o, a, s;
      return e.prototype.fromJSON.call(this, t2), this.postprocessing = new Post(), this.color.fromArray(t2.color), this.alpha = t2.alpha, void 0 !== t2.background && Number.isInteger(t2.background) && (t2.background = new THREE.Color(t2.background)), this.postprocessing.fromJSON(t2.postprocessing), void 0 !== t2.fog && ("Fog" === t2.fog.type ? this.backupFog = new THREE.Fog(
        t2.fog.color,
        t2.fog.near,
        t2.fog.far
      ) : "FogExp2" === t2.fog.type && (this.backupFog = new THREE.FogExp2(
        t2.fog.color,
        t2.fog.density
      ))), this.enableFog = null !== (i = t2.enableFog) && void 0 !== i && i, this.fogUseBGColor = null !== (r = t2.fogUseBGColor) && void 0 !== r && r, this.directionalLightState = null !== (n = t2.directionalLightState) && void 0 !== n && n, this.ambientLightState = null !== (o = t2.ambientLightState) && void 0 !== o && o, this.wireframeState = null !== (a = t2.wireframeState) && void 0 !== a && a, this.canvas.mode = t2.canvas.mode, this.canvas.fullScreen = null !== (s = t2.canvas.fullScreen) && void 0 !== s && s, this.canvas.size = {
        width: t2.canvas.size.width,
        height: t2.canvas.size.height
      }, this;
    }, t;
  }(Object3DMixin(THREE.Scene)), normal = new THREE.Vector3(0, 0, 1), worldNormal = new THREE.Vector3(), coplanarPoint = new THREE.Vector3(), normalMatrix = new THREE.Matrix3(), VectorObject = function(e) {
    function t(t2, i) {
      var r;
      void 0 === t2 && (t2 = VectorGeometry.create({})), void 0 === i && (i = new BasicMaterial({ side: THREE.DoubleSide }));
      var n = e.call(this, t2, i) || this;
      return n.recursiveSelection = false, n.objectType = "VectorObject", n.eventDispatcher = new THREE.EventDispatcher(), n._onShapeUpdate = function() {
        if (n.computeSingleBoundingBox(), n.geometry.computeBoundingSphere(), n.geometry.computeBoundingBox(), n.geometry instanceof VectorSurfaceGeometry) {
          if (n.geometry.updateFromShape()) {
            var e2 = n.geometry.drawCount, t3 = n.geometry.userData;
            n.updateGeometry(
              Object.assign(n.geometry.userData, {
                parameters: Object.assign(t3.parameters, {
                  surfaceMaxCount: e2 + 1e3
                })
              })
            );
          }
        } else n.updateGeometry({});
      }, n.castShadow = true, n.receiveShadow = true, n.forceComputeSize = true, n.shape = t2.userData.shape, null === (r = n.shape.eventDispatcher) || void 0 === r || r.addEventListener("update", n._onShapeUpdate), n;
    }
    return __extends(t, e), t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2);
      return i.object.objectType = "VectorObject", i;
    }, t.prototype.setHelperVisibility = function() {
    }, t.prototype.updateGeometry = function(t2) {
      if (e.prototype.updateGeometry.call(this, t2), "userData" in this.geometry) {
        var i = this.geometry.userData.parameters;
        this.eventDispatcher.dispatchEvent({
          type: "geometryUpdate",
          parameters: i
        });
      }
    }, t.prototype.updateWorldMatrix = function(t2, i) {
      e.prototype.updateWorldMatrix.call(this, t2, i), normalMatrix.getNormalMatrix(this.matrixWorld), worldNormal.copy(normal).applyMatrix3(normalMatrix).normalize(), this.getWorldPosition(coplanarPoint), this.shape.plane.setFromNormalAndCoplanarPoint(
        worldNormal,
        coplanarPoint
      );
    }, t.prototype.clone = function(e2) {
      var i = this.shape.clone(), r = this.material.clone(), n = this.geometry.userData, o = new t(
        VectorGeometry.create(Object.assign({}, n, { shape: i })),
        r
      ).copy(this, e2);
      return i.update(), o;
    }, t.prototype.raycast = function(e2, t2) {
      AbstractMesh.prototype.raycast.call(this, e2, t2);
    }, t;
  }(AbstractMesh), Char3D = function(e) {
    function t(i, r) {
      var n = i.char, o = i.originalChar, a = i.fontFamily, s = i.letterSpacing, l = i.fontSize, c = i.LOD, u = void 0 === c ? 16 : c;
      void 0 === r && (r = new THREE.MeshBasicMaterial({
        color: 0,
        opacity: 1,
        visible: true,
        transparent: true,
        side: THREE.DoubleSide
      }));
      var h = this, d = t.loadChar(n, a, u);
      return (h = e.call(this, d.geometry, r) || this).char = n, h.originalChar = null != o ? o : n, h.fontFamily = a, h.letterSpacing = s, h.fontSize = l, h.LOD = u, h.resolution = d.resolution, h.glyphsHa = d.glyphsHa, h.localPosition = new THREE.Vector2(), h.charSize = 0, h.geometry.userData = {
        type: "CharacterGeometry",
        parameters: {
          char: h.char,
          fontFamily: h.fontFamily,
          letterSpacing: h.letterSpacing,
          fontSize: h.fontSize,
          lod: h.LOD,
          resolution: h.resolution,
          charSize: h.charSize,
          localPosition: h.localPosition
        }
      }, h.updateFontSize(h.fontSize), h;
    }
    return __extends(t, e), Object.defineProperty(t, "FONTS_PATH", {
      get: function() {
        return "_assets/_fonts/";
      },
      enumerable: false,
      configurable: true
    }), t.prototype.updatePosition = function(e2, t2) {
      this.localPosition.copy(e2);
      var i = new THREE.Vector3(
        this.localPosition.x,
        -this.localPosition.y,
        0
      );
      this.position.copy(i).add(t2);
    }, t.prototype.updateFontSize = function(e2) {
      var t2 = e2 / this.resolution;
      this.fontSize = e2, this.scale.set(this.fontSize, this.fontSize, 1), this.charSize = this.glyphsHa * t2 * this.letterSpacing;
    }, t.prototype.updateFontFamily = function(e2) {
      if (this.fontFamily !== e2) {
        this.fontFamily = e2;
        var i = t.loadChar(this.char, e2, this.LOD);
        this.geometry = i.geometry, this.resolution = i.resolution, this.glyphsHa = i.glyphsHa, this.geometry.userData = {
          type: "CharacterGeometry",
          parameters: {
            char: this.char,
            fontFamily: this.fontFamily,
            letterSpacing: this.letterSpacing,
            fontSize: this.fontSize,
            lod: this.LOD,
            resolution: this.resolution,
            charSize: this.charSize,
            localPosition: this.localPosition
          }
        }, this.updateFontSize(this.fontSize);
      }
    }, t.prototype.updateChar = function(e2) {
      if (this.char !== e2) {
        this.char = e2;
        var i = t.loadChar(e2, this.fontFamily, this.LOD);
        this.geometry = i.geometry, this.resolution = i.resolution, this.glyphsHa = i.glyphsHa, this.geometry.userData = {
          type: "CharacterGeometry",
          parameters: {
            char: this.char,
            fontFamily: this.fontFamily,
            letterSpacing: this.letterSpacing,
            fontSize: this.fontSize,
            lod: this.LOD,
            resolution: this.resolution,
            charSize: this.charSize,
            localPosition: this.localPosition
          }
        }, this.updateFontSize(this.fontSize);
      }
    }, t.prototype.updateLetterSpacing = function(e2) {
      this.letterSpacing !== e2 && (this.letterSpacing = e2, this.updateFontSize(this.fontSize));
    }, t.prototype.updateLOD = function(e2) {
      if (this.LOD !== e2) {
        this.LOD = e2;
        var i = t.loadChar(this.char, this.fontFamily, this.LOD);
        this.geometry = i.geometry, this.resolution = i.resolution, this.glyphsHa = i.glyphsHa, this.geometry.userData = {
          type: "CharacterGeometry",
          parameters: {
            char: this.char,
            fontFamily: this.fontFamily,
            letterSpacing: this.letterSpacing,
            fontSize: this.fontSize,
            lod: this.LOD,
            resolution: this.resolution,
            charSize: this.charSize,
            localPosition: this.localPosition
          }
        }, this.updateFontSize(this.fontSize);
      }
    }, t.prototype.clone = function() {
      return new t({
        char: this.char,
        originalChar: this.originalChar,
        fontFamily: this.fontFamily,
        letterSpacing: this.letterSpacing,
        fontSize: this.fontSize,
        LOD: this.LOD
      }).copy(this);
    }, t.loadFont = function(e2) {
      return new Promise(function(i, r) {
        t.fontCache[e2] ? i(t.fontCache[e2]) : new THREE.FontLoader().load(
          t.FONTS_PATH + e2 + ".json",
          function(r2) {
            t.fontCache[e2] = r2, i(r2);
          },
          void 0,
          r
        );
      });
    }, t.loadChar = function(e2, i, r) {
      if (t.charCache[e2]) {
        if (t.charCache[e2][r] && t.charCache[e2][r].fontFamily === i)
          return t.charCache[e2][r];
      } else t.charCache[e2] = {};
      var n = t.fontCache[i], o = n.generateShapes(e2, 1);
      return t.charCache[e2][r] = {
        geometry: new THREE.ShapeBufferGeometry(o, r),
        fontFamily: i,
        resolution: n.data.resolution,
        glyphsHa: n.data.glyphs[e2].ha
      }, t.charCache[e2][r];
    }, t.charCache = {}, t.fontCache = {}, t;
  }(THREE.Mesh), DIACRITICS;
  !function(e) {
    e.ACUTE = "Â´", e.GRAVE = "`", e.CIRCUMFLEX = "^", e.DIAERESIS = "Â¨", e.TILDE = "~";
  }(DIACRITICS || (DIACRITICS = {}));
  Object.values(DIACRITICS);
  var TEXT_TRANSFORM, VERTICAL_ALIGN, HORIZONTAL_ALIGN, TRAVEL_DIRECTION;
  !function(e) {
    e[e.STANDARD = 1] = "STANDARD", e[e.UPPERCASE = 2] = "UPPERCASE", e[e.LOWERCASE = 3] = "LOWERCASE";
  }(TEXT_TRANSFORM || (TEXT_TRANSFORM = {})), function(e) {
    e[e.TOP = 1] = "TOP", e[e.MIDDLE = 2] = "MIDDLE", e[e.BOTTOM = 3] = "BOTTOM";
  }(VERTICAL_ALIGN || (VERTICAL_ALIGN = {})), function(e) {
    e[e.LEFT = 1] = "LEFT", e[e.RIGHT = 2] = "RIGHT", e[e.CENTER = 3] = "CENTER", e[e.JUSTIFY = 4] = "JUSTIFY";
  }(HORIZONTAL_ALIGN || (HORIZONTAL_ALIGN = {})), function(e) {
    e[e.TO_RIGHT = 1] = "TO_RIGHT", e[e.TO_LEFT = -1] = "TO_LEFT";
  }(TRAVEL_DIRECTION || (TRAVEL_DIRECTION = {}));
  var TEMPV2 = new THREE.Vector2(), TextLine = function() {
    function e(e2, t, i) {
      this.message = [], this.endLine = true, this.yLinePos = e2, this.lineHeight = t, this.maxCharSize = i, this.nextChar3DPos = new THREE.Vector2(
        0,
        this.yLinePos + this.maxCharSize * this.lineHeight
      ), this.align = HORIZONTAL_ALIGN.LEFT;
    }
    return e.prototype.addChar3D = function(e2, t, i) {
      void 0 === i && (i = this.message.length), this.message.splice(i, 0, e2), e2.fontSize > this.maxCharSize ? (this.maxCharSize = e2.fontSize, this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight, this.fullUpdate(t)) : (e2.updatePosition(this.nextChar3DPos, t), this.nextChar3DPos.x += e2.charSize);
    }, e.prototype.deleteChar3D = function(e2) {
      void 0 === e2 && (e2 = this.message.length - 1);
      var t = this.message[e2];
      return t ? (this.message.splice(e2, 1), this.nextChar3DPos.x -= t.charSize, t) : void 0;
    }, e.prototype.isEndLine = function(e2) {
      this.endLine = e2;
    }, e.prototype.fullUpdate = function(e2, t) {
      void 0 === t && (t = 0), this.nextChar3DPos.x = 0;
      for (var i = t, r = this.message.length; i < r; i += 1)
        this.message[i].updatePosition(this.nextChar3DPos, e2), this.nextChar3DPos.x += this.message[i].charSize;
    }, e.prototype.checkOverFlow = function(e2) {
      var t, i = this.message.length - 1;
      if (i <= 0) return false;
      for (; i >= 0; ) {
        if (" " !== this.message[i].char) {
          t = this.message[i];
          break;
        }
        i -= 1;
      }
      return !!(i >= 0 && t && t.localPosition.x + t.charSize > e2);
    }, e.prototype.containSpaceOverFlow = function(e2) {
      void 0 === e2 && (e2 = this.message.length - 1);
      for (var t = e2; t >= 0; t -= 1)
        if (" " === this.message[t].char) return true;
      return false;
    }, e.prototype.containSpace = function(e2) {
      if (void 0 === e2 && (e2 = this.message.length - 1), this.endLine)
        return true;
      for (var t = e2; t >= 0; t -= 1)
        if (" " === this.message[t].char) return true;
      return false;
    }, e.prototype.popWord = function(e2) {
      void 0 === e2 && (e2 = this.message.length - 1);
      var t, i = [], r = true;
      for (t = e2; t >= 0; t -= 1) {
        if (" " === this.message[t].char) {
          r = false, 0 === i.length && (t -= 1, i.splice(0, 0, this.message[t]));
          break;
        }
        i.splice(0, 0, this.message[t]);
      }
      return r ? i = [] : this.message.splice(t + 1, i.length), i;
    }, e.prototype.getWord = function(e2, t) {
      void 0 === e2 && (e2 = 0), void 0 === t && (t = 1);
      var i = [], r = e2;
      for (r = e2; ; r += t) {
        if (!this.message[r] || " " === this.message[r].char) {
          0 === i.length && this.message[r] && (i.push(this.message[r]), this.message.splice(r, 1));
          break;
        }
        t > 0 ? (i.push(this.message[r]), this.message.splice(r, 1), r -= t) : (i.splice(0, 0, this.message[r]), this.message.splice(r, 1));
      }
      return i;
    }, e.prototype.getWordAtIndex = function(e2) {
      for (var t = [], i = e2; i < this.message.length && " " !== this.message[i].char; i++)
        t.push(this.message[i]);
      for (i = e2 - 1; i >= 0 && " " !== this.message[i].char; i--)
        t.splice(0, 0, this.message[i]);
      return t;
    }, e.prototype.wordSize = function(e2, t) {
      void 0 === e2 && (e2 = 0), void 0 === t && (t = -1);
      for (var i = 0, r = e2; r >= 0 && r < this.message.length; ) {
        if (" " === this.message[r].char) {
          0 === i && (i = this.message[r].charSize);
          break;
        }
        i += this.message[r].charSize, r += t;
      }
      return (r < 0 || r >= this.message.length) && !this.endLine ? this.message[e2] ? this.message[e2].charSize : 999999999 : 0 === i ? 999999999 : i;
    }, e.prototype.spaceLeft = function(e2) {
      return e2 - this.nextChar3DPos.x;
    }, e.prototype.popChar = function(e2) {
      return void 0 === e2 && (e2 = this.message.length - 1), this.nextChar3DPos.x -= this.message[e2].charSize, this.message.splice(e2, 1);
    }, e.prototype.isEmpty = function() {
      return !this.message.length;
    }, e.prototype.updateNextCharPosY = function() {
      this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight;
    }, e.prototype.updateYLinePos = function(e2) {
      this.yLinePos = e2, this.updateNextCharPosY();
    }, e.prototype.updatelineHeight = function(e2) {
      this.lineHeight = e2, this.updateNextCharPosY();
    }, e.prototype.updateFontSize = function(e2, t, i) {
      void 0 === t && (t = 0), void 0 === i && (i = this.message.length - 1);
      for (var r = t; r <= i; r += 1) this.message[r].updateFontSize(e2);
      this.maxCharSize = e2, this.nextChar3DPos.y = this.yLinePos + this.maxCharSize * this.lineHeight;
    }, e.prototype.countSpaces = function() {
      for (var e2 = 0, t = 0; t < this.message.length; t++)
        " " === this.message[t].char && (e2 += 1);
      return e2;
    }, e.prototype.alignText = function(e2, t, i, r, n) {
      switch (i) {
        case HORIZONTAL_ALIGN.LEFT:
          this.leftAlign(e2, n);
          break;
        case HORIZONTAL_ALIGN.CENTER:
          this.centerAlign(this.spaceLeft(t), e2, n);
          break;
        case HORIZONTAL_ALIGN.RIGHT:
          this.rightAlign(this.spaceLeft(t), e2, n);
          break;
        case HORIZONTAL_ALIGN.JUSTIFY:
          this.justifyAlign(this.spaceLeft(t), e2, n);
      }
    }, e.prototype.offsetCharacters = function(e2, t, i) {
      TEMPV2.set(t, i);
      for (var r = this.message.length, n = 0; n < r; n++)
        this.message[n].updatePosition(
          this.message[n].localPosition.add(TEMPV2),
          e2
        );
    }, e.prototype.leftAlign = function(e2, t) {
      this.align = HORIZONTAL_ALIGN.LEFT, this.offsetCharacters(e2, 0, t);
    }, e.prototype.centerAlign = function(e2, t, i) {
      this.align = HORIZONTAL_ALIGN.CENTER, this.offsetCharacters(t, e2 / 2, i);
    }, e.prototype.rightAlign = function(e2, t, i) {
      this.align = HORIZONTAL_ALIGN.RIGHT, this.offsetCharacters(t, e2, i);
    }, e.prototype.justifyAlign = function(e2, t, i) {
      if (this.align = HORIZONTAL_ALIGN.JUSTIFY, this.endLine)
        this.offsetCharacters(t, 0, i);
      else {
        var r = this.countSpaces();
        if (0 !== r)
          for (var n = e2 / r, o = 0, a = 0; a < this.message.length; a++)
            " " === this.message[a].char && (o += n), TEMPV2.set(o, i), this.message[a].updatePosition(
              this.message[a].localPosition.add(TEMPV2),
              t
            );
        else this.offsetCharacters(t, 0, i);
      }
    }, e.prototype.clone = function() {
      var t = new e(this.yLinePos, this.lineHeight, this.maxCharSize);
      t.nextChar3DPos = this.nextChar3DPos.clone(), t.align = this.align, t.endLine = this.endLine;
      for (var i = 0; i < this.message.length; i++)
        t.message.push(this.message[i].clone());
      return t;
    }, e;
  }(), TextFrame = function(e) {
    function t(t2, i) {
      void 0 === i && (i = new BasicMaterial({
        color: 16777215,
        transparent: true,
        opacity: 1,
        visible: false,
        side: THREE.DoubleSide
      }));
      var r = e.call(this, t2, i) || this;
      return r.objectType = "TextFrame", r._geometryUserData = t2.userData, r.userData.textFrame = {
        hexColor: 6974058,
        opacity: 1,
        visible: true,
        fontSize: 16,
        lineHeight: 1.5,
        letterSpacing: 1,
        fontFamily: "roboto_regular",
        textTransform: TEXT_TRANSFORM.STANDARD,
        horizontalAlignment: 1,
        verticalAlignment: VERTICAL_ALIGN.TOP,
        LOD: 16,
        maxLineSize: r._geometryUserData.parameters.width,
        textOrigin: new THREE.Vector3(
          -0.5 * r._geometryUserData.parameters.width,
          0.5 * r._geometryUserData.parameters.height,
          0
        ),
        textLines: []
      }, r.createTextLine(), r;
    }
    return __extends(t, e), t.prototype.raycast = function(t2, i) {
      var r = [];
      if (e.prototype.raycast.call(this, t2, r), r.length > 0) i.push(r[0]);
      else
        for (var n = [], o = 0, a = this.children.length; o < a; ++o)
          if (this.children[o] instanceof Char3D && (t2.intersectObject(this.children[o], false, n), n.length > 0))
            return n[0].object = this, void i.push(n[0]);
    }, t.prototype.updateGeometry = function(t2) {
      var i, r, n = this.userData, o = this.geometry.userData, a = o.parameters.width, s = null === (i = t2.parameters) || void 0 === i ? void 0 : i.width, l = null === (r = t2.parameters) || void 0 === r ? void 0 : r.height, c = o.parameters.height, u = n.textFrame;
      e.prototype.updateGeometry.call(this, t2), u.maxLineSize = o.parameters.width, u.textOrigin.set(
        -0.5 * o.parameters.width,
        0.5 * o.parameters.height,
        0
      ), void 0 !== l && c !== l ? (this.checkOverFlow(), this.checkCapacity()) : void 0 !== s && (a < s ? this.checkCapacity() : a > s && this.checkOverFlow());
    }, t.prototype.checkOverFlow = function(e2) {
      void 0 === e2 && (e2 = 0);
      for (var t2 = this.userData, i = t2.textFrame.textOrigin, r = t2.textFrame.textLines, n = e2; n < r.length; n++) {
        r[n].updateYLinePos(this.getNewLinePosition(n)), r[n].fullUpdate(i);
        for (var o = []; r[n].checkOverFlow(t2.textFrame.maxLineSize); )
          r[n].containSpaceOverFlow() ? o.splice(
            0,
            0,
            r[n].getWord(
              r[n].message.length - 1,
              TRAVEL_DIRECTION.TO_LEFT
            )
          ) : o.splice(0, 0, r[n].popChar());
        if (o.length > 0) {
          void 0 === r[n + 1] && (r[n].isEndLine(false), this.createTextLine());
          for (var a = 0, s = 0; s < o.length; s += 1)
            for (var l = 0; l < o[s].length; l += 1)
              r[n + 1].addChar3D(o[s][l], i, a), a += 1;
          r[n + 1].fullUpdate(i);
        }
        r[n].fullUpdate(i);
      }
      this.textFullUpdate(e2);
    }, t.prototype.checkCapacity = function(e2) {
      void 0 === e2 && (e2 = 0);
      for (var t2 = this.userData, i = t2.textFrame.textOrigin, r = t2.textFrame.maxLineSize, n = t2.textFrame.textLines, o = e2; o < n.length; o += 1)
        if (n[o].updateYLinePos(this.getNewLinePosition(o)), n[o].fullUpdate(i), n[o - 1])
          for (; !n[o - 1].endLine; ) {
            var a = void 0, s = n[o - 1].spaceLeft(r);
            if (!(n[o].wordSize(0, TRAVEL_DIRECTION.TO_RIGHT) <= s)) {
              n[o].isEmpty() ? (n[o].endLine && n[o - 1].isEndLine(true), n.splice(o, 1), o -= 1) : (n[o].updateYLinePos(this.getNewLinePosition(o)), n[o].fullUpdate(i));
              break;
            }
            a = n[o].containSpace() ? n[o].getWord(0, TRAVEL_DIRECTION.TO_RIGHT) : n[o].popChar(0);
            for (var l = 0; l < a.length; l += 1)
              a[l] && n[o - 1].addChar3D(a[l], i);
          }
      this.textFullUpdate(e2);
    }, t.prototype.createTextLine = function(e2) {
      void 0 === e2 && (e2 = this.userData.textFrame.textLines.length);
      var t2 = this.userData.textFrame;
      t2.textLines.splice(
        e2,
        0,
        new TextLine(this.getNewLinePosition(e2), t2.lineHeight, t2.fontSize)
      );
    }, t.prototype.textFullUpdate = function(e2) {
      void 0 === e2 && (e2 = 0);
      for (var t2 = this.userData.textFrame, i = t2.textLines, r = this.getVerticalAlignmentOffSet(), n = e2; n < i.length; n++)
        i[n].updateYLinePos(this.getNewLinePosition(n)), i[n].fullUpdate(t2.textOrigin), i[n].alignText(
          t2.textOrigin,
          t2.maxLineSize,
          t2.horizontalAlignment,
          t2.verticalAlignment,
          r
        );
    }, t.prototype.getVerticalAlignmentOffSet = function() {
      switch (this.userData.textFrame.verticalAlignment) {
        case VERTICAL_ALIGN.TOP:
          return 0;
        case VERTICAL_ALIGN.MIDDLE:
          return this.getRemainingVerticalSpace() / 2;
        case VERTICAL_ALIGN.BOTTOM:
          return this.getRemainingVerticalSpace();
        default:
          return 0;
      }
    }, t.prototype.getRemainingVerticalSpace = function() {
      var e2 = this.userData.textFrame.textLines;
      return this.geometry.userData.parameters.height - this.getNewLinePosition(e2.length);
    }, t.prototype.getNewLinePosition = function(e2) {
      for (var t2 = this.userData.textFrame.textLines, i = 0, r = 0; r < e2; r += 1)
        i += t2[r].maxCharSize * t2[r].lineHeight;
      return i;
    }, t.prototype.updateColor = function(e2) {
      var t2 = this.userData;
      t2.textFrame.hexColor = e2;
      for (var i = t2.textFrame.textLines, r = 0; r < i.length; r++)
        for (var n = i[r].message, o = 0; o < n.length; o++) {
          n[o].material.color.setHex(e2);
        }
    }, t.prototype.updateOpacity = function(e2) {
      var t2 = this.userData;
      t2.textFrame.opacity = e2;
      for (var i = t2.textFrame.textLines, r = 0; r < i.length; r++)
        for (var n = i[r].message, o = 0; o < n.length; o++) {
          n[o].material.opacity = e2;
        }
    }, t.prototype.updateVisible = function(e2) {
      var t2 = this.userData;
      t2.textFrame.visible = e2;
      for (var i = t2.textFrame.textLines, r = 0; r < i.length; r++)
        for (var n = i[r].message, o = 0; o < n.length; o++) {
          n[o].material.visible = e2;
        }
    }, t.prototype.updateFontFamily = function(e2) {
      return __awaiter(this, void 0, void 0, function() {
        var t2, i, r, n, o, a;
        return __generator(this, function(s) {
          switch (s.label) {
            case 0:
              return [4, Char3D.loadFont(e2)];
            case 1:
              for (s.sent(), t2 = this.userData, i = t2.textFrame, r = i.textLines, i.fontFamily = e2, n = 0; n < r.length; n++)
                for (o = r[n].message, a = 0; a < o.length; a++)
                  o[a].updateFontFamily(e2);
              return this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity(), [2];
          }
        });
      });
    }, t.prototype.updateFontSize = function(e2) {
      var t2 = this.userData.textFrame, i = t2.textLines, r = t2.fontSize;
      t2.fontSize = e2;
      for (var n = 0; n < i.length; n++) i[n].updateFontSize(e2);
      this.textFullUpdate(), e2 > r ? this.checkOverFlow() : e2 < r && this.checkCapacity();
    }, t.prototype.updateTextTransform = function(e2) {
      return __awaiter(this, void 0, void 0, function() {
        var t2, i, r, n, o, a;
        return __generator(this, function(s) {
          switch (s.label) {
            case 0:
              return t2 = this.userData, i = t2.textFrame, [4, Char3D.loadFont(i.fontFamily)];
            case 1:
              switch (s.sent(), r = i.textLines, i.textTransform = e2, e2) {
                case TEXT_TRANSFORM.UPPERCASE:
                  for (n = 0; n < r.length; n++)
                    for (o = r[n].message, a = 0; a < o.length; a++)
                      r[n].message[a].updateChar(o[a].char.toUpperCase());
                  break;
                case TEXT_TRANSFORM.LOWERCASE:
                  for (n = 0; n < r.length; n++)
                    for (o = r[n].message, a = 0; a < o.length; a++)
                      r[n].message[a].updateChar(o[a].char.toLowerCase());
                  break;
                default:
                  for (n = 0; n < r.length; n++)
                    for (o = r[n].message, a = 0; a < o.length; a++)
                      r[n].message[a].updateChar(o[a].originalChar);
              }
              return this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity(), [2];
          }
        });
      });
    }, t.prototype.updateLetterSpacing = function(e2) {
      var t2 = this.userData, i = t2.textFrame.textLines;
      t2.textFrame.letterSpacing = e2;
      for (var r = 0; r < i.length; r++)
        for (var n = i[r].message, o = 0; o < n.length; o++)
          n[o].updateLetterSpacing(e2);
      this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
    }, t.prototype.updateLOD = function(e2) {
      var t2 = this.userData;
      t2.textFrame.LOD = e2;
      for (var i = t2.textFrame.textLines, r = 0; r < i.length; r++) ;
      this.textFullUpdate(), this.checkOverFlow(), this.checkCapacity();
    }, t.prototype.updateLineHeight = function(e2) {
      var t2 = this.userData, i = t2.textFrame.textLines;
      t2.textFrame.lineHeight = e2;
      for (var r = 0; r < i.length; r++) i[r].updatelineHeight(e2);
      this.textFullUpdate();
    }, t.prototype.updateVerticalAlignment = function(e2) {
      this.userData.textFrame.verticalAlignment = e2, this.textFullUpdate();
    }, t.prototype.updateHorizontalAlignment = function(e2) {
      this.userData.textFrame.horizontalAlignment = e2, this.textFullUpdate();
    }, t.prototype.copy = function(t2, i) {
      e.prototype.copy.call(this, t2, i);
      var r = this.userData, n = t2.userData, o = this.geometry.userData;
      r.textFrame.textOrigin = new THREE.Vector3(
        -0.5 * o.parameters.width,
        0.5 * o.parameters.height,
        0
      );
      var a = n.textFrame.textLines;
      r.textFrame.textLines = [];
      for (var s = 0; s < a.length; s++) {
        var l = a[s].clone(), c = l.message;
        r.textFrame.textLines.push(l);
        for (var u = 0; u < c.length; u++) this.add(c[u]);
      }
      return this.textFullUpdate(), this;
    }, t.prototype.toJSON = function(t2) {
      var i = e.prototype.toJSON.call(this, t2), r = i.object;
      r.objectType = "TextFrame";
      var n = this.userData.textFrame.textLines.map(function(e2) {
        var t3 = e2.message.map(function(e3) {
          return {
            char: e3.char,
            originalChar: e3.originalChar,
            fontFamily: e3.fontFamily,
            letterSpacing: e3.letterSpacing,
            fontSize: e3.fontSize,
            LOD: e3.LOD
          };
        });
        return {
          align: e2.align,
          endLine: e2.endLine,
          lineHeight: e2.lineHeight,
          maxCharSize: e2.maxCharSize,
          yLinePos: e2.yLinePos,
          message: t3
        };
      });
      return r.userData.textFrame.textLinesData = n, i;
    }, t.prototype.fromJSONasync = function(t2) {
      return __awaiter(this, void 0, void 0, function() {
        var i, r, n = this;
        return __generator(this, function(o) {
          switch (o.label) {
            case 0:
              return e.prototype.fromJSON.call(this, t2), void 0 === t2.userData ? [3, 2] : (i = t2.userData.textFrame, [4, Char3D.loadFont(i.fontFamily)]);
            case 1:
              o.sent(), i.textOrigin = new THREE.Vector3(
                i.textOrigin.x,
                i.textOrigin.y,
                i.textOrigin.z
              ), r = new THREE.MeshBasicMaterial({
                color: i.hexColor,
                opacity: i.opacity,
                visible: i.visible,
                transparent: true,
                side: THREE.DoubleSide
              }), i.textLinesData && (i.textLines = i.textLinesData.map(function(e2, t3) {
                var o2 = new TextLine(
                  Number(e2.yLinePos),
                  Number(e2.lineHeight),
                  Number(e2.maxCharSize)
                ), a = e2.message.map(function(e3, a2) {
                  if (void 0 === e3.char) {
                    var s = i.textLines[t3].message[a2];
                    if ("geometries" in s) {
                      var l = s.geometries[0].userData.parameters;
                      Object.assign(e3, {
                        LOD: l.lod,
                        char: l.char,
                        fontFamily: l.fontFamily,
                        fontSize: l.fontSize,
                        letterSpacing: l.letterSpacing,
                        originalChar: l.char
                      });
                    }
                  }
                  var c = {
                    char: e3.char,
                    fontFamily: e3.fontFamily,
                    letterSpacing: Number(e3.letterSpacing),
                    fontSize: Number(e3.fontSize),
                    LOD: e3.LOD
                  }, u = new Char3D(c, r.clone());
                  return o2.addChar3D(u, i.textOrigin), n.add(u), u;
                });
                return o2.message = a, o2;
              }), this.userData.textFrame = i), this.textFullUpdate(), o.label = 2;
            case 2:
              return [2, this];
          }
        });
      });
    }, t.VERTICAL_ALIGN = VERTICAL_ALIGN, t.HORIZONTAL_ALIGN = HORIZONTAL_ALIGN, t.TEXT_TRANSFORM = TEXT_TRANSFORM, t.TRAVEL_DIRECTION = TRAVEL_DIRECTION, t;
  }(AbstractMesh), IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], ATTRIBUTE_NAME_MAPPING = { TEXCOORD_0: "UV" }, DEFAULT_SAMPLER = {
    magFilter: GLTF_TEXTURE_MAG_FILTER.NEAREST,
    minFilter: GLTF_TEXTURE_MIN_FILTER.NEAREST,
    wrapS: GLTF_TEXTURE_WRAP_MODE.CLAMP_TO_EDGE,
    wrapT: GLTF_TEXTURE_WRAP_MODE.CLAMP_TO_EDGE
  }, DEFAULT_IMAGE = new Image(), DEFAULT_TEXTURE = new THREE.Texture(), DEFAULT_ARRAY_COLORS = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ], DEFAULT_STEPS = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1], DEFAULT_SHADOWMAP_SIZE = [2048, 2048], GLTFImporter = function() {
    function e() {
      this._scene = null, this._camera = null, this._exportOptions = null, this._sceneOptions = null, this._gltfFile = null, this._nodes = [], this._cameras = [], this._lights = [], this._meshes = [], this._accessors = [], this._materials = [], this._textures = [], this._texturesMap = {}, this._objects = {}, this._interactionStates = {};
    }
    return e.prototype.decode = function(e2) {
      var t, i;
      if (this._scene = null, this._camera = null, this._exportOptions = {}, this._sceneOptions = {}, this._nodes = [], this._objects = {}, this._cameras = [], this._lights = [], this._meshes = [], this._accessors = [], this._materials = [], this._gltfFile = e2, !this._gltfFile)
        return console.error("::decode >>> no gltf file was given"), [null, null, null, null];
      if (this._decodeTextureData(this._gltfFile), this._decodeInteractionStates(this._gltfFile), this._decodeVertexData(this._gltfFile), this._decodeExportOptions(this._gltfFile), this._decodeSceneOptions(this._gltfFile), this._decodeCameras(this._gltfFile), this._decodeLights(this._gltfFile), this._decodeMeshes(this._gltfFile), this._decodeMaterials(this._gltfFile), this._decodeNodes(this._gltfFile), this._decodeInteractions(this._gltfFile), this._decodeSceneGraph(this._gltfFile), this._gltfFile.scenes.length < 1)
        return console.error(
          "GLTFImporter::decode >>> there are no scenes in this\n                           gltf file, so we can't return a valid scene to the application"
        ), [null, null, null, null];
      this._gltfFile.scenes.length > 1 && console.warn(
        "GLTFImporter::decode >>> there are more than one default\n                          scene in the gltf file. Taking only the first one as default"
      );
      var r = this._gltfFile.scenes[0];
      r.nodes.length > 1 && console.warn(
        "GLTFImporter::decode >>> there are more root nodes in\n                          the default scene being decoded. Using first root instead"
      );
      var n = r.nodes[0];
      this._scene = this._nodes[n];
      var o = null !== (i = null === (t = this._gltfFile.extensions.SPE_scene_options.camera) || void 0 === t ? void 0 : t.mainCameraIndex) && void 0 !== i ? i : -1;
      return o < this._nodes.length && o >= 0 && (this._camera = this._nodes[o]), [this._scene, this._camera, this._exportOptions, this._sceneOptions];
    }, e.prototype._decodeTextureData = function(e2) {
      var t, i, r, n, o, a, s, l, c, u, h, d, f, p, v, m;
      function g(e3) {
        switch (e3) {
          case GLTF_TEXTURE_WRAP_MODE.CLAMP_TO_EDGE:
            return THREE.ClampToEdgeWrapping;
          case GLTF_TEXTURE_WRAP_MODE.MIRRORED_REPEAT:
            return THREE.MirroredRepeatWrapping;
          case GLTF_TEXTURE_WRAP_MODE.REPEAT:
            return THREE.RepeatWrapping;
        }
      }
      function E(e3) {
        switch (e3) {
          case GLTF_TEXTURE_MAG_FILTER.LINEAR:
            return THREE.LinearFilter;
          case GLTF_TEXTURE_MAG_FILTER.NEAREST:
            return THREE.NearestFilter;
        }
      }
      function y(e3) {
        switch (e3) {
          case GLTF_TEXTURE_MIN_FILTER.LINEAR:
            return THREE.LinearFilter;
          case GLTF_TEXTURE_MIN_FILTER.LINEAR_MIPMAP_LINEAR:
            return THREE.LinearMipmapLinearFilter;
          case GLTF_TEXTURE_MIN_FILTER.LINEAR_MIPMAP_NEAREST:
            return THREE.LinearMipmapNearestFilter;
          case GLTF_TEXTURE_MIN_FILTER.NEAREST:
            return THREE.NearestFilter;
          case GLTF_TEXTURE_MIN_FILTER.NEAREST_MIPMAP_LINEAR:
            return THREE.NearestMipmapLinearFilter;
          case GLTF_TEXTURE_MIN_FILTER.NEAREST_MIPMAP_NEAREST:
            return THREE.NearestMipmapNearestFilter;
        }
      }
      for (var A = null !== (t = e2.images) && void 0 !== t ? t : [], T = [], x = 0; x < A.length; x++) {
        (C = new Image()).src = null !== (i = A[x].uri) && void 0 !== i ? i : "", T.push(C);
      }
      var _ = null !== (r = e2.samplers) && void 0 !== r ? r : [], w = null !== (n = e2.textures) && void 0 !== n ? n : [];
      for (x = 0; x < w.length; x++) {
        var S = w[x], b = null !== (o = S.source) && void 0 !== o ? o : -1, R = null !== (a = S.sampler) && void 0 !== a ? a : -1, C = null !== (s = T[b]) && void 0 !== s ? s : DEFAULT_IMAGE, O = null !== (l = _[R]) && void 0 !== l ? l : DEFAULT_SAMPLER, D = null !== (u = null === (c = O.extensions) || void 0 === c ? void 0 : c.repeat) && void 0 !== u ? u : [1, 1], M = null !== (d = null === (h = O.extensions) || void 0 === h ? void 0 : h.offset) && void 0 !== d ? d : [0, 0], L = null !== (p = null === (f = O.extensions) || void 0 === f ? void 0 : f.center) && void 0 !== p ? p : [0, 0], I = null !== (m = null === (v = O.extensions) || void 0 === v ? void 0 : v.rotation) && void 0 !== m ? m : 0, P = new THREE.Texture(
          C,
          THREE.Texture.DEFAULT_MAPPING,
          g(O.wrapS),
          g(O.wrapT),
          E(O.magFilter),
          y(O.minFilter)
        );
        P.repeat.fromArray(D), P.offset.fromArray(M), P.center.fromArray(L), P.rotation = I, P.updateMatrix(), this._textures.push(P);
      }
      var B = e2.extensions.SPE_textures_uuid_map;
      for (var H in B) {
        var N = B[Number(H)];
        this._texturesMap[N] = this._textures[Number(H)];
      }
    }, e.prototype._decodeInteractionStates = function(e2) {
      var t = e2.extensions.SPE_interaction_states.states;
      for (var i in t) {
        var r = t[i];
        this._interactionStates[i] = new InteractionState().fromJSON(
          r,
          this._texturesMap
        );
      }
    }, e.prototype._decodeVertexData = function(e2) {
      for (var t, i, r, n = null !== (t = e2.buffers) && void 0 !== t ? t : [], o = [], a = 0; a < n.length; a++)
        o.push(this._decodeBuffer(n[a]));
      var s = null !== (i = e2.bufferViews) && void 0 !== i ? i : [], l = [];
      for (a = 0; a < s.length; a++) l.push(this._decodeBufferView(s[a], o));
      var c = null !== (r = e2.accessors) && void 0 !== r ? r : [];
      for (a = 0; a < c.length; a++)
        this._accessors.push(this._decodeAccessor(c[a], l));
    }, e.prototype._decodeBuffer = function(e2) {
      var t = e2.byteLength, i = e2.uri;
      if (i.indexOf("base64")) {
        for (var r = i.slice(i.indexOf("base64") + 7), n = atob(r), o = new Uint8Array(n.length), a = 0; a < n.length; a++)
          o[a] = n.charCodeAt(a);
        return { data: o, length: t };
      }
      return i.indexOf(".bin") ? (console.error(
        "GLTFImporter::_decodeBuffer >>> decoding from external binary file is not supported yet"
      ), { data: new Uint8Array(0), length: 0 }) : (console.error(
        "GLTFImporter::_decodeBuffer >>> invalid gltf-buffer description"
      ), { data: new Uint8Array(0), length: 0 });
    }, e.prototype._decodeBufferView = function(e2, t) {
      var i = e2.byteLength, r = e2.byteOffset, n = e2.buffer, o = e2.target;
      return n < 0 || n >= t.length ? (console.error(
        "GLTFImporter::_decodeBufferView >>> id of buffer out of range"
      ), {
        data: new Uint8Array(0),
        length: 0,
        target: GLTF_BUFFER_TARGET.ARRAY_BUFFER
      }) : { data: t[n].data.slice(r, r + i), length: i, target: o };
    }, e.prototype._decodeAccessor = function(e2, t) {
      var i = e2.bufferView, r = e2.byteOffset, n = e2.componentType, o = e2.count, a = e2.type;
      if (i < 0 || i >= t.length)
        return console.error(
          "GLTFImporter::_decodeAccessor >>> id of buffer-view out of range"
        ), {
          bufferData: new THREE.BufferAttribute([0], 0),
          itemSize: 0,
          componentSize: 0
        };
      var s, l = t[i], c = GetAccessorItemSize(a), u = GetAccessorComponentSize(n), h = o * c * u, d = l.data.slice(r, r + h);
      switch (n) {
        case GLTF_COMPONENT_TYPE.UNSIGNED_BYTE:
          s = new THREE.Uint8BufferAttribute(new Uint8Array(d.buffer), c);
          break;
        case GLTF_COMPONENT_TYPE.UNSIGNED_SHORT:
          s = new THREE.Uint16BufferAttribute(
            new Uint16Array(d.buffer),
            c
          );
          break;
        case GLTF_COMPONENT_TYPE.UNSIGNED_INT:
          s = new THREE.Uint32BufferAttribute(
            new Uint32Array(d.buffer),
            c
          );
          break;
        case GLTF_COMPONENT_TYPE.FLOAT:
          for (var f = d.length / Float32Array.BYTES_PER_ELEMENT, p = new Float32Array(f), v = new DataView(
            new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT)
          ), m = 0; m < p.length; m++)
            v.setUint8(0, d[4 * m + 0]), v.setUint8(1, d[4 * m + 1]), v.setUint8(2, d[4 * m + 2]), v.setUint8(3, d[4 * m + 3]), p[m] = v.getFloat32(0, true);
          s = new THREE.Float32BufferAttribute(p, c);
          break;
        default:
          console.error(
            "GLTFImporter::_decodeAccessor >>> invalid component-type (" + n + ")"
          ), s = new THREE.Uint8BufferAttribute(new Uint8Array(0), 0);
      }
      return { bufferData: s, itemSize: c, componentSize: u };
    }, e.prototype._decodeExportOptions = function(e2) {
      var t, i, r, n, o, a, s, l, c, u, h, d, f, p;
      if (this._exportOptions) {
        var v = e2.extensions.SPE_export_options;
        this._exportOptions.generatorFormat = null !== (t = v.generatorFormat) && void 0 !== t ? t : GLTF_GENERATOR_FORMAT.FORMAT_GLTF_SPLINE_EXT, this._exportOptions.useOrbitControls = null === (i = v.useOrbitControls) || void 0 === i || i, this._exportOptions.bgColor = new THREE.Color().fromArray(
          null !== (r = v.bgColor) && void 0 !== r ? r : [0.1, 0.1, 0.1]
        ), this._exportOptions.bgAlpha = null !== (n = v.bgAlpha) && void 0 !== n ? n : 0, this._exportOptions.orbitDamped = null !== (o = v.orbitDamped) && void 0 !== o && o, this._exportOptions.orbitTarget = new THREE.Vector3().fromArray(
          null !== (a = v.orbitTarget) && void 0 !== a ? a : [0, 0, 0]
        ), this._exportOptions.cameraType = null !== (s = v.cameraType) && void 0 !== s ? s : "OrthographicCamera", this._exportOptions.cameraRotate = null === (l = v.cameraRotate) || void 0 === l || l, this._exportOptions.cameraPan = null === (c = v.cameraPan) || void 0 === c || c, this._exportOptions.cameraZoom = null === (u = v.cameraZoom) || void 0 === u || u, this._exportOptions.viewMode = null !== (h = v.viewMode) && void 0 !== h ? h : RUNTIME_VIEWMODE.FULLSCREEN, this._exportOptions.viewWidth = null !== (d = v.viewWidth) && void 0 !== d ? d : window.innerWidth, this._exportOptions.viewHeight = null !== (f = v.viewHeight) && void 0 !== f ? f : window.innerHeight, this._exportOptions.quality = null !== (p = v.quality) && void 0 !== p ? p : RUNTIME_QUALITY.DEFAULT;
      }
    }, e.prototype._decodeSceneOptions = function(e2) {
      var t, i, r, n, o, a, s, l, c;
      if (this._sceneOptions) {
        var u = e2.extensions.SPE_scene_options;
        this._sceneOptions.camera = {
          mainCameraIndex: null !== (i = null === (t = u.camera) || void 0 === t ? void 0 : t.mainCameraIndex) && void 0 !== i ? i : -1
        }, u.fog && (this._sceneOptions.fog = {
          color: new THREE.Color().fromArray(
            null !== (r = u.fog.color) && void 0 !== r ? r : [0.1, 0.1, 0.1]
          ),
          near: null !== (n = u.fog.near) && void 0 !== n ? n : 1,
          far: null !== (o = u.fog.far) && void 0 !== o ? o : 1e3
        }), u.fogExp2 && (this._sceneOptions.fogExp2 = {
          color: new THREE.Color().fromArray(
            null !== (a = u.fogExp2.color) && void 0 !== a ? a : [0.1, 0.1, 0.1]
          ),
          density: null !== (s = u.fogExp2.density) && void 0 !== s ? s : 25e-5
        }), u.postProcessing && (this._sceneOptions.postProcessing = {
          enabled: null !== (l = u.postProcessing.enabled) && void 0 !== l && l,
          data: null !== (c = u.postProcessing.data) && void 0 !== c ? c : {}
        });
      }
    }, e.prototype._decodeCameras = function(e2) {
      var t = e2.cameras;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var r = t[i], n = this._decodeCamera(r);
          this._cameras.push(n);
        }
      else
        console.warn(
          "GLTFImporter::_decodeCameras >>> there are no cameras in the given gltf file"
        );
    }, e.prototype._decodeCamera = function(e2) {
      var t, i, r, n, o, a, s, l, c, u, h, d, f, p, v, m, g, E, y, A, T = null, x = 100, _ = 100, w = 45, S = 0.1, b = 5e4, R = 1;
      switch (e2.type) {
        case CAMERA_TYPE.ORTHOGRAPHIC:
          x = null !== (i = null === (t = e2.orthographic) || void 0 === t ? void 0 : t.xmag) && void 0 !== i ? i : 100, _ = null !== (n = null === (r = e2.orthographic) || void 0 === r ? void 0 : r.ymag) && void 0 !== n ? n : 100, S = null !== (a = null === (o = e2.orthographic) || void 0 === o ? void 0 : o.znear) && void 0 !== a ? a : 0.1, b = null !== (l = null === (s = e2.orthographic) || void 0 === s ? void 0 : s.zfar) && void 0 !== l ? l : 5e4, R = null !== (h = null === (u = null === (c = e2.extensions) || void 0 === c ? void 0 : c.SPE_camera_options) || void 0 === u ? void 0 : u.zoom) && void 0 !== h ? h : 1, (T = new CombinedCamera(x, _, w, S, b)).toOrthographic(), T.zoom = R;
          break;
        case CAMERA_TYPE.PERSPECTIVE:
          w = (null !== (f = null === (d = e2.perspective) || void 0 === d ? void 0 : d.yfov) && void 0 !== f ? f : Math.PI / 4) * THREE.MathUtils.RAD2DEG, S = null !== (v = null === (p = e2.perspective) || void 0 === p ? void 0 : p.znear) && void 0 !== v ? v : 0.1, b = null !== (g = null === (m = e2.perspective) || void 0 === m ? void 0 : m.zfar) && void 0 !== g ? g : 5e4, R = null !== (A = null === (y = null === (E = e2.extensions) || void 0 === E ? void 0 : E.SPE_camera_options) || void 0 === y ? void 0 : y.zoom) && void 0 !== A ? A : 1, (T = new CombinedCamera(x, _, w, S, b)).toPerspective(), T.zoom = R;
          break;
        default:
          console.error(
            "GLTFImporter::_decodeCamera >>> unsupported camera type (" + e2.type + ")"
          ), (T = new CombinedCamera(x, _, w, S, b)).toOrthographic(), T.zoom = R;
      }
      return T;
    }, e.prototype._decodeLights = function(e2) {
      var t = e2.extensions.KHR_lights_punctual.lights;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var r = t[i], n = this._decodeLight(r);
          this._lights.push(n);
        }
      else
        console.warn(
          "GLTFImporter::_decodeLights >>> there are no lights in the given gltf file"
        );
    }, e.prototype._decodeLight = function(e2) {
      var t, i, r, n, o, a, s, l, c, u, h, d, f, p, v, m, g, E, y, A, T, x, _, w, S, b, R, C, O, D, M, L, I, P, B, H, N, F, G, U, z, V, k, j, Y, Q, $, W, X, J, K, q, Z, ee, te, ie, re, ne, oe, ae, se, le, ce, ue, he, de, fe, pe, ve, me, ge, Ee, ye, Ae, Te, xe, _e, we, Se, be, Re, Ce, Oe, De, Me, Le, Ie, Pe, Be, He, Ne, Fe, Ge, Ue, ze, Ve, ke, je, Ye, Qe, $e, We, Xe, Je, Ke = null;
      switch (e2.type) {
        case LIGHT_TYPE.HEMISPHERIC:
          var qe = new THREE.Color().fromArray(
            null !== (t = e2.color) && void 0 !== t ? t : [1, 1, 1]
          ), Ze = new THREE.Color().setHex(8553090), et = null !== (i = e2.intensity) && void 0 !== i ? i : 0.75;
          Ke = new THREE.HemisphereLight(qe, Ze, et);
          break;
        case LIGHT_TYPE.DIRECTIONAL:
          qe = new THREE.Color().fromArray(
            null !== (r = e2.color) && void 0 !== r ? r : [1, 1, 1]
          ), et = null !== (n = e2.intensity) && void 0 !== n ? n : 1;
          (Ke = new LightDirectional(qe, et)).castShadow = null !== (l = null === (s = null === (a = null === (o = e2.extensions) || void 0 === o ? void 0 : o.SPE_light_parameters) || void 0 === a ? void 0 : a.shadows) || void 0 === s ? void 0 : s.castShadow) && void 0 !== l && l, Ke.shadow.mapSize = new THREE.Vector2().fromArray(
            null !== (d = null === (h = null === (u = null === (c = e2.extensions) || void 0 === c ? void 0 : c.SPE_light_parameters) || void 0 === u ? void 0 : u.shadows) || void 0 === h ? void 0 : h.shadowmapSize) && void 0 !== d ? d : DEFAULT_SHADOWMAP_SIZE
          ), Ke.shadow.bias = null !== (m = null === (v = null === (p = null === (f = e2.extensions) || void 0 === f ? void 0 : f.SPE_light_parameters) || void 0 === p ? void 0 : p.shadows) || void 0 === v ? void 0 : v.shadowmapBias) && void 0 !== m ? m : 0, Ke.shadow.camera.right = null !== (A = null === (y = null === (E = null === (g = e2.extensions) || void 0 === g ? void 0 : g.SPE_light_parameters) || void 0 === E ? void 0 : E.shadows) || void 0 === y ? void 0 : y.shadowmapViewRight) && void 0 !== A ? A : 1250, Ke.shadow.camera.left = null !== (w = null === (_ = null === (x = null === (T = e2.extensions) || void 0 === T ? void 0 : T.SPE_light_parameters) || void 0 === x ? void 0 : x.shadows) || void 0 === _ ? void 0 : _.shadowmapViewLeft) && void 0 !== w ? w : -1250, Ke.shadow.camera.top = null !== (C = null === (R = null === (b = null === (S = e2.extensions) || void 0 === S ? void 0 : S.SPE_light_parameters) || void 0 === b ? void 0 : b.shadows) || void 0 === R ? void 0 : R.shadowmapViewTop) && void 0 !== C ? C : 1250, Ke.shadow.camera.bottom = null !== (L = null === (M = null === (D = null === (O = e2.extensions) || void 0 === O ? void 0 : O.SPE_light_parameters) || void 0 === D ? void 0 : D.shadows) || void 0 === M ? void 0 : M.shadowmapViewBottom) && void 0 !== L ? L : -1250, Ke.shadow.camera.near = null !== (H = null === (B = null === (P = null === (I = e2.extensions) || void 0 === I ? void 0 : I.SPE_light_parameters) || void 0 === P ? void 0 : P.shadows) || void 0 === B ? void 0 : B.shadowmapViewNear) && void 0 !== H ? H : 1, Ke.shadow.camera.far = null !== (U = null === (G = null === (F = null === (N = e2.extensions) || void 0 === N ? void 0 : N.SPE_light_parameters) || void 0 === F ? void 0 : F.shadows) || void 0 === G ? void 0 : G.shadowmapViewFar) && void 0 !== U ? U : 2500;
          break;
        case LIGHT_TYPE.POINT:
          qe = new THREE.Color().fromArray(
            null !== (z = e2.color) && void 0 !== z ? z : [1, 1, 1]
          ), et = null !== (V = e2.intensity) && void 0 !== V ? V : 1;
          var tt = null !== (k = e2.range) && void 0 !== k ? k : 0, it = null !== ($ = null === (Q = null === (Y = null === (j = e2.extensions) || void 0 === j ? void 0 : j.SPE_light_parameters) || void 0 === Y ? void 0 : Y.custom) || void 0 === Q ? void 0 : Q.decay) && void 0 !== $ ? $ : 1;
          (Ke = new LightPoint(qe, et, tt, it)).castShadow = null !== (K = null === (J = null === (X = null === (W = e2.extensions) || void 0 === W ? void 0 : W.SPE_light_parameters) || void 0 === X ? void 0 : X.shadows) || void 0 === J ? void 0 : J.castShadow) && void 0 !== K && K, Ke.shadow.mapSize = new THREE.Vector2().fromArray(
            null !== (te = null === (ee = null === (Z = null === (q = e2.extensions) || void 0 === q ? void 0 : q.SPE_light_parameters) || void 0 === Z ? void 0 : Z.shadows) || void 0 === ee ? void 0 : ee.shadowmapSize) && void 0 !== te ? te : DEFAULT_SHADOWMAP_SIZE
          ), Ke.shadow.bias = null !== (oe = null === (ne = null === (re = null === (ie = e2.extensions) || void 0 === ie ? void 0 : ie.SPE_light_parameters) || void 0 === re ? void 0 : re.shadows) || void 0 === ne ? void 0 : ne.shadowmapBias) && void 0 !== oe ? oe : 0, Ke.shadow.camera.near = null !== (ce = null === (le = null === (se = null === (ae = e2.extensions) || void 0 === ae ? void 0 : ae.SPE_light_parameters) || void 0 === se ? void 0 : se.shadows) || void 0 === le ? void 0 : le.shadowmapViewNear) && void 0 !== ce ? ce : 1, Ke.shadow.camera.far = null !== (fe = null === (de = null === (he = null === (ue = e2.extensions) || void 0 === ue ? void 0 : ue.SPE_light_parameters) || void 0 === he ? void 0 : he.shadows) || void 0 === de ? void 0 : de.shadowmapViewFar) && void 0 !== fe ? fe : 2500;
          break;
        case LIGHT_TYPE.SPOT:
          qe = new THREE.Color().fromArray(
            null !== (pe = e2.color) && void 0 !== pe ? pe : [1, 1, 1]
          ), et = null !== (ve = e2.intensity) && void 0 !== ve ? ve : 1, tt = null !== (me = e2.range) && void 0 !== me ? me : 0;
          var rt = null !== (Ee = null === (ge = e2.spot) || void 0 === ge ? void 0 : ge.innerConeAngle) && void 0 !== Ee ? Ee : Math.PI / 3, nt = (it = null !== (xe = null === (Te = null === (Ae = null === (ye = e2.extensions) || void 0 === ye ? void 0 : ye.SPE_light_parameters) || void 0 === Ae ? void 0 : Ae.custom) || void 0 === Te ? void 0 : Te.decay) && void 0 !== xe ? xe : 1, null !== (be = null === (Se = null === (we = null === (_e = e2.extensions) || void 0 === _e ? void 0 : _e.SPE_light_parameters) || void 0 === we ? void 0 : we.custom) || void 0 === Se ? void 0 : Se.penumbra) && void 0 !== be ? be : 0);
          (Ke = new LightSpot(qe, et, tt, rt, nt, it)).castShadow = null !== (De = null === (Oe = null === (Ce = null === (Re = e2.extensions) || void 0 === Re ? void 0 : Re.SPE_light_parameters) || void 0 === Ce ? void 0 : Ce.shadows) || void 0 === Oe ? void 0 : Oe.castShadow) && void 0 !== De && De, Ke.shadow.mapSize = new THREE.Vector2().fromArray(
            null !== (Pe = null === (Ie = null === (Le = null === (Me = e2.extensions) || void 0 === Me ? void 0 : Me.SPE_light_parameters) || void 0 === Le ? void 0 : Le.shadows) || void 0 === Ie ? void 0 : Ie.shadowmapSize) && void 0 !== Pe ? Pe : DEFAULT_SHADOWMAP_SIZE
          ), Ke.shadow.bias = null !== (Fe = null === (Ne = null === (He = null === (Be = e2.extensions) || void 0 === Be ? void 0 : Be.SPE_light_parameters) || void 0 === He ? void 0 : He.shadows) || void 0 === Ne ? void 0 : Ne.shadowmapBias) && void 0 !== Fe ? Fe : 0, Ke.shadow.camera.fov = null !== (Ve = null === (ze = null === (Ue = null === (Ge = e2.extensions) || void 0 === Ge ? void 0 : Ge.SPE_light_parameters) || void 0 === Ue ? void 0 : Ue.shadows) || void 0 === ze ? void 0 : ze.shadowmapViewFov) && void 0 !== Ve ? Ve : 2 * THREE.MathUtils.RAD2DEG * rt, Ke.shadow.camera.near = null !== (Qe = null === (Ye = null === (je = null === (ke = e2.extensions) || void 0 === ke ? void 0 : ke.SPE_light_parameters) || void 0 === je ? void 0 : je.shadows) || void 0 === Ye ? void 0 : Ye.shadowmapViewNear) && void 0 !== Qe ? Qe : 1, Ke.shadow.camera.far = null !== (Je = null === (Xe = null === (We = null === ($e = e2.extensions) || void 0 === $e ? void 0 : $e.SPE_light_parameters) || void 0 === We ? void 0 : We.shadows) || void 0 === Xe ? void 0 : Xe.shadowmapViewFar) && void 0 !== Je ? Je : 2500;
          break;
        default:
          console.error(
            "GLTFImporter::_decodeLight >>> unsupported light type (" + e2.type + ")"
          );
      }
      return Ke;
    }, e.prototype._decodeMeshes = function(e2) {
      var t = e2.meshes;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var r = t[i], n = this._decodeMesh(r);
          this._meshes.push(n);
        }
      else
        console.error(
          "GLTFImporter::_decodeMeshes >>> there are no meshes in this gltf-file"
        );
    }, e.prototype._decodeMesh = function(e2) {
      return !(e2.primitives.length > 0) ? this._decodeParametriGeometry(e2) : this._decodeNonParametricGeometry(e2);
    }, e.prototype._decodeParametriGeometry = function(e2) {
      var t, i = null === (t = e2.extensions) || void 0 === t ? void 0 : t.SPE_primitive;
      return createGeometry(
        null != i ? i : {
          type: "SphereGeometry",
          parameters: { width: 100, height: 100, depth: 100 }
        }
      );
    }, e.prototype._decodeNonParametricGeometry = function(e2) {
      var t, i, r, n, o, a = e2.primitives[0], s = null !== (t = a.indices) && void 0 !== t ? t : -1, l = a.attributes, c = null !== (i = this._accessors[s]) && void 0 !== i ? i : null, u = {};
      for (var h in l) {
        var d = l[h];
        u[h] = this._accessors[d];
      }
      var f = new THREE.BufferGeometry();
      for (var p in c && f.setIndex(c.bufferData), u) {
        h = p in ATTRIBUTE_NAME_MAPPING ? ATTRIBUTE_NAME_MAPPING[p] : p;
        f.setAttribute(h.toLowerCase(), u[p].bufferData);
      }
      if (!e2.extensions)
        return console.error(
          "GLTFImporter::_decodeNonParametricGeometry >>> must have SPE_primitive extension"
        ), f;
      var v = new THREE.Vector3();
      f.computeBoundingBox(), f.boundingBox.getSize(v);
      var m = e2.extensions.SPE_primitive, g = null !== (r = m.parameters.width) && void 0 !== r ? r : v.x, E = null !== (n = m.parameters.height) && void 0 !== n ? n : v.y, y = null !== (o = m.parameters.depth) && void 0 !== o ? o : v.z;
      return f.scale(
        Math.abs(v.x) < 1e-5 ? 1 : g / v.x,
        Math.abs(v.y) < 1e-5 ? 1 : E / v.y,
        Math.abs(v.z) < 1e-5 ? 1 : y / v.z
      ), f.userData = {
        type: "NonParametricGeometry",
        parameters: { width: g, height: E, depth: y }
      }, f;
    }, e.prototype._decodeMaterials = function(e2) {
      var t = e2.materials;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var r = t[i], n = this._decodeMaterial(r);
          this._materials.push(n);
        }
      else
        console.error(
          "GLTFImporter::_decodeMaterials >>> there are no materials in this gltf-file"
        );
    }, e.prototype._decodeMaterial = function(e2) {
      var t, i, r, n, o, a, s, l, c, u, h, d, f, p, v, m, g, E = null !== (t = e2.name) && void 0 !== t ? t : "DefaultMaterial", y = (null !== (i = e2.alphaMode) && void 0 !== i ? i : GLTF_MATERIAL_ALPHA_MODE.OPAQUE) === GLTF_MATERIAL_ALPHA_MODE.BLEND, A = null !== (r = e2.alphaCutoff) && void 0 !== r ? r : 1;
      if (!e2.extensions)
        return console.error(
          "GLTFImporter::_decodeMaterial >>> there must be extensions for materials in Spline"
        ), null;
      if (!e2.extensions.KHR_materials_common)
        return console.error(
          "GLTFImporter::_decodeMaterial >>> there must be the KHR_materials_common extension for spline usage"
        ), null;
      if (!e2.extensions.SPE_materials_layers)
        return console.error(
          "GLTFImporter::_decodeMaterial >>> there must be the SPE_materials_layers extension for spline usage"
        ), null;
      if (!e2.extensions.SPE_materials_options)
        return console.error(
          "GLTFImporter::_decodeMaterial >>> there must be the SPE_materials_options extension for spline usage"
        ), null;
      var T = e2.extensions.KHR_materials_common, x = e2.extensions.SPE_materials_layers, _ = e2.extensions.SPE_materials_options;
      function w(e3) {
        switch (e3) {
          case GLTF_MATERIAL_SIDE.FRONT_SIDE:
            return THREE.FrontSide;
          case GLTF_MATERIAL_SIDE.BACK_SIDE:
            return THREE.BackSide;
          case GLTF_MATERIAL_SIDE.DOUBLE_SIDE:
            return THREE.DoubleSide;
        }
      }
      var S = null;
      switch (T.technique) {
        case GLTF_LIGHTING_TECHNIQUE.CONSTANT:
          var b = new THREE.Color().fromArray(
            null !== (n = T.ambient) && void 0 !== n ? n : [0.5, 0.5, 0.5]
          ), R = _.visible, C = _.wireframe, O = _.shadingMode === GLTF_MATERIAL_SHADING_MODE.FLAT_SHADING, D = w(_.side);
          S = new BasicMaterial({
            name: E,
            color: b,
            visible: R,
            wireframe: C,
            flatShading: O,
            side: D,
            transparent: y,
            opacity: A
          });
          break;
        case GLTF_LIGHTING_TECHNIQUE.LAMBERT:
          b = new THREE.Color().fromArray(
            null !== (o = T.diffuse) && void 0 !== o ? o : [0.5, 0.5, 0.5]
          );
          var M = new THREE.Color().fromArray(
            null !== (a = T.emission) && void 0 !== a ? a : [0, 0, 0]
          );
          R = _.visible, C = _.wireframe, O = _.shadingMode === GLTF_MATERIAL_SHADING_MODE.FLAT_SHADING, D = w(_.side);
          S = new LambertMaterial({
            name: E,
            color: b,
            emissive: M,
            visible: R,
            wireframe: C,
            flatShading: O,
            side: D,
            transparent: y,
            opacity: A
          });
          break;
        case GLTF_LIGHTING_TECHNIQUE.BLINN:
          b = new THREE.Color().fromArray(
            null !== (s = T.diffuse) && void 0 !== s ? s : [0.5, 0.5, 0.5]
          );
          var L = new THREE.Color().fromArray(
            null !== (l = T.specular) && void 0 !== l ? l : [0.5, 0.5, 0.5]
          ), I = null !== (c = T.shininess) && void 0 !== c ? c : 32;
          M = new THREE.Color().fromArray(
            null !== (u = T.emission) && void 0 !== u ? u : [0, 0, 0]
          ), R = _.visible, C = _.wireframe, O = _.shadingMode === GLTF_MATERIAL_SHADING_MODE.FLAT_SHADING, D = w(_.side);
          S = new PhongMaterial$1({
            name: E,
            color: b,
            specular: L,
            shininess: I,
            emissive: M,
            visible: R,
            wireframe: C,
            flatShading: O,
            side: D,
            transparent: y,
            opacity: A
          });
          break;
        case GLTF_LIGHTING_TECHNIQUE.TOON:
          b = new THREE.Color().fromArray(
            null !== (h = T.ambient) && void 0 !== h ? h : [0.5, 0.5, 0.5]
          ), M = new THREE.Color().fromArray(
            null !== (d = T.emission) && void 0 !== d ? d : [0, 0, 0]
          ), R = _.visible, C = _.wireframe, O = _.shadingMode === GLTF_MATERIAL_SHADING_MODE.FLAT_SHADING, D = w(_.side);
          S = new ToonMaterial({
            name: E,
            color: b,
            emissive: M,
            visible: R,
            wireframe: C,
            flatShading: O,
            side: D,
            transparent: y,
            opacity: A
          });
          break;
        case GLTF_LIGHTING_TECHNIQUE.PHYSICAL:
          b = new THREE.Color().fromArray(
            null !== (f = T.diffuse) && void 0 !== f ? f : [0.5, 0.5, 0.5]
          );
          var P = null !== (p = T.roughness) && void 0 !== p ? p : 0.3, B = null !== (v = T.metalness) && void 0 !== v ? v : 0, H = null !== (m = T.reflectivity) && void 0 !== m ? m : 0.5;
          M = new THREE.Color().fromArray(
            null !== (g = T.emission) && void 0 !== g ? g : [0, 0, 0]
          ), R = _.visible, C = _.wireframe, O = _.shadingMode === GLTF_MATERIAL_SHADING_MODE.FLAT_SHADING, D = w(_.side);
          S = new PhysicalMaterial({
            name: E,
            color: b,
            roughness: P,
            metalness: B,
            reflectivity: H,
            emissive: M,
            visible: R,
            wireframe: C,
            flatShading: O,
            side: D,
            transparent: y,
            opacity: A
          });
          break;
        default:
          b = new THREE.Color(9079434), L = new THREE.Color(9079434);
          S = new PhongMaterial$1({
            name: E,
            color: b,
            specular: L,
            shininess: I = 32,
            transparent: y,
            opacity: A
          });
      }
      return this._setupLayersInMaterial(S, x.layers), S.onBeforeCompile = ShaderLib.createCallback(S), S;
    }, e.prototype._setupLayersInMaterial = function(e2, t) {
      var i, r, n, o, a, s, l, c, u, h, d, f, p, v, m, g, E, y, A, T, x, _, w, S, b, R, C, O, D, M, L, I, P, B, H, N, F, G, U, z, V, k, j, Y, Q, $, W, X, J, K, q, Z, ee, te, ie, re, ne, oe, ae, se, le, ce, ue, he, de, fe, pe, ve, me = this;
      function ge(e3) {
        var t2;
        return null !== (t2 = me._textures[e3]) && void 0 !== t2 ? t2 : DEFAULT_TEXTURE;
      }
      function Ee(e3) {
        for (var t2 = Math.floor(e3.length / 4), i2 = [], r2 = 0; r2 < t2; r2++) {
          var n2 = e3[4 * r2 + 0], o2 = e3[4 * r2 + 1], a2 = e3[4 * r2 + 2], s2 = e3[4 * r2 + 3];
          i2.push(new THREE.Vector4(n2, o2, a2, s2));
        }
        return i2;
      }
      var ye = e2.userData.layers, Ae = null;
      ye.dispose();
      for (var Te = 0; Te < t.length; Te++) {
        var xe = t[Te], _e = xe.id, we = xe.uniforms, Se = {
          type: xe.type,
          alpha: null !== (r = null === (i = we.alpha) || void 0 === i ? void 0 : i.value) && void 0 !== r ? r : 1,
          mode: null !== (o = null === (n = we.mode) || void 0 === n ? void 0 : n.value) && void 0 !== o ? o : 0,
          color: new THREE.Color().fromArray(
            null !== (s = null === (a = we.color) || void 0 === a ? void 0 : a.value) && void 0 !== s ? s : [0.1, 0.1, 0.1]
          ),
          texture: ge(
            null !== (c = null === (l = we.texture) || void 0 === l ? void 0 : l.value) && void 0 !== c ? c : -1
          ),
          crop: null !== (h = null === (u = we.crop) || void 0 === u ? void 0 : u.value) && void 0 !== h ? h : 0,
          cnormal: new THREE.Vector3().fromArray(
            null !== (f = null === (d = we.cnormal) || void 0 === d ? void 0 : d.value) && void 0 !== f ? f : [0, 0, 1]
          ),
          near: null !== (v = null === (p = we.near) || void 0 === p ? void 0 : p.value) && void 0 !== v ? v : 700,
          far: null !== (g = null === (m = we.far) || void 0 === m ? void 0 : m.value) && void 0 !== g ? g : 1e3,
          origin: new THREE.Vector3().fromArray(
            null !== (y = null === (E = we.origin) || void 0 === E ? void 0 : E.value) && void 0 !== y ? y : [0, 0, 0]
          ),
          isVector: null !== (T = null === (A = we.isVector) || void 0 === A ? void 0 : A.value) && void 0 !== T ? T : 0,
          colorA: new THREE.Color().fromArray(
            null !== (_ = null === (x = we.colorA) || void 0 === x ? void 0 : x.value) && void 0 !== _ ? _ : [0.1, 0.1, 0.1]
          ),
          colorB: new THREE.Color().fromArray(
            null !== (S = null === (w = we.colorB) || void 0 === w ? void 0 : w.value) && void 0 !== S ? S : [0.1, 0.1, 0.1]
          ),
          colorC: new THREE.Color().fromArray(
            null !== (R = null === (b = we.colorC) || void 0 === b ? void 0 : b.value) && void 0 !== R ? R : [0.1, 0.1, 0.1]
          ),
          colorD: new THREE.Color().fromArray(
            null !== (O = null === (C = we.colorD) || void 0 === C ? void 0 : C.value) && void 0 !== O ? O : [0.1, 0.1, 0.1]
          ),
          scale: null !== (M = null === (D = we.scale) || void 0 === D ? void 0 : D.value) && void 0 !== M ? M : 2,
          move: null !== (I = null === (L = we.move) || void 0 === L ? void 0 : L.value) && void 0 !== I ? I : 1,
          distortion: new THREE.Vector2().fromArray(
            null !== (B = null === (P = we.distortion) || void 0 === P ? void 0 : P.value) && void 0 !== B ? B : [1, 1]
          ),
          fA: new THREE.Vector2().fromArray(
            null !== (N = null === (H = we.fA) || void 0 === H ? void 0 : H.value) && void 0 !== N ? N : [1.7, 9.2]
          ),
          fB: new THREE.Vector2().fromArray(
            null !== (G = null === (F = we.fB) || void 0 === F ? void 0 : F.value) && void 0 !== G ? G : [8.3, 2.8]
          ),
          intA: null !== (z = null === (U = we.intA) || void 0 === U ? void 0 : U.value) && void 0 !== z ? z : 10,
          intB: null !== (k = null === (V = we.intB) || void 0 === V ? void 0 : V.value) && void 0 !== k ? k : 10,
          intC: null !== (Y = null === (j = we.intC) || void 0 === j ? void 0 : j.value) && void 0 !== Y ? Y : 10,
          intD: null !== ($ = null === (Q = we.intD) || void 0 === Q ? void 0 : Q.value) && void 0 !== $ ? $ : 10,
          bias: null !== (X = null === (W = we.bias) || void 0 === W ? void 0 : W.value) && void 0 !== X ? X : 0.1,
          intensity: null !== (K = null === (J = we.intensity) || void 0 === J ? void 0 : J.value) && void 0 !== K ? K : 2,
          factor: null !== (Z = null === (q = we.factor) || void 0 === q ? void 0 : q.value) && void 0 !== Z ? Z : 1,
          colors: Ee(
            null !== (te = null === (ee = we.colors) || void 0 === ee ? void 0 : ee.value) && void 0 !== te ? te : DEFAULT_ARRAY_COLORS
          ),
          steps: null !== (re = null === (ie = we.steps) || void 0 === ie ? void 0 : ie.value) && void 0 !== re ? re : DEFAULT_STEPS,
          gl_type: null !== (oe = null === (ne = we.gl_type) || void 0 === ne ? void 0 : ne.value) && void 0 !== oe ? oe : 0,
          num: null !== (se = null === (ae = we.num) || void 0 === ae ? void 0 : ae.value) && void 0 !== se ? se : 2,
          smooth: null !== (ce = null === (le = we.smooth) || void 0 === le ? void 0 : le.value) && void 0 !== ce && ce,
          offset: new THREE.Vector2().fromArray(
            null !== (he = null === (ue = we.offset) || void 0 === ue ? void 0 : ue.value) && void 0 !== he ? he : [0, 0]
          ),
          morph: new THREE.Vector2().fromArray(
            null !== (fe = null === (de = we.morph) || void 0 === de ? void 0 : de.value) && void 0 !== fe ? fe : [0, 0]
          ),
          angle: null !== (ve = null === (pe = we.angle) || void 0 === pe ? void 0 : pe.value) && void 0 !== ve ? ve : 0
        };
        if (0 == Te) Ae = ye.head = new Layer(_e, Se);
        else {
          var be = new Layer(_e, Se);
          Ae.next = be, Ae = be;
        }
      }
    }, e.prototype._decodeNodes = function(e2) {
      var t = e2.nodes;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var r = t[i], n = this._decodeNode(r);
          this._nodes.push(n), this._objects[n.uuid] = n;
        }
      else
        console.error(
          "GLTFImporter::_decodeMaterials >>> there are no materials in this gltf-file"
        );
    }, e.prototype._decodeInteractions = function(e2) {
      for (var t, i, r, n, o = null !== (t = e2.extensions.SPE_interactions.interactions) && void 0 !== t ? t : [], a = e2.nodes, s = 0; s < a.length; s++) {
        var l = null !== (n = null === (r = null === (i = a[s].extensions) || void 0 === i ? void 0 : i.SPE_node_3d) || void 0 === r ? void 0 : r.interaction) && void 0 !== n ? n : -1;
        if (l >= 0 && l < o.length) {
          var c = o[l], u = this._interactionStates, h = this._objects;
          this._nodes[s].interaction.fromJSON(c, h, u);
        }
      }
    }, e.prototype._decodeNode = function(e2) {
      var t, i, r, n, o, a, s, l, c, u, h, d, f, p, v, m, g, E, y, A, T, x, _, w, S, b, R, C, O, D, M, L, I, P, B, H, N, F, G, U;
      if (!(null === (t = e2.extensions) || void 0 === t ? void 0 : t.SPE_node_3d))
        return console.error(
          "GLTFImporter::_decodeNode >>> tried decoding a non-spline object"
        ), new THREE.Object3D();
      var z = e2.extensions.SPE_node_3d, V = z.type;
      switch (V) {
        case OBJECT_TYPE.SCENE:
          var k = null !== (i = e2.name) && void 0 !== i ? i : "Default Scene", j = null !== (r = z.uuid) && void 0 !== r ? r : THREE.MathUtils.generateUUID(), Y = new Scene();
          return Y.name = k, Y.uuid = j, Y;
        case OBJECT_TYPE.CAMERA:
          var Q = null !== (n = e2.camera) && void 0 !== n ? n : -1;
          if (Q < 0 || Q >= this._cameras.length)
            return console.error(
              "GLTFImporter::_decodeNode >>> camera index out of range"
            ), new EmptyObject();
          var $ = this._cameras[Q], W = new THREE.Vector3().fromArray(
            null !== (o = e2.translation) && void 0 !== o ? o : [0, 0, 0]
          ), X = new THREE.Quaternion().fromArray(
            null !== (a = e2.rotation) && void 0 !== a ? a : [0, 0, 0, 1]
          ), J = new THREE.Matrix4().fromArray(
            null !== (s = z.hiddenMatrix) && void 0 !== s ? s : IDENTITY_MATRIX
          ), K = null === (l = z.visible) || void 0 === l || l, q = null !== (c = z.uuid) && void 0 !== c ? c : THREE.MathUtils.generateUUID(), Z = null !== (u = e2.name) && void 0 !== u ? u : "Camera_" + THREE.MathUtils.generateUUID();
          return $.position.copy(W), $.quaternion.copy(X), $.hiddenMatrix.copy(J), $.visible = K, $.uuid = q, $.name = Z, $.updateMatrix(), $;
        case OBJECT_TYPE.LIGHT:
          var ee = null !== (d = null === (h = e2.extensions.KHR_lights_punctual) || void 0 === h ? void 0 : h.light) && void 0 !== d ? d : -1;
          if (ee < 0 || ee >= this._lights.length)
            return console.error(
              "GLTFImporter::_decodeNode >>> light index out of range"
            ), new EmptyObject();
          var te = this._lights[ee], ie = new THREE.Vector3().fromArray(
            null !== (f = e2.translation) && void 0 !== f ? f : [0, 0, 0]
          ), re = new THREE.Quaternion().fromArray(
            null !== (p = e2.rotation) && void 0 !== p ? p : [0, 0, 0, 1]
          ), ne = new THREE.Matrix4().fromArray(
            null !== (v = z.hiddenMatrix) && void 0 !== v ? v : IDENTITY_MATRIX
          ), oe = null === (m = z.visible) || void 0 === m || m, ae = null !== (g = z.uuid) && void 0 !== g ? g : THREE.MathUtils.generateUUID(), se = null !== (E = e2.name) && void 0 !== E ? E : "Light_" + THREE.MathUtils.generateUUID();
          if ("HemisphereLight" !== te.type && te.position.copy(ie), te.visible = oe, te.uuid = ae, te.name = se, "HemisphereLight" !== te.type && te.hiddenMatrix.copy(ne), "SpotLight" === te.type || "DirectionalLight" === te.type) {
            var le = new THREE.Matrix4().makeRotationFromQuaternion(re), ce = new THREE.Vector3(
              le.elements[8],
              le.elements[9],
              le.elements[10]
            );
            te.target.position.copy(te.position.clone().add(ce));
          }
          return "HemisphereLight" !== te.type && te.updateMatrix(), te;
        case OBJECT_TYPE.MESH_3D:
        case OBJECT_TYPE.MESH_2D:
        case OBJECT_TYPE.TEXTFRAME:
        case OBJECT_TYPE.VECTOR_OBJECT:
          var ue = null !== (y = e2.mesh) && void 0 !== y ? y : -1;
          (ue < 0 || ue >= this._meshes.length) && console.error(
            "GLTFImporter::_decodeNode >>> geometry index out of range"
          );
          var he = null !== (A = this._meshes[ue]) && void 0 !== A ? A : new THREE.SphereBufferGeometry(100), de = (null !== (T = this._gltfFile.meshes) && void 0 !== T ? T : [])[ue], fe = -1;
          if (de.primitives.length > 0)
            fe = null !== (x = de.primitives[0].material) && void 0 !== x ? x : -1;
          else {
            var pe = null === (_ = de.extensions) || void 0 === _ ? void 0 : _.SPE_material;
            fe = pe && null !== (w = pe[0]) && void 0 !== w ? w : -1;
          }
          (fe < 0 || fe >= this._materials.length) && console.error(
            "GLTFImporter::_decodeNode >>> material index out of range"
          );
          var ve = null !== (S = this._materials[fe]) && void 0 !== S ? S : new PhongMaterial$1({ color: 10592673 }), me = null;
          switch (V) {
            case OBJECT_TYPE.MESH_3D:
              me = new Mesh3D(he, ve);
              break;
            case OBJECT_TYPE.MESH_2D:
              me = new Mesh2D(he, ve);
              break;
            case OBJECT_TYPE.TEXTFRAME:
              me = new TextFrame(he, ve);
              var ge = e2.extensions.SPE_node_3d.textData.object;
              me.fromJSONasync(ge).then(function() {
              }).catch(function(e3) {
                console.error(e3);
              });
              break;
            case OBJECT_TYPE.VECTOR_OBJECT:
              me = new VectorObject(he, ve);
          }
          var Ee = new THREE.Vector3().fromArray(
            null !== (b = e2.translation) && void 0 !== b ? b : [0, 0, 0]
          ), ye = new THREE.Quaternion().fromArray(
            null !== (R = e2.rotation) && void 0 !== R ? R : [0, 0, 0, 1]
          ), Ae = new THREE.Vector3().fromArray(
            null !== (C = e2.scale) && void 0 !== C ? C : [1, 1, 1]
          ), Te = new THREE.Matrix4().fromArray(
            null !== (O = z.hiddenMatrix) && void 0 !== O ? O : IDENTITY_MATRIX
          ), xe = null === (D = z.visible) || void 0 === D || D, _e = null !== (M = z.uuid) && void 0 !== M ? M : THREE.MathUtils.generateUUID(), we = null === (L = z.castShadow) || void 0 === L || L, Se = null === (I = z.receiveShadow) || void 0 === I || I;
          return me.position.copy(Ee), me.quaternion.copy(ye), me.scale.copy(Ae), me.hiddenMatrix.copy(Te), me.visible = xe, me.uuid = _e, me.castShadow = we, me.receiveShadow = Se, me.updateMatrix(), null !== (P = e2.extensions.SPE_node_3d.isCloner) && void 0 !== P && P && (me.cloner = new Cloner(me).fromJSON(
            e2.extensions.SPE_node_3d.cloner
          ), me.add(me.cloner)), me;
        case OBJECT_TYPE.EMPTY_OBJECT:
          var be = new EmptyObject(), Re = new THREE.Vector3().fromArray(
            null !== (B = e2.translation) && void 0 !== B ? B : [0, 0, 0]
          ), Ce = new THREE.Quaternion().fromArray(
            null !== (H = e2.rotation) && void 0 !== H ? H : [0, 0, 0, 1]
          ), Oe = new THREE.Vector3().fromArray(
            null !== (N = e2.scale) && void 0 !== N ? N : [1, 1, 1]
          ), De = new THREE.Matrix4().fromArray(
            null !== (F = z.hiddenMatrix) && void 0 !== F ? F : IDENTITY_MATRIX
          ), Me = null === (G = z.visible) || void 0 === G || G, Le = null !== (U = z.uuid) && void 0 !== U ? U : THREE.MathUtils.generateUUID();
          return be.position.copy(Re), be.quaternion.copy(Ce), be.scale.copy(Oe), be.hiddenMatrix.copy(De), be.visible = Me, be.uuid = Le, be.updateMatrix(), be;
      }
      return console.error(
        "GLTFImporter::_decodeNode >>> unsupported object type (" + V + ")"
      ), new THREE.Object3D();
    }, e.prototype._decodeSceneGraph = function(e2) {
      for (var t, i = [{ nodeIndex: 0, parentNode: null }]; 0 != i.length; ) {
        var r = i.pop(), n = r.nodeIndex, o = r.parentNode;
        if (n < this._nodes.length && n >= 0) {
          var a = this._nodes[n];
          if (!a) continue;
          o && o.add(a);
          for (var s = null !== (t = e2.nodes[n].children) && void 0 !== t ? t : [], l = 0; l < s.length; l++)
            i.push({ nodeIndex: s[l], parentNode: a });
        }
      }
    }, e;
  }(), OrbitControls = function(e, t) {
    var i, r, n, o, a;
    void 0 === t && console.warn(
      'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
    ), t === document && console.error(
      'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
    ), this.object = e, this.domElement = t, this.enabled = true, this.target = new THREE.Vector3(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = false, this.keyPanSpeed = 7, this.autoRotate = false, this.autoRotateSpeed = 2, this.enableKeys = true, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = {
      LEFT: THREE.MOUSE.ROTATE,
      MIDDLE: THREE.MOUSE.DOLLY,
      RIGHT: THREE.MOUSE.PAN
    }, this.touches = {
      ONE: THREE.TOUCH.ROTATE,
      TWO: THREE.TOUCH.DOLLY_PAN
    }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
      return p.phi;
    }, this.getAzimuthalAngle = function() {
      return p.theta;
    }, this.saveState = function() {
      s.target0.copy(s.target), s.position0.copy(s.object.position), s.zoom0 = s.object.zoom;
    }, this.reset = function() {
      s.target.copy(s.target0), s.object.position.copy(s.position0), s.object.zoom = s.zoom0, s.object.updateProjectionMatrix(), s.dispatchEvent(l), s.update(), d = h.NONE;
    }, this.update = (i = new THREE.Vector3(), r = new THREE.Quaternion().setFromUnitVectors(
      e.up,
      new THREE.Vector3(0, 1, 0)
    ), n = r.clone().inverse(), o = new THREE.Vector3(), a = new THREE.Quaternion(), function() {
      var e2 = s.object.position;
      return i.copy(e2).sub(s.target), i.applyQuaternion(r), p.setFromVector3(i), s.autoRotate && d === h.NONE && O(2 * Math.PI / 60 / 60 * s.autoRotateSpeed), s.enableDamping ? (p.theta += v.theta * s.dampingFactor, p.phi += v.phi * s.dampingFactor) : (p.theta += v.theta, p.phi += v.phi), p.theta = Math.max(
        s.minAzimuthAngle,
        Math.min(s.maxAzimuthAngle, p.theta)
      ), p.phi = Math.max(
        s.minPolarAngle,
        Math.min(s.maxPolarAngle, p.phi)
      ), p.makeSafe(), p.radius *= m, p.radius = Math.max(
        s.minDistance,
        Math.min(s.maxDistance, p.radius)
      ), true === s.enableDamping ? s.target.addScaledVector(g, s.dampingFactor) : s.target.add(g), i.setFromSpherical(p), i.applyQuaternion(n), e2.copy(s.target).add(i), s.object.lookAt(s.target), true === s.enableDamping ? (v.theta *= 1 - s.dampingFactor, v.phi *= 1 - s.dampingFactor, g.multiplyScalar(1 - s.dampingFactor)) : (v.set(0, 0, 0), g.set(0, 0, 0)), m = 1, !!(E || o.distanceToSquared(s.object.position) > f || 8 * (1 - a.dot(s.object.quaternion)) > f) && (s.dispatchEvent(l), o.copy(s.object.position), a.copy(s.object.quaternion), E = false, true);
    }), this.dispose = function() {
      s.domElement.removeEventListener("contextmenu", q, false), s.domElement.removeEventListener("mousedown", j, false), s.domElement.removeEventListener("wheel", $, false), s.domElement.removeEventListener("touchstart", X, false), s.domElement.removeEventListener("touchend", K, false), s.domElement.removeEventListener("touchmove", J, false), document.removeEventListener("mousemove", Y, false), document.removeEventListener("mouseup", Q, false), s.domElement.removeEventListener("keydown", W, false);
    };
    var s = this, l = { type: "change" }, c = { type: "start" }, u = { type: "end" }, h = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    }, d = h.NONE, f = 1e-6, p = new THREE.Spherical(), v = new THREE.Spherical(), m = 1, g = new THREE.Vector3(), E = false, y = new THREE.Vector2(), A = new THREE.Vector2(), T = new THREE.Vector2(), x = new THREE.Vector2(), _ = new THREE.Vector2(), w = new THREE.Vector2(), S = new THREE.Vector2(), b = new THREE.Vector2(), R = new THREE.Vector2();
    function C() {
      return Math.pow(0.95, s.zoomSpeed);
    }
    function O(e2) {
      v.theta -= e2;
    }
    function D(e2) {
      v.phi -= e2;
    }
    var M = function() {
      var e2 = new THREE.Vector3();
      return function(t2, i2) {
        e2.setFromMatrixColumn(i2, 0), e2.multiplyScalar(-t2), g.add(e2);
      };
    }(), L = function() {
      var e2 = new THREE.Vector3();
      return function(t2, i2) {
        true === s.screenSpacePanning ? e2.setFromMatrixColumn(i2, 1) : (e2.setFromMatrixColumn(i2, 0), e2.crossVectors(s.object.up, e2)), e2.multiplyScalar(t2), g.add(e2);
      };
    }(), I = function() {
      var e2 = new THREE.Vector3();
      return function(t2, i2) {
        var r2 = s.domElement;
        if ("PerspectiveCamera" === s.object.cameraType) {
          var n2 = s.object.position;
          e2.copy(n2).sub(s.target);
          var o2 = e2.length();
          o2 *= Math.tan(s.object.fov / 2 * Math.PI / 180), M(2 * t2 * o2 / r2.clientHeight, s.object.matrix), L(2 * i2 * o2 / r2.clientHeight, s.object.matrix);
        } else
          "OrthographicCamera" === s.object.cameraType ? (M(
            t2 * (s.object.right - s.object.left) / s.object.zoom / r2.clientWidth,
            s.object.matrix
          ), L(
            i2 * (s.object.top - s.object.bottom) / s.object.zoom / r2.clientHeight,
            s.object.matrix
          )) : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
          ), s.enablePan = false);
      };
    }();
    function P(e2) {
      "PerspectiveCamera" === s.object.cameraType ? m /= e2 : "OrthographicCamera" === s.object.cameraType ? (s.object.zoom = Math.max(
        s.minZoom,
        Math.min(s.maxZoom, s.object.zoom * e2)
      ), s.object.updateProjectionMatrix(), E = true) : (console.warn(
        "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
      ), s.enableZoom = false);
    }
    function B(e2) {
      "PerspectiveCamera" === s.object.cameraType ? m *= e2 : "OrthographicCamera" === s.object.cameraType ? (s.object.zoom = Math.max(
        s.minZoom,
        Math.min(s.maxZoom, s.object.zoom / e2)
      ), s.object.updateProjectionMatrix(), E = true) : (console.warn(
        "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
      ), s.enableZoom = false);
    }
    function H(e2) {
      y.set(e2.clientX, e2.clientY);
    }
    function N(e2) {
      x.set(e2.clientX, e2.clientY);
    }
    function F(e2) {
      if (1 == e2.touches.length) y.set(e2.touches[0].pageX, e2.touches[0].pageY);
      else {
        var t2 = 0.5 * (e2.touches[0].pageX + e2.touches[1].pageX), i2 = 0.5 * (e2.touches[0].pageY + e2.touches[1].pageY);
        y.set(t2, i2);
      }
    }
    function G(e2) {
      if (1 == e2.touches.length) x.set(e2.touches[0].pageX, e2.touches[0].pageY);
      else {
        var t2 = 0.5 * (e2.touches[0].pageX + e2.touches[1].pageX), i2 = 0.5 * (e2.touches[0].pageY + e2.touches[1].pageY);
        x.set(t2, i2);
      }
    }
    function U(e2) {
      var t2 = e2.touches[0].pageX - e2.touches[1].pageX, i2 = e2.touches[0].pageY - e2.touches[1].pageY, r2 = Math.sqrt(t2 * t2 + i2 * i2);
      S.set(0, r2);
    }
    function z(e2) {
      if (1 == e2.touches.length) A.set(e2.touches[0].pageX, e2.touches[0].pageY);
      else {
        var t2 = 0.5 * (e2.touches[0].pageX + e2.touches[1].pageX), i2 = 0.5 * (e2.touches[0].pageY + e2.touches[1].pageY);
        A.set(t2, i2);
      }
      T.subVectors(A, y).multiplyScalar(s.rotateSpeed);
      var r2 = s.domElement;
      O(2 * Math.PI * T.x / r2.clientHeight), D(2 * Math.PI * T.y / r2.clientHeight), y.copy(A);
    }
    function V(e2) {
      if (1 == e2.touches.length) _.set(e2.touches[0].pageX, e2.touches[0].pageY);
      else {
        var t2 = 0.5 * (e2.touches[0].pageX + e2.touches[1].pageX), i2 = 0.5 * (e2.touches[0].pageY + e2.touches[1].pageY);
        _.set(t2, i2);
      }
      w.subVectors(_, x).multiplyScalar(s.panSpeed), I(w.x, w.y), x.copy(_);
    }
    function k(e2) {
      var t2 = e2.touches[0].pageX - e2.touches[1].pageX, i2 = e2.touches[0].pageY - e2.touches[1].pageY, r2 = Math.sqrt(t2 * t2 + i2 * i2);
      b.set(0, r2), R.set(0, Math.pow(b.y / S.y, s.zoomSpeed)), P(R.y), S.copy(b);
    }
    function j(e2) {
      if (false !== s.enabled) {
        var t2;
        switch (e2.preventDefault(), s.domElement.focus ? s.domElement.focus() : window.focus(), e2.button) {
          case 0:
            t2 = s.mouseButtons.LEFT;
            break;
          case 1:
            t2 = s.mouseButtons.MIDDLE;
            break;
          case 2:
            t2 = s.mouseButtons.RIGHT;
            break;
          default:
            t2 = -1;
        }
        switch (t2) {
          case THREE.MOUSE.DOLLY:
            if (false === s.enableZoom) return;
            !function(e3) {
              S.set(e3.clientX, e3.clientY);
            }(e2), d = h.DOLLY;
            break;
          case THREE.MOUSE.ROTATE:
            if (e2.ctrlKey || e2.metaKey || e2.shiftKey) {
              if (false === s.enablePan) return;
              N(e2), d = h.PAN;
            } else {
              if (false === s.enableRotate) return;
              H(e2), d = h.ROTATE;
            }
            break;
          case THREE.MOUSE.PAN:
            if (e2.ctrlKey || e2.metaKey || e2.shiftKey) {
              if (false === s.enableRotate) return;
              H(e2), d = h.ROTATE;
            } else {
              if (false === s.enablePan) return;
              N(e2), d = h.PAN;
            }
            break;
          default:
            d = h.NONE;
        }
        d !== h.NONE && (document.addEventListener("mousemove", Y, false), document.addEventListener("mouseup", Q, false), s.dispatchEvent(c));
      }
    }
    function Y(e2) {
      if (false !== s.enabled)
        switch (e2.preventDefault(), d) {
          case h.ROTATE:
            if (false === s.enableRotate) return;
            !function(e3) {
              A.set(e3.clientX, e3.clientY), T.subVectors(A, y).multiplyScalar(s.rotateSpeed);
              var t2 = s.domElement;
              O(2 * Math.PI * T.x / t2.clientHeight), D(2 * Math.PI * T.y / t2.clientHeight), y.copy(A), s.update();
            }(e2);
            break;
          case h.DOLLY:
            if (false === s.enableZoom) return;
            !function(e3) {
              b.set(e3.clientX, e3.clientY), R.subVectors(b, S), R.y > 0 ? P(C()) : R.y < 0 && B(C()), S.copy(b), s.update();
            }(e2);
            break;
          case h.PAN:
            if (false === s.enablePan) return;
            !function(e3) {
              _.set(e3.clientX, e3.clientY), w.subVectors(_, x).multiplyScalar(s.panSpeed), I(w.x, w.y), x.copy(_), s.update();
            }(e2);
        }
    }
    function Q(e2) {
      false !== s.enabled && (document.removeEventListener("mousemove", Y, false), document.removeEventListener("mouseup", Q, false), s.dispatchEvent(u), d = h.NONE);
    }
    function $(e2) {
      false === s.enabled || false === s.enableZoom || d !== h.NONE && d !== h.ROTATE || (e2.preventDefault(), e2.stopPropagation(), s.dispatchEvent(c), function(e3) {
        e3.deltaY < 0 ? B(C()) : e3.deltaY > 0 && P(C()), s.update();
      }(e2), s.dispatchEvent(u));
    }
    function W(e2) {
      false !== s.enabled && false !== s.enableKeys && false !== s.enablePan && function(e3) {
        var t2 = false;
        switch (e3.keyCode) {
          case s.keys.UP:
            I(0, s.keyPanSpeed), t2 = true;
            break;
          case s.keys.BOTTOM:
            I(0, -s.keyPanSpeed), t2 = true;
            break;
          case s.keys.LEFT:
            I(s.keyPanSpeed, 0), t2 = true;
            break;
          case s.keys.RIGHT:
            I(-s.keyPanSpeed, 0), t2 = true;
        }
        t2 && (e3.preventDefault(), s.update());
      }(e2);
    }
    function X(e2) {
      if (false !== s.enabled) {
        switch (e2.preventDefault(), e2.touches.length) {
          case 1:
            switch (s.touches.ONE) {
              case THREE.TOUCH.ROTATE:
                if (false === s.enableRotate) return;
                F(e2), d = h.TOUCH_ROTATE;
                break;
              case THREE.TOUCH.PAN:
                if (false === s.enablePan) return;
                G(e2), d = h.TOUCH_PAN;
                break;
              default:
                d = h.NONE;
            }
            break;
          case 2:
            switch (s.touches.TWO) {
              case THREE.TOUCH.DOLLY_PAN:
                if (false === s.enableZoom && false === s.enablePan) return;
                !function(e3) {
                  s.enableZoom && U(e3), s.enablePan && G(e3);
                }(e2), d = h.TOUCH_DOLLY_PAN;
                break;
              case THREE.TOUCH.DOLLY_ROTATE:
                if (false === s.enableZoom && false === s.enableRotate) return;
                !function(e3) {
                  s.enableZoom && U(e3), s.enableRotate && F(e3);
                }(e2), d = h.TOUCH_DOLLY_ROTATE;
                break;
              default:
                d = h.NONE;
            }
            break;
          default:
            d = h.NONE;
        }
        d !== h.NONE && s.dispatchEvent(c);
      }
    }
    function J(e2) {
      if (false !== s.enabled)
        switch (e2.preventDefault(), e2.stopPropagation(), d) {
          case h.TOUCH_ROTATE:
            if (false === s.enableRotate) return;
            z(e2), s.update();
            break;
          case h.TOUCH_PAN:
            if (false === s.enablePan) return;
            V(e2), s.update();
            break;
          case h.TOUCH_DOLLY_PAN:
            if (false === s.enableZoom && false === s.enablePan) return;
            !function(e3) {
              s.enableZoom && k(e3), s.enablePan && V(e3);
            }(e2), s.update();
            break;
          case h.TOUCH_DOLLY_ROTATE:
            if (false === s.enableZoom && false === s.enableRotate) return;
            !function(e3) {
              s.enableZoom && k(e3), s.enableRotate && z(e3);
            }(e2), s.update();
            break;
          default:
            d = h.NONE;
        }
    }
    function K(e2) {
      false !== s.enabled && (s.dispatchEvent(u), d = h.NONE);
    }
    function q(e2) {
      false !== s.enabled && e2.preventDefault();
    }
    s.domElement.addEventListener("contextmenu", q, false), s.domElement.addEventListener("mousedown", j, false), s.domElement.addEventListener("wheel", $, false), s.domElement.addEventListener("touchstart", X, false), s.domElement.addEventListener("touchend", K, false), s.domElement.addEventListener("touchmove", J, false), s.domElement.addEventListener("keydown", W, false), -1 === s.domElement.tabIndex && (s.domElement.tabIndex = 0), this.update();
  };
  OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype), OrbitControls.prototype.constructor = OrbitControls;
  var MapControls = function(e, t) {
    OrbitControls.call(this, e, t), this.mouseButtons.LEFT = THREE.MOUSE.PAN, this.mouseButtons.RIGHT = THREE.MOUSE.ROTATE, this.touches.ONE = THREE.TOUCH.PAN, this.touches.TWO = THREE.TOUCH.DOLLY_ROTATE;
  };
  MapControls.prototype = Object.create(THREE.EventDispatcher.prototype), MapControls.prototype.constructor = MapControls;
  var Application = function() {
    function e() {
      this._viewportMode = RUNTIME_VIEWMODE.FULLSCREEN, this._viewportWidth = window.innerWidth, this._viewportHeight = window.innerHeight, this._running = false, this._renderer = null, this._scene = null, this._camera = null, this._controls = null, this._playmode = null, this._postProcessing = null, this._decoder = new GLTFImporter(), window.addEventListener("resize", this.resize.bind(this));
    }
    return e.prototype.start = function(e2, __REACT_SPLINE_EDIT___CANVAS__) {
      var t = this;
      const fetchPromise = new Promise(
        (resolve) => resolve(e2)
      );
      fetchPromise.then(function(e3) {
        var i;
        i = __read(t._decoder.decode(CreateFromJson(e3)), 4), t._scene = i[0], t._camera = i[1], t._exportOptions = i[2], t._sceneOptions = i[3], t.init(__REACT_SPLINE_EDIT___CANVAS__), t._running = true, t.run(), t.resize();
      }).catch(function(e3) {
        console.error(e3);
      });
    }, e.prototype.run = function() {
      requestAnimationFrame(this.run.bind(this)), this.render();
    }, e.prototype.render = function() {
      this._running && (this._renderer ? (this._controls && this._controls.update(), this._playmode && !this._playmode.isEnable && this._playmode.activate(), this._scene && this._camera && (this._postProcessing ? (this._renderer.autoClear = true, this._postProcessing.render()) : (this._renderer.autoClear = true, this._renderer.render(this._scene, this._camera)))) : console.error(
        "Application::render >>> tried to renderer without a renderer"
      ));
    }, e.prototype.resize = function() {
      this._running && this._renderer && (this._viewportMode === RUNTIME_VIEWMODE.FULLSCREEN && (this._viewportWidth = window.innerWidth, this._viewportHeight = window.innerHeight), this._camera && ("PerspectiveCamera" === this._camera.cameraType ? this._camera.aspect = this._viewportWidth / this._viewportHeight : "OrthographicCamera" === this._camera.cameraType && (this._camera.left = -this._viewportWidth / 2, this._camera.right = this._viewportWidth / 2, this._camera.top = this._viewportHeight / 2, this._camera.bottom = -this._viewportHeight / 2), this._camera.updateProjectionMatrix()), this._renderer && this._renderer.setSize(this._viewportWidth, this._viewportHeight));
    }, e.prototype.init = function(__REACT_SPLINE_EDIT___CANVAS__) {
      __REACT_SPLINE_EDIT___CANVAS__ = __REACT_SPLINE_EDIT___CANVAS__ || document.getElementById("canvas3d");
      var e2, t, i, r, n, o, a, s, l, c, u, h, d, f, p, v, m, g, E, y, A, T, x, _, w, S, R, C, O, D = __REACT_SPLINE_EDIT___CANVAS__;
      null !== (i = null === (t = null === (e2 = this._sceneOptions) || void 0 === e2 ? void 0 : e2.postProcessing) || void 0 === t ? void 0 : t.enabled) && void 0 !== i && i ? this._renderer = new THREE.WebGLRenderer({
        canvas: D,
        antialias: false,
        stencil: false,
        depth: false,
        powerPreference: "high-performance"
      }) : this._renderer = new THREE.WebGLRenderer({
        canvas: D,
        antialias: true,
        alpha: true,
        stencil: true,
        depth: true
      });
      var M = null !== (n = null === (r = this._exportOptions) || void 0 === r ? void 0 : r.viewWidth) && void 0 !== n ? n : window.innerWidth, L = null !== (a = null === (o = this._exportOptions) || void 0 === o ? void 0 : o.viewHeight) && void 0 !== a ? a : window.innerHeight, I = null !== (l = null === (s = this._exportOptions) || void 0 === s ? void 0 : s.bgColor) && void 0 !== l ? l : new THREE.Color(1644825), P = null !== (u = null === (c = this._exportOptions) || void 0 === c ? void 0 : c.bgAlpha) && void 0 !== u ? u : 0;
      if (this._viewportWidth = M, this._viewportHeight = L, this._renderer.setPixelRatio(window.devicePixelRatio), this._renderer.setSize(this._viewportWidth, this._viewportHeight), this._renderer.shadowMap.enabled = true, this._renderer.shadowMap.type = THREE.PCFSoftShadowMap, this._renderer.setClearColor(I, P), this._viewportMode = null !== (d = null === (h = this._exportOptions) || void 0 === h ? void 0 : h.viewMode) && void 0 !== d ? d : RUNTIME_VIEWMODE.FULLSCREEN, null === (p = null === (f = this._exportOptions) || void 0 === f ? void 0 : f.useOrbitControls) || void 0 === p || p) {
        this._controls = new OrbitControls(
          this._camera,
          this._renderer.domElement
        ), this._controls.target.copy(
          null !== (m = null === (v = this._exportOptions) || void 0 === v ? void 0 : v.orbitTarget) && void 0 !== m ? m : new THREE.Vector3()
        ), this._controls.enableRotate = null !== (E = null === (g = this._exportOptions) || void 0 === g ? void 0 : g.cameraRotate) && void 0 !== E && E, this._controls.enablePan = null !== (A = null === (y = this._exportOptions) || void 0 === y ? void 0 : y.cameraPan) && void 0 !== A && A, this._controls.enableZoom = null !== (x = null === (T = this._exportOptions) || void 0 === T ? void 0 : T.cameraZoom) && void 0 !== x && x, this._controls.enableDamping = null !== (w = null === (_ = this._exportOptions) || void 0 === _ ? void 0 : _.orbitDamped) && void 0 !== w && w;
        null === (S = this._exportOptions) || void 0 === S ? void 0 : S.orbitDamped;
        this._controls.rotateSpeed = 1, this._controls.panSpeed = 1;
      }
      if (this._playmode = new PlayMode(
        this._renderer.domElement,
        this._scene,
        this._camera
      ), null === (R = this._sceneOptions) || void 0 === R ? void 0 : R.fog) {
        var B = this._sceneOptions.fog, H = new THREE.Fog(B.color.getHex(), B.near, B.far);
        this._scene.fog = H;
      }
      if (null === (C = this._sceneOptions) || void 0 === C ? void 0 : C.fogExp2) {
        B = this._sceneOptions.fogExp2, H = new THREE.FogExp2(B.color.getHex(), B.density);
        this._scene.fog = H;
      }
      (null === (O = this._sceneOptions) || void 0 === O ? void 0 : O.postProcessing) && this._sceneOptions.postProcessing.enabled && (this._postProcessing = new Post(), this._postProcessing.fromJSON(
        this._sceneOptions.postProcessing.data
      ), this._postProcessing.init({
        renderer: this._renderer,
        camera: this._camera,
        scene: this._scene
      }));
    }, e;
  }(), _canvas;
  return THREE.ImageUtils.getDataURL = function(e) {
    if (/^data:/i.test(e.src)) return e.src;
    if ("undefined" == typeof HTMLCanvasElement) return e.src;
    var t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      void 0 === _canvas && (_canvas = document.createElementNS(
        "http://www.w3.org/1999/xhtml",
        "canvas"
      )), _canvas.width = e.width, _canvas.height = e.height;
      var i = _canvas.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = _canvas;
    }
    return t.toDataURL("image/png");
  }, exports.Application = Application, Object.defineProperty(exports, "__esModule", { value: true }), exports;
};
var SpeRuntime = speRuntimeFactory({}, window.THREE);
var Spline = {
  render: function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { style: _vm.containerStyle, attrs: { "className": _vm.className } }, [_c("canvas", { ref: "spline", style: _vm.canvasStyle, attrs: { "id": _vm.id } })]);
  },
  staticRenderFns: [],
  props: {
    id: {
      type: String
    },
    scene: {
      type: Object
    },
    className: {
      type: String
    },
    canvasStyle: {
      type: Object,
      default: () => {
        return { height: "100%", width: "100%", outline: "none" };
      }
    },
    containerStyle: {
      type: Object,
      default: () => {
        return {
          width: "100%",
          height: "100%",
          overflow: "hidden",
          position: "relative"
        };
      }
    }
  },
  mounted() {
    new SpeRuntime.Application().start(this.scene, this.$refs.spline);
  }
};
var dist_default = Spline;
export {
  dist_default as default
};
/*! Bundled license information:

vue-spline/dist/index.js:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)
*/
//# sourceMappingURL=vue-spline.js.map
